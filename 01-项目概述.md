# 01. 项目概述

---

## 1.1 项目背景与目标

### 背景

SyncTV 是一个实时同步观影平台，允许多个用户在同一房间内同步观看视频内容。当前 Go 版本存在以下问题：

1. **架构限制**：单实例部署，无法水平扩展
2. **性能瓶颈**：高并发场景下性能不足
3. **代码质量**：缺乏类型安全，维护困难
4. **功能扩展性差**：视频解析、代理等模块耦合严重

### 目标

使用 Rust 重构 SyncTV，实现：

- ✅ **高性能**：利用 Rust 的零成本抽象和异步运行时
- ✅ **类型安全**：编译期错误检查，减少运行时错误
- ✅ **水平扩展**：支持 Kubernetes 多副本部署
- ✅ **高可用**：副本故障自动处理，99.9% SLA
- ✅ **易维护**：模块化设计，清晰的代码结构

---

## 1.2 核心特性

### 1.2.1 房间管理

**功能**：

- 创建/删除房间
- 房间密码保护
- 成员权限管理（创建者、管理员、普通成员）
- 房间设置（隐藏、游客加入等）

**权限系统** (详见 [07-权限系统设计](./07-权限系统设计.md)):

- **角色与状态分离**: UserRole (root/admin/user) 独立于 UserStatus (active/pending/banned)
- **64位权限位掩码**: 细粒度控制，支持64种权限组合
- **清晰的权限继承**: Creator → Custom → Role Default → Global Default
- **Telegram风格设计**: 房间默认权限 + 个人自定义权限

```rust
pub struct Permissions(pub u64);

impl Permissions {
    // ===== 内容管理权限 (0-9) =====
    pub const SEND_CHAT: u64 = 1 << 0;
    pub const ADD_MOVIE: u64 = 1 << 1;
    pub const DELETE_MOVIE_SELF: u64 = 1 << 2;
    pub const DELETE_MOVIE_ANY: u64 = 1 << 3;
    pub const EDIT_MOVIE_SELF: u64 = 1 << 4;
    pub const EDIT_MOVIE_ANY: u64 = 1 << 5;
    pub const REORDER_PLAYLIST: u64 = 1 << 6;
    pub const CLEAR_PLAYLIST: u64 = 1 << 7;

    // ===== 播放控制权限 (10-19) =====
    pub const PLAY_CONTROL: u64 = 1 << 10;
    pub const CHANGE_CURRENT_MOVIE: u64 = 1 << 11;
    pub const CHANGE_PLAYBACK_RATE: u64 = 1 << 12;

    // ===== 成员管理权限 (20-29) =====
    pub const APPROVE_MEMBER: u64 = 1 << 20;
    pub const KICK_MEMBER: u64 = 1 << 21;
    pub const BAN_MEMBER: u64 = 1 << 22;
    pub const SET_MEMBER_PERMISSIONS: u64 = 1 << 23;
    pub const MANAGE_ADMIN: u64 = 1 << 24;

    // ===== 房间管理权限 (30-39) =====
    pub const SET_ROOM_SETTINGS: u64 = 1 << 30;
    pub const SET_ROOM_PASSWORD: u64 = 1 << 31;
    pub const DELETE_CHAT: u64 = 1 << 32;
    pub const VIEW_STATS: u64 = 1 << 33;
    pub const EXPORT_DATA: u64 = 1 << 34;
    pub const DELETE_ROOM: u64 = 1 << 35;

    // ===== 查看权限 (40-49) =====
    pub const VIEW_PLAYLIST: u64 = 1 << 40;
    pub const VIEW_MEMBER_LIST: u64 = 1 << 41;
    pub const VIEW_CHAT_HISTORY: u64 = 1 << 42;

    // ===== 通信权限 (50-59) =====
    pub const USE_WEBRTC: u64 = 1 << 50;

    // 详细定义见 07-权限系统设计.md
}
```

### 1.2.2 播放同步

**同步控制**：

- 播放/暂停同步
- 跳转时间同步
- 播放速率同步（0.5x - 2.0x）
- 影片切换同步

**实时性保证**：

- gRPC Bidirectional Streaming（主通道）+ gRPC-Web（浏览器支持）
- WebSocket（可选兼容层，用于不支持 gRPC-Web 的旧客户端）
- 延迟 < 50ms
- 断线重连自动恢复

### 1.2.3 视频内容管理

**支持的视频源**：

- 直接链接（.mp4, .mkv 等）
- Bilibili 视频/番剧
- Alist 网盘
- Emby 媒体服务器
- 自定义视频源（插件化）

**代理功能**：

- 多级缓存（内存 + Redis + 文件）
- 请求去重（避免重复下载）
- 布隆过滤器（防缓存穿透）
- 自动重试与降级

**字幕支持**：

- SRT、VTT、ASS 格式
- 格式自动转换
- 字幕代理服务
- 多语言字幕

### 1.2.4 实时互动

**聊天系统**：

- 实时文本聊天
- 系统消息通知
- 聊天历史（最近500条）
- 消息删除（管理员）

**弹幕系统**：

- 实时弹幕显示
- 三种位置（滚动、顶部、底部）
- 颜色和大小自定义
- Bilibili 直播弹幕转发
- **仅内存存储**（最近10秒）

### 1.2.5 直播推流

**支持协议**：

- RTMP 推流
- HLS 播放（低延迟 < 3s）
- FLV 播放

**直播特性**：

- 任意副本接受推流
- Publisher 节点记录
- 跨副本流转发
- GOP 缓存（2个GOP）

---

## 1.3 性能指标

### 并发能力

| 指标 | 目标值 | 测试条件 |
|-----|-------|---------|
| 并发连接数 | 1000+ | 单副本，4核8G |
| 并发直播流 | 50+ | 单副本 |
| 房间数量 | 500+ | 活跃房间 |
| 实时连接 | 2000+ | 跨多个房间（gRPC/WebSocket） |

### 延迟指标

| 指标 | 目标值 | 说明 |
|-----|-------|-----|
| 实时消息延迟 | < 50ms | P95（gRPC Streaming 主通道） |
| HTTP API 响应 | < 200ms | P95 |
| 直播延迟 | < 3s | HLS 播放 |
| 播放同步误差 | < 100ms | 跨副本 |

### 可用性指标

| 指标 | 目标值 |
|-----|-------|
| SLA | 99.9% |
| 副本故障恢复 | < 30s |
| 滚动更新零停机 | 100% |
| 数据持久性 | 99.99% |

### 资源消耗

| 资源 | 单副本消耗 | 说明 |
|-----|-----------|-----|
| CPU | 1-2 核 | 空闲 0.2 核，峰值 2 核 |
| 内存 | 2-4 GB | 包含缓存 |
| 网络 | 100 Mbps | 50 并发流 |
| 存储 | 50 GB | HLS 缓存 |

---

## 1.4 技术栈选型

### 1.4.1 后端核心

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **Rust** | 1.75+ | 开发语言 | 高性能、类型安全、零成本抽象 |
| **Tokio** | 1.35 | 异步运行时 | 成熟稳定、高性能、生态丰富 |
| **Axum** | 0.7 | Web 框架 | 类型安全、性能优秀、易用性好 |

**选择 Rust 的原因**：

- ✅ 性能接近 C/C++，远超 Go
- ✅ 内存安全，无 GC 停顿
- ✅ 强大的类型系统，编译期错误检查
- ✅ 优秀的异步支持（async/await）
- ✅ 成熟的生态系统

### 1.4.2 数据存储

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **PostgreSQL** | 15 | 主数据库 | 可靠性高、功能丰富、性能优秀 |
| **SQLx** | 0.7 | 数据库 ORM | 编译期 SQL 验证、异步支持 |
| **Redis** | 7 | 缓存/消息 | 高性能、丰富的数据结构、Pub/Sub |

**为什么选择 PostgreSQL**：

- ✅ ACID 事务保证
- ✅ 丰富的索引类型
- ✅ 触发器和存储过程
- ✅ JSON 支持（灵活的扩展字段）

### 1.4.3 流媒体

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **xiu** | latest | 流媒体引擎 | 纯 Rust、支持 RTMP/HLS/FLV、内置流转发 |

**为什么选择 xiu**：

- ✅ 纯 Rust 实现，易于集成
- ✅ 支持 RTMP 推流
- ✅ 支持 HLS/FLV 播放
- ✅ 内置 GOP 缓存
- ✅ 内置流转发功能（Pull/Push Relay）
- ✅ HTTP API 和 WebHook 支持

**vs 自己实现 livelib**：

- 节省 6-8 周开发时间
- 代码质量更高
- 社区支持

### 1.4.4 通信协议

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **tonic** | 0.11 | gRPC 框架（主通道） | 高性能、类型安全、Bidirectional Streaming |
| **tonic-web** | 0.11 | gRPC-Web | 浏览器支持、HTTP/1.1 兼容 |
| **WebSocket** | - | 兼容层（可选） | 支持不兼容 gRPC-Web 的旧客户端 |

### 1.4.5 序列化

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **serde** | 1.0 | 序列化框架 | Rust 标准、零拷贝、多格式支持 |
| **serde_json** | 1.0 | JSON | API 响应、配置文件 |
| **prost** | 0.12 | Protobuf | gRPC 消息 |

### 1.4.6 并发与缓存

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **dashmap** | 5 | 并发 Map | 无锁、高性能 |
| **parking_lot** | 0.12 | 锁原语 | 比标准库更快 |
| **lru** | 0.12 | LRU 缓存 | 简单易用 |
| **moka** | 0.12 | 高级缓存 | TTL、过期策略 |

### 1.4.7 日志与追踪

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **tracing** | 0.1 | 结构化日志 | 异步友好、分布式追踪 |
| **tracing-subscriber** | 0.3 | 日志订阅 | 灵活的输出配置 |

### 1.4.8 安全

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **jsonwebtoken** | 9 | JWT | 成熟稳定 |
| **argon2** | 0.5 | 密码哈希 | 安全性高、抗暴力破解 |
| **aes-gcm** | 0.10 | 数据加密 | AEAD、安全性高 |
| **ammonia** | 3 | HTML 清理 | 防 XSS |

### 1.4.9 部署

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|-----|---------|
| **Kubernetes** | 1.28+ | 容器编排 | 标准化、自动扩缩容、故障恢复 |
| **Docker** | latest | 容器化 | 标准容器格式 |
| **Prometheus** | latest | 监控 | 云原生监控标准 |
| **Grafana** | latest | 可视化 | 丰富的图表 |

---

## 1.5 项目结构

```
synctv/
├── Cargo.toml                 # Workspace 配置
├── Cargo.lock
├── docs/                      # 设计文档
│   ├── 01-项目概述.md
│   ├── 02-整体架构.md
│   └── ...
│
├── synctv-core/              # 核心库
│   ├── Cargo.toml
│   └── src/
│       ├── models/           # 数据模型
│       ├── repository/       # 数据访问层
│       ├── service/          # 业务逻辑层
│       ├── cache/            # 缓存模块
│       └── lib.rs
│
├── synctv-api/               # API 服务
│   ├── Cargo.toml
│   └── src/
│       ├── routes/           # 路由定义
│       ├── handlers/         # 请求处理器
│       ├── middleware/       # 中间件
│       ├── ws/               # WebSocket
│       └── main.rs
│
├── synctv-stream/            # 流媒体服务
│   ├── Cargo.toml
│   └── src/
│       ├── xiu_integration/  # xiu 集成
│       ├── relay/            # 流转发
│       ├── cache/            # GOP 缓存
│       └── lib.rs
│
├── synctv-cluster/           # 集群模块
│   ├── Cargo.toml
│   └── src/
│       ├── sync/             # 集群同步
│       ├── discovery/        # 服务发现
│       ├── grpc/             # gRPC 通信
│       └── lib.rs
│
├── proto/                    # gRPC proto 定义
│   ├── cluster.proto
│   └── stream.proto
│
├── migrations/               # 数据库迁移
│   ├── 20240101_initial.sql
│   └── ...
│
└── k8s/                      # Kubernetes 配置
    ├── deployment.yaml
    ├── service.yaml
    └── ...
```

---

## 1.6 开发规范

### 代码风格

- 遵循 [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- 使用 `rustfmt` 自动格式化
- 使用 `clippy` 静态检查
- 所有公开 API 必须有文档注释

### 提交规范

```
type(scope): subject

body

footer
```

**类型**：

- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试

### 测试要求

- 单元测试覆盖率 > 70%
- 所有 public API 必须有测试
- 集成测试覆盖关键流程

---

**下一章**: [02-整体架构](./02-整体架构.md)
