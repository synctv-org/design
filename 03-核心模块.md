# 03. 核心模块设计

---

> **ID 策略说明**：本系统采用双层 ID 设计：
>
> - **数据库层**：使用 UUID 作为主键（标准化、易扩展）
> - **API/缓存层**：使用 nanoid 作为外部标识符（更短、URL友好）
> - **Service 层**：所有函数接受 `&str` (nanoid)，内部通过 IdMapper 转换为 UUID
> - **数据模型**：包含 `id: String` (nanoid, 序列化到API) 和 `uuid: Uuid` (#[serde(skip)], 仅数据库使用)
>
> 详见 [§ 3.8 ID 映射层](#38-id-映射层)

## 3.1 模块架构图

```
synctv/
├── src/
│   ├── main.rs                     # 应用入口，启动所有服务
│   ├── lib.rs                      # 库入口，导出公共 API
│   │
│   ├── config/                     # 配置模块 ⭐
│   │   ├── mod.rs                  # 配置聚合
│   │   ├── app.rs                  # 应用配置
│   │   ├── database.rs             # 数据库配置
│   │   ├── redis.rs                # Redis 配置
│   │   ├── cluster.rs              # 集群配置
│   │   ├── live.rs                 # 直播配置
│   │   └── loader.rs               # 配置加载器（支持环境变量、文件、CLI）
│   │
│   ├── grpc/                       # gRPC 服务层 ⭐⭐
│   │   ├── mod.rs                  # gRPC 服务聚合
│   │   ├── client.rs               # 客户端服务实现
│   │   ├── cluster.rs              # 集群服务实现
│   │   ├── stream.rs               # 流转发服务实现
│   │   ├── interceptor/            # gRPC 拦截器
│   │   │   ├── mod.rs
│   │   │   ├── auth.rs             # JWT 认证拦截器
│   │   │   ├── logging.rs          # 请求日志拦截器
│   │   │   └── rate_limit.rs       # 限流拦截器
│   │   └── streaming/              # 实时流处理
│   │       ├── mod.rs
│   │       ├── message_stream.rs   # 消息流处理
│   │       └── room_hub.rs         # 房间消息管理
│   │
│   ├── http/                       # HTTP API 层 (辅助)
│   │   ├── mod.rs                  # HTTP 路由聚合
│   │   ├── health.rs               # 健康检查
│   │   ├── metrics.rs              # Prometheus 指标
│   │   ├── admin.rs                # 管理后台 API
│   │   ├── oauth.rs                # OAuth2 认证
│   │   └── middleware/             # HTTP 中间件
│   │       ├── mod.rs
│   │       ├── cors.rs             # CORS 处理
│   │       └── auth.rs             # 管理员认证
│   │
│   ├── service/                    # 业务逻辑层 ⭐
│   │   ├── mod.rs
│   │   ├── user_service.rs         # 用户服务
│   │   ├── room_service.rs         # 房间服务
│   │   ├── member_service.rs       # 成员服务
│   │   ├── movie_service.rs        # 内容服务
│   │   ├── live_service.rs         # 直播服务
│   │   └── admin_service.rs        # 管理服务
│   │
│   ├── model/                      # 数据模型 ⭐
│   │   ├── mod.rs
│   │   ├── user.rs                 # 用户模型
│   │   ├── room.rs                 # 房间模型
│   │   ├── member.rs               # 成员模型
│   │   ├── movie.rs                # 内容模型
│   │   ├── stream.rs               # 直播流模型
│   │   ├── permission.rs           # 权限定义
│   │   └── pagination.rs           # 分页模型
│   │
│   ├── db/                         # 数据访问层 ⭐
│   │   ├── mod.rs                  # 数据库初始化
│   │   ├── connection.rs           # 连接池管理
│   │   ├── user_repo.rs            # 用户仓储
│   │   ├── room_repo.rs            # 房间仓储
│   │   ├── member_repo.rs          # 成员仓储
│   │   ├── movie_repo.rs           # 内容仓储
│   │   └── stream_repo.rs          # 流仓储
│   │
│   ├── sync/                       # 集群同步模块 ⭐⭐
│   │   ├── mod.rs
│   │   ├── cluster_sync.rs         # 集群事件同步 (Redis Pub/Sub) ⭐⭐⭐
│   │   ├── event.rs                # 集群事件定义
│   │   ├── room_state.rs           # 房间状态管理
│   │   └── event_handler.rs        # 事件处理器
│   │
│   ├── cluster/                    # 集群管理模块 ⭐⭐⭐
│   │   ├── mod.rs
│   │   ├── registry.rs             # 节点注册表
│   │   ├── discovery/              # 服务发现
│   │   │   ├── mod.rs
│   │   │   ├── kubernetes.rs       # K8s 服务发现
│   │   │   └── static.rs           # 静态配置
│   │   ├── heartbeat.rs            # 心跳检测
│   │   └── rpc/                    # gRPC 通信
│   │       ├── mod.rs
│   │       ├── client.rs           # gRPC 客户端
│   │       ├── server.rs           # gRPC 服务器
│   │       └── proto/              # Protobuf 定义
│   │           ├── cluster.proto
│   │           ├── sync.proto
│   │           └── stream.proto
│   │
│   ├── live/                       # 直播模块 ⭐⭐⭐
│   │   ├── mod.rs
│   │   ├── xiu_integration.rs      # xiu 集成层
│   │   ├── notifier.rs             # xiu 事件监听器
│   │   ├── stream/                 # 流管理
│   │   │   ├── mod.rs
│   │   │   ├── manager.rs          # 流管理器
│   │   │   ├── local_stream.rs     # 本地流（Publisher 节点）
│   │   │   ├── pull_stream.rs      # 拉流实例（主动拉取）⭐
│   │   │   ├── pull_manager.rs     # 拉流管理器 ⭐
│   │   │   ├── relay.rs            # 流转发器
│   │   │   └── state.rs            # 流状态机
│   │   ├── hls/                    # HLS 处理
│   │   │   ├── mod.rs
│   │   │   ├── proxy.rs            # HLS 透传代理 ⭐
│   │   │   ├── storage.rs          # OSS 存储接口 ⭐
│   │   │   └── cache.rs            # 本地缓存
│   │   ├── flv/                    # FLV 处理 ⭐
│   │   │   ├── mod.rs
│   │   │   ├── handler.rs          # FLV 请求处理
│   │   │   └── writer.rs           # FLV 数据写入
│   │   └── auth.rs                 # 推流认证
│   │
│   ├── providers/                  # 视频解析器模块 ⭐⭐⭐
│   │   ├── mod.rs                  # Provider 导出
│   │   ├── registry.rs             # Provider 注册表（Factory 模式）⭐
│   │   ├── traits.rs               # MediaProvider trait 定义
│   │   ├── config.rs               # Provider 配置系统
│   │   ├── context.rs              # ProviderContext 上下文
│   │   ├── bilibili/               # Bilibili Provider
│   │   │   ├── mod.rs
│   │   │   ├── parser.rs           # 视频解析
│   │   │   ├── proxy.rs            # MPD/Segment 代理
│   │   │   └── danmu.rs            # 弹幕处理
│   │   ├── alist/                  # Alist Provider
│   │   │   ├── mod.rs
│   │   │   ├── parser.rs           # 文件解析
│   │   │   ├── proxy.rs            # 流代理
│   │   │   └── m3u8.rs             # M3U8 处理
│   │   ├── emby/                   # Emby Provider
│   │   │   ├── mod.rs
│   │   │   ├── parser.rs           # 媒体库解析
│   │   │   ├── proxy.rs            # 转码代理
│   │   │   └── hooks.rs            # 生命周期钩子
│   │   ├── direct_url/             # 直接 URL Provider
│   │   │   └── mod.rs
│   │   └── rtmp/                   # RTMP Provider
│   │       └── mod.rs
│   │
│   ├── cache/                      # 缓存模块 ⭐
│   │   ├── mod.rs
│   │   ├── redis.rs                # Redis 客户端封装
│   │   ├── local.rs                # 本地内存缓存（LRU）
│   │   ├── distributed.rs          # 分布式缓存
│   │   └── strategy.rs             # 缓存策略
│   │
│   ├── auth/                       # 认证与授权 ⭐
│   │   ├── mod.rs
│   │   ├── jwt.rs                  # JWT 生成和验证
│   │   ├── password.rs             # 密码哈希
│   │   ├── token.rs                # Token 管理
│   │   └── permission.rs           # 权限检查
│   │
│   └── utils/                      # 工具模块
│       ├── mod.rs
│       ├── time.rs                 # 时间工具
│       ├── hash.rs                 # 哈希工具
│       ├── validator.rs            # 输入验证
│       └── id.rs                   # ID 生成（Snowflake）
│
├── proto/                          # gRPC Proto 定义
│   ├── cluster.proto               # 集群通信协议
│   ├── sync.proto                  # 数据同步协议
│   └── stream.proto                # 流转发协议
│
├── migrations/                     # 数据库迁移
│   ├── 20240101000000_init.sql
│   ├── 20240102000000_add_streams.sql
│   └── ...
│
├── config/                         # 配置文件
│   ├── default.toml                # 默认配置
│   ├── development.toml            # 开发环境
│   ├── production.toml             # 生产环境
│   └── test.toml                   # 测试环境
│
├── tests/                          # 集成测试
│   ├── api_tests.rs
│   ├── cluster_tests.rs
│   └── live_tests.rs
│
├── benches/                        # 性能测试
│   ├── grpc_streaming_bench.rs
│   └── stream_bench.rs
│
├── Cargo.toml                      # 项目配置
├── Cargo.lock                      # 依赖锁定
├── build.rs                        # 构建脚本（生成 Proto）
├── Dockerfile                      # Docker 镜像
└── README.md                       # 项目说明
```

## 3.2 gRPC 服务层

### 3.2.1 客户端服务实现

```rust
// grpc/client.rs
use tonic::{Request, Response, Status};
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;

pub struct ClientServiceImpl {
    room_hub: Arc<RoomMessageHub>,
    user_service: Arc<UserService>,
    room_service: Arc<RoomService>,
}

#[tonic::async_trait]
impl ClientService for ClientServiceImpl {
    // 实时消息流（双向流）
    type MessageStreamStream = ReceiverStream<Result<ServerMessage, Status>>;

    async fn message_stream(
        &self,
        request: Request<tonic::Streaming<ClientMessage>>,
    ) -> Result<Response<Self::MessageStreamStream>, Status> {
        // 1. 从 metadata 提取并验证 JWT
        let token = extract_jwt_from_metadata(request.metadata())?;
        let user_id = verify_jwt_token(&token)?;

        // 2. 创建双向通道
        let mut client_stream = request.into_inner();
        let (tx, rx) = mpsc::channel(100);

        // 3. 启动消息处理任务
        let room_hub = self.room_hub.clone();
        tokio::spawn(async move {
            handle_client_messages(client_stream, tx, user_id, room_hub).await
        });

        Ok(Response::new(ReceiverStream::new(rx)))
    }

    // 登录
    async fn login(
        &self,
        request: Request<LoginRequest>,
    ) -> Result<Response<LoginResponse>, Status> {
        let req = request.into_inner();

        let (user, tokens) = self.user_service
            .login(&req.username, &req.password)
            .await
            .map_err(|e| Status::unauthenticated(e.to_string()))?;

        Ok(Response::new(LoginResponse {
            user: Some(user.into()),
            access_token: tokens.access_token,
            refresh_token: tokens.refresh_token,
            expires_in: tokens.expires_in,
        }))
    }

    // 创建房间
    async fn create_room(
        &self,
        request: Request<CreateRoomRequest>,
    ) -> Result<Response<CreateRoomResponse>, Status> {
        let user_id = extract_user_from_request(&request)?;
        let req = request.into_inner();

        let room = self.room_service
            .create_room(user_id, req)
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        Ok(Response::new(CreateRoomResponse {
            room: Some(room.into()),
        }))
    }

    // ... 其他 RPC 方法
}

// JWT 认证辅助函数
fn extract_jwt_from_metadata(metadata: &MetadataMap) -> Result<String, Status> {
    metadata
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.strip_prefix("Bearer "))
        .map(|s| s.to_string())
        .ok_or_else(|| Status::unauthenticated("Missing or invalid authorization header"))
}

fn extract_user_from_request<T>(request: &Request<T>) -> Result<Uuid, Status> {
    let token = extract_jwt_from_metadata(request.metadata())?;
    verify_jwt_token(&token)
}
```

### 3.2.2 gRPC 拦截器

```rust
// grpc/interceptor/auth.rs
use tonic::{Request, Status};

/// JWT 认证拦截器
pub fn auth_interceptor(mut req: Request<()>) -> Result<Request<()>, Status> {
    let metadata = req.metadata();

    // 提取 token
    let token = metadata
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.strip_prefix("Bearer "))
        .ok_or_else(|| Status::unauthenticated("Missing authorization"))?;

    // 验证 token
    let claims = verify_jwt_token(token)
        .map_err(|_| Status::unauthenticated("Invalid token"))?;

    // 将 user_id 注入到 extensions
    req.extensions_mut().insert(claims.user_id);

    Ok(req)
}

// grpc/interceptor/logging.rs
use tracing::{info, error};

/// 请求日志拦截器
pub fn logging_interceptor<T>(req: Request<T>) -> Result<Request<T>, Status> {
    let path = req.uri().path();
    let metadata = req.metadata();

    info!(
        path = %path,
        user_agent = ?metadata.get("user-agent"),
        "Received gRPC request"
    );

    Ok(req)
}

// grpc/interceptor/rate_limit.rs
use governor::{Quota, RateLimiter};
use std::num::NonZeroU32;

/// 限流拦截器
pub struct RateLimitInterceptor {
    limiter: Arc<RateLimiter<String, DefaultKeyedStateStore<String>, DefaultClock>>,
}

impl RateLimitInterceptor {
    pub fn intercept<T>(&self, req: Request<T>) -> Result<Request<T>, Status> {
        // 从 metadata 提取用户标识
        let user_id = req.extensions()
            .get::<Uuid>()
            .map(|id| id.to_string())
            .unwrap_or_else(|| "anonymous".to_string());

        // 检查限流
        if self.limiter.check_key(&user_id).is_err() {
            return Err(Status::resource_exhausted("Rate limit exceeded"));
        }

        Ok(req)
    }
}
```

### 3.2.3 混合服务器启动

```rust
// main.rs
use tonic::transport::Server;

#[tokio::main]
async fn main() -> Result<()> {
    let addr = "0.0.0.0:8080".parse()?;

    // 1. 创建 gRPC 服务
    let client_service = ClientServiceServer::new(ClientServiceImpl::new(...));
    let cluster_service = ClusterServiceServer::new(ClusterServiceImpl::new(...));

    // 2. 创建 gRPC 路由
    let grpc_router = Server::builder()
        .add_service(client_service)
        .add_service(cluster_service)
        .into_router();

    // 3. 添加 HTTP 路由
    let app = grpc_router
        .into_axum_router()
        .route("/health", get(health_check))
        .route("/metrics", get(metrics))
        .route("/api/admin/rooms", get(list_rooms))
        .with_state(app_state);

    // 4. 启动混合服务器
    tracing::info!("Starting server on {}", addr);

    Server::builder()
        .accept_http1(true)  // 支持 HTTP/1.1
        .add_routes(app.into())
        .serve(addr)
        .await?;

    Ok(())
}
```

## 3.3 业务逻辑层

### 3.3.1 房间服务

```rust
// service/room_service.rs
use crate::db::RoomRepository;
use crate::model::{Room, RoomSettings, CreateRoomRequest};
use crate::sync::ClusterSync;

pub struct RoomService {
    room_repo: Arc<RoomRepository>,
    cluster_sync: Arc<ClusterSync>,
    redis: deadpool_redis::Pool,
}

impl RoomService {
    pub fn new(
        room_repo: Arc<RoomRepository>,
        cluster_sync: Arc<ClusterSync>,
        redis: deadpool_redis::Pool,
    ) -> Self {
        Self {
            room_repo,
            cluster_sync,
            redis,
        }
    }

    // 创建房间
    pub async fn create_room(
        &self,
        creator_id: &str,  // nanoid string
        request: CreateRoomRequest,
    ) -> Result<Room> {
        // 内部转换 nanoid 到 UUID
        let creator_uuid = id_mapper.nanoid_to_uuid(creator_id)?;
        // 验证输入
        request.validate()?;

        // 创建房间
        let room = self.room_repo.create(Room {
            name: request.name,
            creator_id: creator_uuid,
            status: RoomStatus::Active,
            password_hash: request.password.map(|p| hash_password(&p)),
            settings: request.settings.unwrap_or_default(),
            ..Default::default()
        }).await?;

        // 创建房间状态
        self.room_repo.create_state(&room.id).await?;

        // 发布集群事件
        self.cluster_sync.publish(ClusterEvent::RoomCreated {
            room_id: room.id.clone(),
            creator_id: creator_id.to_string(),
        }).await?;

        Ok(room)
    }

    // 获取房间详情
    pub async fn get_room(&self, room_id: &str) -> Result<Room> {  // nanoid string
        // 先查询缓存
        let cache_key = format!("room:{}", room_id);
        if let Some(cached) = self.get_cached_room(&cache_key).await? {
            return Ok(cached);
        }

        // 查询数据库
        let room = self.room_repo.get(room_id).await?
            .ok_or(Error::RoomNotFound)?;

        // 写入缓存（TTL 5 分钟）
        self.cache_room(&cache_key, &room, 300).await?;

        Ok(room)
    }

    // 更新房间设置
    pub async fn update_settings(
        &self,
        room_id: &str,      // nanoid string
        user_id: &str,      // nanoid string
        settings: RoomSettings,
    ) -> Result<()> {
        // 检查权限（创建者或管理员）
        self.check_admin_permission(room_id, user_id).await?;

        // 更新数据库
        self.room_repo.update_settings(room_id, settings.clone()).await?;

        // 清除缓存
        self.invalidate_room_cache(room_id).await?;

        // 发布集群事件
        self.cluster_sync.publish(ClusterEvent::RoomSettingsChanged {
            room_id: room_id.to_string(),
            settings,
        }).await?;

        Ok(())
    }

    // 获取房间在线人数（从 Redis）
    pub async fn get_viewer_count(&self, room_id: &str) -> Result<usize> {  // nanoid string
        let mut conn = self.redis.get().await?;

        let key = format!("room:viewers:{}", room_id);
        let count: Option<usize> = redis::cmd("GET")
            .arg(&key)
            .query_async(&mut conn)
            .await?;

        Ok(count.unwrap_or(0))
    }
}
```

### 3.3.2 成员服务

```rust
// service/member_service.rs
use crate::model::{Member, MemberPermission, MemberStatus};

pub struct MemberService {
    member_repo: Arc<MemberRepository>,
    user_repo: Arc<UserRepository>,
    room_repo: Arc<RoomRepository>,
    cluster_sync: Arc<ClusterSync>,
}

impl MemberService {
    // 加入房间
    pub async fn join_room(
        &self,
        room_id: &str,      // nanoid string
        user_id: &str,      // nanoid string
        password: Option<String>,
    ) -> Result<Member> {
        // 内部转换 nanoid 到 UUID
        let user_uuid = id_mapper.nanoid_to_uuid(user_id)?;
        // Step 1: 检查房间是否存在
        let room = self.room_repo.get(room_id).await?
            .ok_or(Error::RoomNotFound)?;

        // Step 2: 检查密码（如果房间有密码）
        if let Some(hash) = &room.password_hash {
            let pwd = password.ok_or(Error::PasswordRequired)?;
            if !verify_password(&pwd, hash)? {
                return Err(Error::PasswordIncorrect);
            }
        }

        // Step 3: 检查是否已是成员
        if let Some(member) = self.member_repo.get(room_id, user_uuid).await? {
            if member.status == MemberStatus::Banned {
                return Err(Error::MemberBanned);
            }
            return Ok(member);
        }

        // Step 4: 创建成员记录
        let member = self.member_repo.create(Member {
            room_id: room_id.to_string(),
            user_id: user_uuid,
            status: MemberStatus::Active,
            permissions: self.get_default_permissions(&room),
            admin_permissions: 0,
            joined_at: Utc::now(),
        }).await?;

        // Step 5: 发布集群事件
        self.cluster_sync.publish(ClusterEvent::MemberJoined {
            room_id: room_id.to_string(),
            user_id: user_id.to_string(),
        }).await?;

        Ok(member)
    }

    // 更新成员权限
    pub async fn update_permissions(
        &self,
        room_id: &str,          // nanoid string
        target_user_id: &str,   // nanoid string
        operator_id: &str,      // nanoid string
        permissions: u64,
        admin_permissions: u64,
    ) -> Result<()> {
        // 内部转换 nanoid 到 UUID
        let target_uuid = id_mapper.nanoid_to_uuid(target_user_id)?;
        let operator_uuid = id_mapper.nanoid_to_uuid(operator_id)?;

        // 检查操作者权限
        self.check_admin_or_creator(room_id, operator_id).await?;

        // 不能修改创建者权限
        let room = self.room_repo.get(room_id).await?.unwrap();
        if room.creator_id == target_uuid {
            return Err(Error::CannotModifyCreatorPermissions);
        }

        // 更新权限
        self.member_repo.update_permissions(
            room_id,
            target_uuid,
            permissions,
            admin_permissions,
        ).await?;

        // 发布事件
        self.cluster_sync.publish(ClusterEvent::MemberPermissionsChanged {
            room_id: room_id.to_string(),
            user_id: target_user_id.to_string(),
            permissions,
            admin_permissions,
        }).await?;

        Ok(())
    }
}
```

## 3.4 数据访问层

### 3.4.1 仓储模式

```rust
// db/mod.rs
use sqlx::PgPool;

#[async_trait]
pub trait Repository<T, ID>: Send + Sync {
    async fn get(&self, id: ID) -> Result<Option<T>>;
    async fn create(&self, entity: T) -> Result<T>;
    async fn update(&self, id: ID, entity: T) -> Result<()>;
    async fn delete(&self, id: ID) -> Result<()>;
}

// db/user_repo.rs
pub struct UserRepository {
    pool: PgPool,
}

impl UserRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    pub async fn get(&self, id: Uuid) -> Result<Option<User>> {
        let user = sqlx::query_as!(
            User,
            r#"
            SELECT id, username, email, password_hash, role as "role: UserRole",
                   avatar_url, created_at, updated_at
            FROM users
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    pub async fn get_by_username(&self, username: &str) -> Result<Option<User>> {
        let user = sqlx::query_as!(
            User,
            r#"
            SELECT id, username, email, password_hash, role as "role: UserRole",
                   avatar_url, created_at, updated_at
            FROM users
            WHERE username = $1
            "#,
            username
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    pub async fn create(&self, user: User) -> Result<User> {
        let user = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (username, email, password_hash, role, avatar_url)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id, username, email, password_hash, role as "role: UserRole",
                      avatar_url, created_at, updated_at
            "#,
            user.username,
            user.email,
            user.password_hash,
            user.role as UserRole,
            user.avatar_url
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }
}
```

## 3.5 集群同步模块

### 3.5.1 集群事件定义

```rust
// sync/message.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ClusterEvent {
    // 房间事件
    RoomCreated {
        room_id: String,     // nanoid
        creator_id: String,  // nanoid
    },
    RoomSettingsChanged {
        room_id: String,     // nanoid
        settings: RoomSettings,
    },
    RoomUpdated {
        room_id: String,     // nanoid
        fields_changed: Vec<String>,
    },
    RoomDeleted {
        room_id: String,     // nanoid
        operator_id: String, // nanoid
        deleted_at: DateTime<Utc>,
    },
    RoomClosed {
        room_id: String,     // nanoid
    },

    // 播放控制事件
    MovieChanged {
        room_id: String,     // nanoid
        movie_id: String,    // nanoid
        position: f64,
    },
    PlayStatusChanged {
        room_id: String,     // nanoid
        status: PlayStatus,
        position: f64,
        timestamp: i64,
    },
    SeekTo {
        room_id: String,     // nanoid
        position: f64,
        timestamp: i64,
    },

    // 成员事件
    MemberJoined {
        room_id: String,     // nanoid
        user_id: String,     // nanoid
    },
    MemberLeft {
        room_id: String,     // nanoid
        user_id: String,     // nanoid
    },
    MemberKicked {
        room_id: String,     // nanoid
        user_id: String,     // nanoid
        operator_id: String, // nanoid
        reason: String,
    },
    MemberPermissionsChanged {
        room_id: String,     // nanoid
        user_id: String,     // nanoid
        permissions: u64,
        admin_permissions: u64,
    },

    // 聊天事件
    ChatMessage {
        room_id: String,     // nanoid
        user_id: String,     // nanoid
        username: String,
        message: String,
        timestamp: i64,
    },
    ChatMessageDeleted {
        room_id: String,     // nanoid
        message_id: String,  // nanoid
        operator_id: String, // nanoid
    },

    // 弹幕事件
    DanmakuSent {
        room_id: String,     // nanoid
        danmaku: Danmaku,
    },

    // 直播流事件 (用于监控和统计,不用于触发拉流)
    // 注意: 其他节点收到此事件不会主动建立拉流,
    //       而是在收到客户端FLV请求时才懒加载创建拉流
    StreamStarted {
        stream_key: String,
        publisher_node: String,
        started_at: DateTime<Utc>,
    },
    StreamStopped {
        stream_key: String,
        publisher_node_id: String,
        stopped_at: DateTime<Utc>,
    },
    StreamPublisherChanged {
        stream_key: String,
        old_publisher: String,
        new_publisher: String,
    },

    // 影片列表事件
    MovieListChanged {
        room_id: String,     // nanoid
        operation: String,   // "added" | "removed" | "reordered"
        movie_id: Option<String>,  // nanoid
    },

    // 会话管理事件
    ForceDisconnect {
        user_id: String,     // nanoid
        room_id: String,     // nanoid
        session_id: String,  // WebSocket会话ID
        reason: String,      // "new_connection" | "kicked" | "banned"
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClusterEventEnvelope {
    pub event_id: String,
    pub node_id: String,
    pub event: ClusterEvent,
    pub timestamp: i64,
}
```

### 3.5.2 集群同步实现

```rust
// sync/cluster_sync.rs
pub struct ClusterSync {
    redis: deadpool_redis::Pool,
    local_node_id: String,
    event_handlers: Arc<RwLock<Vec<Arc<dyn EventHandler>>>>,
}

#[async_trait]
pub trait EventHandler: Send + Sync {
    async fn handle(&self, event: &ClusterEvent) -> Result<()>;
}

impl ClusterSync {
    pub fn new(redis: deadpool_redis::Pool, local_node_id: String) -> Self {
        Self {
            redis,
            local_node_id,
            event_handlers: Arc::new(RwLock::new(Vec::new())),
        }
    }

    // 发布事件
    pub async fn publish(&self, event: ClusterEvent) -> Result<()> {
        let envelope = ClusterEventEnvelope {
            event_id: Uuid::new_v4().to_string(),
            node_id: self.local_node_id.clone(),
            event,
            timestamp: Utc::now().timestamp_millis(),
        };

        let json = serde_json::to_string(&envelope)?;

        let mut conn = self.redis.get().await?;
        redis::cmd("PUBLISH")
            .arg("cluster:events")
            .arg(&json)
            .query_async(&mut conn)
            .await?;

        tracing::debug!(
            event_id = %envelope.event_id,
            node_id = %envelope.node_id,
            "Published cluster event"
        );

        Ok(())
    }

    // 订阅事件（后台任务）
    pub async fn start_subscription(self: Arc<Self>) {
        tokio::spawn(async move {
            loop {
                if let Err(e) = self.subscribe_loop().await {
                    tracing::error!(error = ?e, "Cluster subscription error");
                    tokio::time::sleep(Duration::from_secs(5)).await;
                }
            }
        });
    }

    async fn subscribe_loop(&self) -> Result<()> {
        let mut conn = self.redis.get().await?;
        let mut pubsub = conn.into_pubsub();

        pubsub.subscribe("cluster:events").await?;

        tracing::info!("Subscribed to cluster events");

        let mut stream = pubsub.on_message();

        while let Some(msg) = stream.next().await {
            let payload: String = msg.get_payload()?;

            match serde_json::from_str::<ClusterEventEnvelope>(&payload) {
                Ok(envelope) => {
                    // 忽略自己发布的事件
                    if envelope.node_id == self.local_node_id {
                        continue;
                    }

                    self.handle_event(envelope).await;
                }
                Err(e) => {
                    tracing::error!(error = ?e, "Failed to parse cluster event");
                }
            }
        }

        Ok(())
    }

    async fn handle_event(&self, envelope: ClusterEventEnvelope) {
        tracing::debug!(
            event_id = %envelope.event_id,
            from_node = %envelope.node_id,
            "Received cluster event"
        );

        let handlers = self.event_handlers.read().await;
        for handler in handlers.iter() {
            if let Err(e) = handler.handle(&envelope.event).await {
                tracing::error!(error = ?e, "Event handler error");
            }
        }
    }

    // 注册事件处理器
    pub async fn register_handler(&self, handler: Arc<dyn EventHandler>) {
        self.event_handlers.write().await.push(handler);
    }
}
```

### 3.5.3 房间消息中心 (Redis Pub/Sub)

房间消息中心使用 Redis Pub/Sub 实现跨节点消息分发,无需依赖外部网关的会话亲和性。

```rust
// sync/hub.rs
use dashmap::DashMap;

pub struct RoomMessageHub {
    redis_client: Arc<redis::Client>,
    // room_id -> RoomSubscription
    subscriptions: Arc<DashMap<String, Arc<RoomSubscription>>>,
}

pub struct RoomSubscription {
    room_id: String,  // nanoid
    // client_id -> ClientSender
    clients: Arc<DashMap<String, ClientSender>>,
    // Redis 订阅
    redis_sub: Arc<Mutex<redis::aio::PubSub>>,
    // 取消令牌
    cancel_token: CancellationToken,
}

pub struct ClientSender {
    user_id: String,  // nanoid
    sender: mpsc::UnboundedSender<WsMessage>,
    joined_at: Instant,
}

impl RoomMessageHub {
    pub fn new(redis_client: Arc<redis::Client>) -> Self {
        Self {
            redis_client,
            subscriptions: Arc::new(DashMap::new()),
        }
    }

    // 获取或创建房间订阅
    pub async fn get_or_create_subscription(
        &self,
        room_id: String,
    ) -> Result<Arc<RoomSubscription>> {
        // 检查是否已存在
        if let Some(sub) = self.subscriptions.get(&room_id) {
            return Ok(sub.clone());
        }

        // 创建 Redis Pub/Sub 连接
        let mut conn = self.redis_client.get_multiplexed_async_connection().await?;
        let mut redis_sub = conn.into_pubsub();

        // 订阅房间频道
        let channel = format!("room:{}:messages", room_id);
        redis_sub.subscribe(&channel).await?;

        tracing::info!(room_id = %room_id, "Subscribed to room channel");

        // 创建订阅实例
        let subscription = Arc::new(RoomSubscription {
            room_id: room_id.clone(),
            clients: Arc::new(DashMap::new()),
            redis_sub: Arc::new(Mutex::new(redis_sub)),
            cancel_token: CancellationToken::new(),
        });

        // 启动 Redis 消息接收任务
        let sub_clone = subscription.clone();
        tokio::spawn(async move {
            sub_clone.receive_redis_messages().await;
        });

        self.subscriptions.insert(room_id, subscription.clone());

        Ok(subscription)
    }

    // 移除房间订阅 (如果没有客户端)
    pub async fn remove_subscription_if_empty(&self, room_id: &str) {
        if let Some((_, sub)) = self.subscriptions.remove(room_id) {
            if sub.clients.is_empty() {
                sub.cancel_token.cancel();
                tracing::info!(room_id = %room_id, "Removed empty room subscription");
            } else {
                // 放回去
                self.subscriptions.insert(room_id.to_string(), sub);
            }
        }
    }
}

impl RoomSubscription {
    // 添加客户端
    pub fn add_client(
        &self,
        client_id: String,
        user_id: String,  // nanoid
        sender: mpsc::UnboundedSender<WsMessage>,
    ) {
        let client = ClientSender {
            user_id,
            sender,
            joined_at: Instant::now(),
        };

        self.clients.insert(client_id.clone(), client);

        tracing::info!(
            room_id = %self.room_id,
            client_id = %client_id,
            user_id = %user_id,
            total_clients = self.clients.len(),
            "Client added to room"
        );
    }

    // 移除客户端
    pub fn remove_client(&self, client_id: &str) {
        self.clients.remove(client_id);

        tracing::info!(
            room_id = %self.room_id,
            client_id = %client_id,
            remaining_clients = self.clients.len(),
            "Client removed from room"
        );
    }

    // 发送消息 (发布到 Redis)
    pub async fn send_message(&self, message: WsMessage) -> Result<()> {
        let redis_client = self.redis_sub.lock().await
            .get_connection()
            .get_redis_client();

        let mut conn = redis_client.get_multiplexed_async_connection().await?;

        let channel = format!("room:{}:messages", self.room_id);
        let json = serde_json::to_string(&message)?;

        redis::cmd("PUBLISH")
            .arg(&channel)
            .arg(&json)
            .query_async(&mut conn)
            .await?;

        Ok(())
    }

    // 接收 Redis 消息并分发到本地客户端
    async fn receive_redis_messages(self: Arc<Self>) {
        let mut redis_sub = self.redis_sub.lock().await;
        let mut stream = redis_sub.on_message();

        loop {
            tokio::select! {
                _ = self.cancel_token.cancelled() => {
                    tracing::info!(room_id = %self.room_id, "Redis subscription cancelled");
                    break;
                }
                msg = stream.next() => {
                    if let Some(msg) = msg {
                        let payload: String = match msg.get_payload() {
                            Ok(p) => p,
                            Err(e) => {
                                tracing::error!(error = ?e, "Failed to get Redis payload");
                                continue;
                            }
                        };

                        match serde_json::from_str::<WsMessage>(&payload) {
                            Ok(ws_message) => {
                                self.broadcast_to_local_clients(ws_message).await;
                            }
                            Err(e) => {
                                tracing::error!(error = ?e, "Failed to parse WsMessage");
                            }
                        }
                    } else {
                        break;
                    }
                }
            }
        }
    }

    // 广播到本节点的所有客户端
    async fn broadcast_to_local_clients(&self, message: WsMessage) {
        let mut disconnected = Vec::new();

        for entry in self.clients.iter() {
            let client_id = entry.key();
            let client = entry.value();

            if let Err(e) = client.sender.send(message.clone()) {
                tracing::warn!(
                    room_id = %self.room_id,
                    client_id = %client_id,
                    error = ?e,
                    "Failed to send message to client"
                );
                disconnected.push(client_id.clone());
            }
        }

        // 清理已断开的客户端
        for client_id in disconnected {
            self.clients.remove(&client_id);
        }
    }

    // 发送消息给特定用户
    pub async fn send_to_user(&self, user_id: &str, message: WsMessage) {  // nanoid
        for entry in self.clients.iter() {
            let client = entry.value();
            if client.user_id == user_id {
                let _ = client.sender.send(message.clone());
            }
        }
    }

    // 获取在线用户数 (本节点)
    pub fn get_local_viewer_count(&self) -> usize {
        self.clients.len()
    }

    // 获取在线用户列表 (本节点)
    pub fn get_local_users(&self) -> Vec<String> {
        self.clients
            .iter()
            .map(|entry| entry.value().user_id.clone())
            .collect()
    }
}
```

**优势**：

- ✅ 跨节点消息分发,无需会话亲和性
- ✅ 客户端可以连接任意节点,消息自动同步
- ✅ Redis 充当消息总线,解耦节点间通信
- ✅ 自动清理空订阅,减少资源占用
- ✅ 支持房间级别的消息路由

## 3.6 直播模块

### 3.6.1 拉流管理器

拉流管理器负责管理从 Publisher 节点主动拉取 RTMP 流,并在本地生成 FLV 分发。

```rust
// live/stream/pull_manager.rs
pub struct PullStreamManager {
    // stream_key -> PullStream
    streams: Arc<DashMap<String, Arc<PullStream>>>,
    redis: deadpool_redis::Pool,
}

impl PullStreamManager {
    /// 获取或创建拉流
    pub async fn get_or_create_pull_stream(
        &self,
        stream_key: &str,
        publisher_node: &str,
        local_node_id: String,
    ) -> Result<Arc<PullStream>> {
        // 检查是否已存在
        if let Some(stream) = self.streams.get(stream_key) {
            if stream.is_healthy().await {
                return Ok(stream.clone());
            } else {
                // 移除不健康的流
                self.streams.remove(stream_key);
            }
        }

        // 创建新的拉流
        let pull_stream = self.create_pull_stream(
            stream_key,
            publisher_node,
            local_node_id,
        ).await?;

        self.streams.insert(stream_key.to_string(), pull_stream.clone());

        Ok(pull_stream)
    }

    async fn create_pull_stream(
        &self,
        stream_key: &str,
        publisher_node: &str,
        local_node_id: String,
    ) -> Result<Arc<PullStream>> {
        // 获取 Publisher 地址
        let publisher_addr = format!("{}:1935", publisher_node);

        // 创建 RTMP 客户端连接
        let rtmp_url = format!("rtmp://{}/live/{}", publisher_addr, stream_key);
        let rtmp_client = RtmpClient::connect(&rtmp_url).await?;

        // 创建拉流实例
        let pull_stream = Arc::new(PullStream::new(
            stream_key.to_string(),
            rtmp_client,
            local_node_id,
        ));

        // 启动拉流任务
        pull_stream.start().await?;

        tracing::info!(
            stream_key = %stream_key,
            publisher_node = %publisher_node,
            "Created and started pull stream"
        );

        Ok(pull_stream)
    }

    /// 停止并移除拉流
    pub async fn stop_pull_stream(&self, stream_key: &str) -> Result<()> {
        if let Some((_, stream)) = self.streams.remove(stream_key) {
            stream.stop().await?;
            tracing::info!(stream_key = %stream_key, "Stopped pull stream");
        }
        Ok(())
    }

    /// 清理不活跃的拉流 (定期任务)
    pub async fn cleanup_inactive_streams(&self) {
        let inactive_keys: Vec<String> = self.streams
            .iter()
            .filter_map(|entry| {
                let stream = entry.value();
                if stream.subscriber_count() == 0
                    && stream.last_active_time().elapsed() > Duration::from_secs(300) {
                    Some(entry.key().clone())
                } else {
                    None
                }
            })
            .collect();

        for key in inactive_keys {
            self.stop_pull_stream(&key).await.ok();
        }
    }
}

// live/stream/pull_stream.rs
pub struct PullStream {
    stream_key: String,
    rtmp_client: Arc<Mutex<RtmpClient>>,
    local_node_id: String,

    // GOP 缓存 (最近一个 GOP)
    gop_cache: Arc<RwLock<Vec<Arc<Bytes>>>>,

    // 订阅者管理
    subscribers: Arc<RwLock<Vec<SubscriberHandle>>>,
    subscriber_count: Arc<AtomicUsize>,

    // 状态管理
    state: Arc<RwLock<PullStreamState>>,
    last_packet_time: Arc<Mutex<Instant>>,

    // 取消令牌
    cancel_token: CancellationToken,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum PullStreamState {
    Connecting,
    Running,
    Stopped,
    Failed,
}

struct SubscriberHandle {
    id: String,
    sender: mpsc::Sender<Arc<Bytes>>,
    created_at: Instant,
}

impl PullStream {
    pub fn new(
        stream_key: String,
        rtmp_client: RtmpClient,
        local_node_id: String,
    ) -> Self {
        Self {
            stream_key,
            rtmp_client: Arc::new(Mutex::new(rtmp_client)),
            local_node_id,
            gop_cache: Arc::new(RwLock::new(Vec::new())),
            subscribers: Arc::new(RwLock::new(Vec::new())),
            subscriber_count: Arc::new(AtomicUsize::new(0)),
            state: Arc::new(RwLock::new(PullStreamState::Connecting)),
            last_packet_time: Arc::new(Mutex::new(Instant::now())),
            cancel_token: CancellationToken::new(),
        }
    }

    /// 启动拉流任务
    pub async fn start(&self) -> Result<()> {
        let rtmp_client = self.rtmp_client.clone();
        let gop_cache = self.gop_cache.clone();
        let subscribers = self.subscribers.clone();
        let state = self.state.clone();
        let last_packet_time = self.last_packet_time.clone();
        let cancel_token = self.cancel_token.clone();
        let stream_key = self.stream_key.clone();

        tokio::spawn(async move {
            *state.write().await = PullStreamState::Running;

            loop {
                tokio::select! {
                    _ = cancel_token.cancelled() => {
                        tracing::info!(stream_key = %stream_key, "Pull stream cancelled");
                        break;
                    }
                    result = Self::read_packet(&rtmp_client) => {
                        match result {
                            Ok(packet) => {
                                // 更新最后接收时间
                                *last_packet_time.lock().await = Instant::now();

                                let data = Arc::new(packet.data);

                                // 更新 GOP 缓存
                                if packet.is_key_frame {
                                    let mut cache = gop_cache.write().await;
                                    cache.clear();
                                    cache.push(data.clone());
                                } else {
                                    gop_cache.write().await.push(data.clone());
                                }

                                // 分发给所有订阅者
                                Self::distribute_packet(&subscribers, data).await;
                            }
                            Err(e) => {
                                tracing::error!(
                                    stream_key = %stream_key,
                                    error = ?e,
                                    "Pull stream read error"
                                );
                                *state.write().await = PullStreamState::Failed;
                                break;
                            }
                        }
                    }
                }
            }

            *state.write().await = PullStreamState::Stopped;
        });

        Ok(())
    }

    async fn read_packet(rtmp_client: &Arc<Mutex<RtmpClient>>) -> Result<RtmpPacket> {
        let mut client = rtmp_client.lock().await;
        client.read_packet().await
    }

    async fn distribute_packet(
        subscribers: &Arc<RwLock<Vec<SubscriberHandle>>>,
        data: Arc<Bytes>,
    ) {
        let mut subs = subscribers.write().await;

        // 移除已关闭的订阅者
        subs.retain(|sub| !sub.sender.is_closed());

        // 分发数据
        for sub in subs.iter() {
            if let Err(e) = sub.sender.try_send(data.clone()) {
                tracing::warn!(
                    subscriber_id = %sub.id,
                    error = ?e,
                    "Failed to send packet to subscriber"
                );
            }
        }
    }

    /// 订阅 FLV 流
    pub async fn subscribe_flv(&self) -> Result<impl Stream<Item = Result<Bytes>>> {
        let subscriber_id = nanoid::nanoid!(12);
        let (tx, rx) = mpsc::channel(100);

        // 发送 FLV Header
        tx.send(Arc::new(Self::flv_header())).await.ok();

        // 发送 GOP 缓存
        let gop_cache = self.gop_cache.read().await;
        for packet in gop_cache.iter() {
            tx.send(packet.clone()).await.ok();
        }

        // 添加到订阅者列表
        let handle = SubscriberHandle {
            id: subscriber_id.clone(),
            sender: tx,
            created_at: Instant::now(),
        };

        self.subscribers.write().await.push(handle);
        self.subscriber_count.fetch_add(1, Ordering::Relaxed);

        tracing::info!(
            stream_key = %self.stream_key,
            subscriber_id = %subscriber_id,
            total_subscribers = self.subscriber_count(),
            "New FLV subscriber"
        );

        let stream_key = self.stream_key.clone();
        let subscriber_count = self.subscriber_count.clone();

        let stream = ReceiverStream::new(rx)
            .map(move |data| Ok((*data).clone()))
            .on_completion(move || {
                subscriber_count.fetch_sub(1, Ordering::Relaxed);
                tracing::info!(
                    stream_key = %stream_key,
                    subscriber_id = %subscriber_id,
                    "Subscriber disconnected"
                );
            });

        Ok(stream)
    }

    fn flv_header() -> Bytes {
        // FLV file header: FLV + version(1) + flags(5=audio+video) + header size(9)
        Bytes::from_static(&[0x46, 0x4C, 0x56, 0x01, 0x05, 0x00, 0x00, 0x00, 0x09])
    }

    /// 停止拉流
    pub async fn stop(&self) -> Result<()> {
        self.cancel_token.cancel();
        *self.state.write().await = PullStreamState::Stopped;
        Ok(())
    }

    /// 检查流是否健康
    pub async fn is_healthy(&self) -> bool {
        let state = *self.state.read().await;
        if state != PullStreamState::Running {
            return false;
        }

        // 检查最后接收数据包的时间 (超过30秒认为不健康)
        let last_time = *self.last_packet_time.lock().await;
        last_time.elapsed() < Duration::from_secs(30)
    }

    /// 获取订阅者数量
    pub fn subscriber_count(&self) -> usize {
        self.subscriber_count.load(Ordering::Relaxed)
    }

    /// 获取最后活跃时间
    pub fn last_active_time(&self) -> Instant {
        *self.last_packet_time.blocking_lock()
    }
}
```

**优势**：

- ✅ 主动拉流,类似推流机制,但由拉流节点控制
- ✅ GOP 缓存,实现快速首帧
- ✅ 多客户端共享同一拉流连接,降低 Publisher 压力
- ✅ 自动健康检查和清理不活跃的拉流
- ✅ 零拷贝分发 (Arc<Bytes>)

### 3.6.2 xiu 集成层

```rust
// live/xiu_integration.rs
use streamhub::{StreamsHub, notify::Notifier};
use rtmp::RtmpServer;

pub struct XiuIntegration {
    stream_hub: Arc<StreamsHub>,
    rtmp_server: Arc<RtmpServer>,
}

impl XiuIntegration {
    pub async fn new(
        config: LiveConfig,
        notifier: Arc<dyn Notifier>,
    ) -> Result<Self> {
        // 创建 StreamHub
        let stream_hub = Arc::new(StreamsHub::new(Some(notifier)));

        // 创建 RTMP 服务器
        let rtmp_server = Arc::new(RtmpServer::new(config.rtmp_addr));

        Ok(Self {
            stream_hub,
            rtmp_server,
        })
    }

    pub async fn start(self: Arc<Self>) -> Result<()> {
        // 启动 StreamHub
        let hub = self.stream_hub.clone();
        tokio::spawn(async move {
            hub.run().await;
        });

        // 启动 RTMP 服务器
        let server = self.rtmp_server.clone();
        tokio::spawn(async move {
            server.run().await;
        });

        tracing::info!("xiu integration started");
        Ok(())
    }
}
```

### 3.6.2 自定义 Notifier

```rust
// live/notifier.rs
use streamhub::notify::{Notifier, StreamHubEventMessage};

pub struct SyncTvNotifier {
    cluster_registry: Arc<ClusterRegistry>,
    stream_manager: Arc<StreamManager>,
    cluster_sync: Arc<ClusterSync>,
}

#[async_trait]
impl Notifier for SyncTvNotifier {
    async fn on_publish_notify(&self, event: &StreamHubEventMessage) {
        let stream_key = event.identifier.to_string();

        tracing::info!(
            stream_key = %stream_key,
            "Stream publish started"
        );

        // Step 1: 确定该流的 Publisher 节点
        let hash_ring = self.cluster_registry.get_hash_ring().await;
        let publisher_node = match hash_ring.get_node(&stream_key) {
            Some(node) => node.clone(),
            None => {
                tracing::error!("No available node for stream");
                return;
            }
        };

        let local_node_id = &self.cluster_registry.local_node_id;

        // Step 2: 检查当前节点是否是 Publisher
        if &publisher_node != local_node_id {
            tracing::warn!(
                stream_key = %stream_key,
                publisher_node = %publisher_node,
                local_node = %local_node_id,
                "Not the publisher node, should reject publish"
            );
            return;
        }

        // Step 3: 注册到 Redis
        if let Err(e) = self.cluster_registry
            .register_stream_publisher(&stream_key, local_node_id, 300)
            .await
        {
            tracing::error!(error = ?e, "Failed to register stream publisher");
            return;
        }

        // Step 4: (可选) 发布集群事件用于监控和统计
        //         注意: 这不是用来通知其他节点建立拉流!
        //               其他节点在收到FLV请求时才懒加载创建拉流
        if let Err(e) = self.cluster_sync.publish(ClusterEvent::StreamStarted {
            stream_key: stream_key.clone(),
            publisher_node: local_node_id.clone(),
            started_at: Utc::now(),
        }).await {
            tracing::error!(error = ?e, "Failed to publish stream started event");
        }

        // Step 5: 启动心跳任务
        let registry = self.cluster_registry.clone();
        let key = stream_key.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));
            loop {
                interval.tick().await;

                if let Err(e) = registry.renew_stream_publisher(&key, 300).await {
                    tracing::error!(error = ?e, "Failed to renew stream publisher");
                    break;
                }
            }
        });
    }

    async fn on_unpublish_notify(&self, event: &StreamHubEventMessage) {
        let stream_key = event.identifier.to_string();

        tracing::info!(
            stream_key = %stream_key,
            "Stream publish stopped"
        );

        // 删除 Redis 注册
        let _ = self.cluster_registry
            .unregister_stream_publisher(&stream_key)
            .await;

        // 发布集群事件
        let _ = self.cluster_sync.publish(ClusterEvent::StreamStopped {
            stream_key,
            stopped_at: Utc::now(),
        }).await;
    }
}
```

## 3.7 Provider 模块 ⭐⭐⭐

Provider 模块是视频解析和代理的核心，采用**插件化注册 + Factory 模式**，支持动态扩展视频源。

### 3.7.1 设计理念

**核心特性**：

- ✅ **插件化注册**：Provider 通过 Factory 函数动态注册
- ✅ **独立路由**：每个 Provider 可注册自己的 HTTP 端点
- ✅ **策略配置**：支持多种 URL 生成策略
- ✅ **类型安全**：基于 trait 的设计，编译时检查
- ✅ **零成本抽象**：默认实现不影响性能

### 3.7.2 Provider 注册表

```rust
// providers/registry.rs

use axum::Router;
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;

/// Provider 工厂函数类型
pub type ProviderFactory = Arc<dyn Fn(ProviderConfig) -> Result<Arc<dyn MediaProvider>> + Send + Sync>;

/// Provider 注册表（全局单例）
pub struct ProviderRegistry {
    /// 工厂函数映射：provider_name -> factory
    factories: Arc<RwLock<HashMap<String, ProviderFactory>>>,

    /// 已实例化的 provider：instance_id -> provider
    instances: Arc<RwLock<HashMap<String, Arc<dyn MediaProvider>>>>,

    /// HTTP 路由构建器
    router_builder: Arc<RwLock<Router>>,
}

impl ProviderRegistry {
    pub fn new() -> Self {
        Self {
            factories: Arc::new(RwLock::new(HashMap::new())),
            instances: Arc::new(RwLock::new(HashMap::new())),
            router_builder: Arc::new(RwLock::new(Router::new())),
        }
    }

    /// 注册 Provider 工厂（在启动时调用）
    ///
    /// # Example
    /// ```
    /// registry.register_factory("bilibili", Arc::new(|config| {
    ///     Ok(Arc::new(BilibiliProvider::new(config)?))
    /// }));
    /// ```
    pub async fn register_factory(&self, name: &str, factory: ProviderFactory) {
        self.factories.write().await.insert(name.to_string(), factory);
        tracing::info!("Registered provider factory: {}", name);
    }

    /// 创建 Provider 实例
    ///
    /// # Parameters
    /// - `name`: Provider 类型名称（如 "bilibili", "alist"）
    /// - `instance_id`: 实例唯一标识（如 "bilibili_main", "alist_company"）
    /// - `config`: Provider 配置
    pub async fn create_instance(
        &self,
        name: &str,
        instance_id: &str,
        config: ProviderConfig,
    ) -> Result<Arc<dyn MediaProvider>> {
        // 1. 获取工厂函数
        let factory = self.factories.read().await
            .get(name)
            .cloned()
            .ok_or_else(|| Error::ProviderNotFound(name.to_string()))?;

        // 2. 使用工厂创建实例
        let provider = factory(config)?;

        // 3. 注册 HTTP 路由（如果 provider 支持）
        if provider.supports_http_routes() {
            let mut router = self.router_builder.write().await;
            provider.register_routes(&mut router, instance_id).await?;
        }

        // 4. 存储实例
        self.instances.write().await.insert(instance_id.to_string(), provider.clone());

        tracing::info!("Created provider instance: {} (type: {})", instance_id, name);
        Ok(provider)
    }

    /// 获取已创建的实例
    pub async fn get_instance(&self, instance_id: &str) -> Option<Arc<dyn MediaProvider>> {
        self.instances.read().await.get(instance_id).cloned()
    }

    /// 构建最终的 HTTP 路由
    pub async fn build_routes(&self) -> Router {
        self.router_builder.read().await.clone()
    }

    /// 列出所有已注册的 provider 类型
    pub async fn list_provider_types(&self) -> Vec<String> {
        self.factories.read().await.keys().cloned().collect()
    }

    /// 列出所有已创建的实例
    pub async fn list_instances(&self) -> Vec<String> {
        self.instances.read().await.keys().cloned().collect()
    }
}
```

### 3.7.3 MediaProvider Trait

**两阶段设计**：

1. **Parse（HTTP端点）**：添加媒体时，用户调用 `/api/providers/{id}/parse`，Provider返回source_config（存数据库）
2. **generate_playback(trait方法)**：播放时，根据source_config生成播放信息（内部调用，可缓存）

```rust
// providers/traits.rs

use axum::{Router, extract::State};
use async_trait::async_trait;
use bytes::Bytes;
use tokio_stream::Stream;

/// 媒体提供商核心接口
#[async_trait]
pub trait MediaProvider: Send + Sync {
    // ==================== 基础信息 ====================

    /// Provider 类型名称（如 "bilibili", "alist"）
    fn name(&self) -> &'static str;

    /// Provider 实例 ID（如 "bilibili_main"）
    fn instance_id(&self) -> &str;

    /// Provider 配置
    fn config(&self) -> &ProviderConfig;

    // ==================== 核心方法：生成播放信息 ====================

    /// 根据source_config生成播放信息
    ///
    /// **用于**：用户播放时，动态生成完整的播放信息
    /// **流程**：数据库 → source_config → generate_playback() → PlaybackResult → 客户端
    ///
    /// # 返回
    /// PlaybackResult {
    ///   playback_infos: HashMap<String, PlaybackInfo>,  // 多模式（direct、proxied等）
    ///   default_mode: String,                           // 默认模式
    ///   metadata: HashMap,                              // 媒体元数据（duration、thumbnail等）
    /// }
    ///
    /// # 说明
    /// - 播放信息动态生成，不存储在数据库
    /// - Provider可自定义任意数量和类型的模式
    /// - 每个模式包含完整的urls、subtitles、danmakus
    async fn generate_playback(&self, ctx: &ProviderContext<'_>, source_config: &Value) -> Result<PlaybackResult>;

    // ==================== HTTP 路由注册 ====================

    /// 是否支持自定义 HTTP 路由
    fn supports_http_routes(&self) -> bool {
        false
    }

    /// 注册自定义 HTTP 路由
    ///
    /// Provider 可以注册自己的代理端点、回调端点等
    ///
    /// # 路由格式
    /// `/api/providers/{instance_id}/proxy/*path`
    /// `/api/providers/{instance_id}/callback`
    ///
    /// # Example
    /// ```rust
    /// async fn register_routes(&self, router: &mut Router, instance_id: &str) -> Result<()> {
    ///     let provider = Arc::new(self.clone());
    ///
    ///     *router = router.clone()
    ///         .route(
    ///             &format!("/api/providers/{}/proxy/*path", instance_id),
    ///             get(Self::handle_proxy)
    ///         )
    ///         .with_state(provider);
    ///
    ///     Ok(())
    /// }
    /// ```
    async fn register_routes(&self, router: &mut Router, instance_id: &str) -> Result<()> {
        Ok(())  // 默认不注册
    }

    // ==================== URL 生成 ====================

    /// 生成播放 URL（根据 media.proxy 决定返回代理 URL 或直连 URL）
    ///
    /// # Parameters
    /// - `media`: 媒体对象（包含 proxy 标志）
    /// - `token`: 用户 token
    /// - `room_id`: 房间 ID
    /// - `base_url`: 完整的 base URL（例如 "https://synctv.example.com"）
    ///
    /// # Returns
    /// 完整的播放 URL（客户端无感知代理）
    fn generate_playback_url(
        &self,
        media: &Media,
        token: &str,
        room_id: &str,
        base_url: &str,
    ) -> String {
        if media.proxy {
            // 需要代理：返回 Provider 的代理 URL
            self.config().build_full_proxy_url(
                base_url,
                &media.id.to_string(),
                &[("token", token), ("room_id", room_id)],
            )
        } else {
            // 不需要代理：返回第三方直连 URL
            media.url.clone()
        }
    }

    /// 生成字幕 URL
    fn generate_subtitle_url(
        &self,
        media: &Media,
        subtitle_id: &str,
        token: &str,
        room_id: &str,
        base_url: &str,
    ) -> String {
        let path = self.config().build_subtitle_path(&media.id.to_string(), subtitle_id);
        let query = format!("token={}&room_id={}",
                          urlencoding::encode(token),
                          urlencoding::encode(room_id));
        format!("{}{}?{}", base_url.trim_end_matches('/'), path, query)
    }

    /// 生成备用源 URL
    fn generate_alternative_source_url(
        &self,
        media: &Media,
        source_id: &str,
        token: &str,
        room_id: &str,
        base_url: &str,
    ) -> String {
        self.config().build_full_proxy_url(
            base_url,
            &media.id.to_string(),
            &[
                ("token", token),
                ("room_id", room_id),
                ("source", source_id),
            ],
        )
    }

    // ==================== 代理功能 ====================

    /// 代理请求（由 HTTP handler 调用）
    async fn proxy_stream(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        request: ProxyRequest,
    ) -> Result<ProxyResponse>;

    // ==================== 缓存策略 ====================

    /// 生成缓存键
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // 默认实现：根据 source_config.share 决定
        let is_shared = media.source_config
            .get("share")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if is_shared {
            format!("media:parsed:{}:shared", media.id)
        } else if let Some(requester) = ctx.requester {
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else {
            format!("media:parsed:{}:shared", media.id)
        }
    }

    // ==================== 生命周期钩子（可选）====================

    /// 播放开始时调用
    async fn on_playback_start(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }

    /// 播放停止时调用
    async fn on_playback_stop(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }

    /// 播放进度更新时调用
    async fn on_playback_progress(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }
}

// ==================== 返回值结构定义 ====================

/// Parse 解析结果（解析用户输入时返回）
///
/// ⚠️ **重要**：Parse 响应结构是 Provider 特定的
///
/// 不定义通用的 ParseResult 结构。每个 Provider 定义自己的 parse 响应格式。
///
/// **原因**：
/// - parse 是 HTTP + gRPC 端点，供前端/用户使用（不是系统内部调用）
/// - 每个 provider 的响应结构完全不同（Bilibili 有分P，Alist 有文件列表等）
/// - 前端根据不同 provider 类型使用不同的响应结构
///
/// **示例**：
///
/// ```rust
/// // Bilibili Provider 特定响应
/// pub struct BilibiliParseResponse {
///     pub video_info: VideoInfo,
///     pub pages: Vec<VideoPage>,
///     pub default_page: usize,
/// }
///
/// // Alist Provider 特定响应
/// pub struct AlistParseResponse {
///     pub path: String,
///     pub items: Vec<AlistItem>,
///     pub has_more: bool,
/// }
/// ```
///
/// **工作流**：
/// 1. 用户调用 parse 端点 → 获取 provider 特定的响应
/// 2. 客户端根据用户选择构建 source_config
/// 3. 调用 add_media API，传入 source_config
/// 4. 服务端调用 validate_source_config() 校验
///
/// 详见：08-视频内容管理.md § 6.1.6.1

/// 播放信息生成结果（播放时返回）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackResult {
    /// 多种播放模式（由Provider自定义）
    pub playback_infos: HashMap<String, PlaybackInfo>,
    /// 默认模式名称
    pub default_mode: String,
    /// 媒体元数据
    pub metadata: HashMap<String, Value>,
}

/// 单个播放模式的信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackInfo {
    /// 播放URL列表（多个备用源或清晰度）
    pub urls: Vec<PlaybackUrl>,
    /// 默认URL索引
    pub default_url_index: usize,
    /// 字幕列表
    pub subtitles: Vec<Subtitle>,
    /// 默认字幕索引
    pub default_subtitle_index: Option<usize>,
    /// 弹幕列表
    pub danmakus: Vec<Danmaku>,
}

/// 播放 URL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackUrl {
    /// 名称（如 "1080P"、"HEVC"）
    pub name: String,
    /// URL 地址
    pub url: String,
    /// 请求头
    pub headers: HashMap<String, String>,
    /// 元数据（可选，如 quality、codec、bitrate）
    pub metadata: HashMap<String, Value>,
}

/// 字幕
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subtitle {
    /// 字幕名称（如 "中文"、"English"）
    pub name: String,
    /// 字幕URL
    pub url: String,
    /// 字幕格式（如 "srt"、"ass"、"vtt"）
    pub format: String,
    /// 语言代码（如 "zh-CN"、"en-US"）
    pub language: Option<String>,
}

/// 弹幕
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Danmaku {
    /// 弹幕源名称（如 "Bilibili弹幕"、"本地弹幕"）
    pub name: String,
    /// 弹幕URL
    pub url: String,
    /// 弹幕格式（如 "bilibili"、"xml"、"json"）
    pub format: Option<String>,
    /// 请求头
    pub headers: HashMap<String, String>,
}

// ==================== 其他辅助结构 ====================

/// Provider 上下文
pub struct ProviderContext<'a> {
    /// 请求者信息
    pub requester: Option<&'a User>,
    /// 房间ID
    pub room_id: &'a str,
    /// HTTP 客户端
    pub http_client: &'a reqwest::Client,
    /// 缓存接口
    pub cache: &'a dyn CacheProvider,
}

/// 代理请求
pub struct ProxyRequest {
    /// 媒体对象
    pub media: Media,
    /// 请求路径（相对路径）
    pub path: String,
    /// 查询参数
    pub query: HashMap<String, String>,
    /// 请求头
    pub headers: HeaderMap,
}

/// 代理响应
pub struct ProxyResponse {
    /// 状态码
    pub status: StatusCode,
    /// 响应头
    pub headers: HeaderMap,
    /// 响应体（流）
    pub body: BoxStream<'static, Result<Bytes>>,
}
```

### 3.7.4 Provider 配置系统

```rust
// providers/config.rs

use serde::{Deserialize, Serialize};

/// Provider 配置（统一结构）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderConfig {
    /// Provider 类型（如 "bilibili", "alist", "emby"）
    pub provider_type: String,

    /// 实例 ID（如 "bilibili_main", "alist_company"）
    pub instance_id: String,

    /// Provider 特定配置
    pub provider_specific: serde_json::Value,
}

impl ProviderConfig {
    /// 构建代理路径（不包含 host）
    ///
    /// 格式：`/api/providers/{instance_id}/proxy/{media_id}`
    pub fn build_proxy_path(&self, media_id: &str) -> String {
        format!("/api/providers/{}/proxy/{}", self.instance_id, media_id)
    }

    /// 构建字幕代理路径
    pub fn build_subtitle_path(&self, media_id: &str, subtitle_id: &str) -> String {
        format!("/api/providers/{}/proxy/{}/subtitle/{}",
                self.instance_id, media_id, subtitle_id)
    }

    /// 构建完整代理 URL（包含 host）
    ///
    /// # Parameters
    /// - `base_url`: 完整的 base URL，例如 "https://synctv.example.com"
    /// - `media_id`: 媒体 ID
    /// - `params`: 查询参数
    pub fn build_full_proxy_url(
        &self,
        base_url: &str,
        media_id: &str,
        params: &[(&str, &str)],
    ) -> String {
        let path = self.build_proxy_path(media_id);
        let base = base_url.trim_end_matches('/');

        if params.is_empty() {
            format!("{}{}", base, path)
        } else {
            let query = params.iter()
                .map(|(k, v)| format!("{}={}", k, urlencoding::encode(v)))
                .collect::<Vec<_>>()
                .join("&");
            format!("{}{}?{}", base, path, query)
        }
    }
}
```

### 3.7.5 Bilibili Provider 示例

```rust
// providers/bilibili/mod.rs

use axum::{
    Router,
    extract::{Path, Query, State},
    response::IntoResponse,
    routing::get,
};
use std::sync::Arc;

pub struct BilibiliProvider {
    config: ProviderConfig,
    http_client: reqwest::Client,
}

impl BilibiliProvider {
    pub fn new(config: ProviderConfig) -> Result<Self> {
        Ok(Self {
            config,
            http_client: reqwest::Client::new(),
        })
    }

    /// HTTP 处理器：代理 MPD 文件
    async fn handle_mpd_proxy(
        State(provider): State<Arc<BilibiliProvider>>,
        Path((media_id, variant)): Path<(String, String)>,
        Query(params): Query<HashMap<String, String>>,
    ) -> impl IntoResponse {
        // 验证 token
        let token = params.get("token").ok_or(Error::Unauthorized)?;
        // ... token 验证逻辑

        // 获取 MPD 数据
        let mpd_data = match variant.as_str() {
            "hevc" => provider.get_hevc_mpd(&media_id).await?,
            "avc" => provider.get_avc_mpd(&media_id).await?,
            _ => return Err(Error::InvalidVariant),
        };

        // 改写 MPD 中的 segment URL 为代理 URL
        let rewritten_mpd = provider.rewrite_mpd_urls(&mpd_data, &media_id, token).await?;

        Ok((
            StatusCode::OK,
            [(header::CONTENT_TYPE, "application/dash+xml")],
            rewritten_mpd
        ))
    }

    /// HTTP 处理器：代理视频段
    async fn handle_segment_proxy(
        State(provider): State<Arc<BilibiliProvider>>,
        Path((media_id, segment_id)): Path<(String, String)>,
        Query(params): Query<HashMap<String, String>>,
        headers: HeaderMap,
    ) -> impl IntoResponse {
        // 验证 token
        let token = params.get("token").ok_or(Error::Unauthorized)?;
        // ... token 验证逻辑

        // 获取 segment 的真实 URL
        let segment_url = provider.get_segment_url(&media_id, &segment_id).await?;

        // 代理请求
        let range = headers.get(header::RANGE)
            .and_then(|v| v.to_str().ok());

        let response = provider.proxy_request(&segment_url, range).await?;

        Ok(response)
    }
}

#[async_trait]
impl MediaProvider for BilibiliProvider {
    fn name(&self) -> &'static str {
        "bilibili"
    }

    fn instance_id(&self) -> &str {
        &self.config.instance_id
    }

    fn config(&self) -> &ProviderConfig {
        &self.config
    }

    // ==================== 核心 trait 方法：生成播放信息 ====================

    async fn generate_playback(&self, ctx: &ProviderContext<'_>, source_config: &Value) -> Result<PlaybackResult> {
        // 从数据库读取的source_config中提取配置
        let bvid = source_config.get("bvid")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;
        let cid = source_config.get("cid")
            .and_then(|v| v.as_i64())
            .ok_or(Error::InvalidConfig)?;

        // 获取完整的播放信息
        let play_info = self.fetch_play_url(bvid, cid, ctx).await?;

        // 构建多种播放模式
        let mut playback_infos = HashMap::new();

        // 1. 直连模式（如果支持）
        if let Some(direct_urls) = play_info.direct_urls {
            playback_infos.insert("direct".to_string(), PlaybackInfo {
                urls: direct_urls.into_iter().map(|u| PlaybackUrl {
                    name: u.quality_name,
                    url: u.url,
                    headers: u.headers,
                    metadata: HashMap::from([
                        ("quality".to_string(), json!(u.quality)),
                        ("codec".to_string(), json!(u.codec)),
                    ]),
                }).collect(),
                default_url_index: 0,
                subtitles: play_info.subtitles.clone(),
                default_subtitle_index: None,
                danmakus: vec![
                    Danmaku {
                        name: "Bilibili弹幕".to_string(),
                        url: format!("https://api.bilibili.com/x/v1/dm/list.so?oid={}", cid),
                        format: Some("bilibili".to_string()),
                        headers: HashMap::new(),
                    }
                ],
            });
        }

        // 2. 代理模式（通过服务器代理）
        playback_infos.insert("proxied".to_string(), PlaybackInfo {
            urls: vec![
                PlaybackUrl {
                    name: "HEVC (代理)".to_string(),
                    url: format!("/api/providers/{}/proxy/{}/mpd/hevc",
                        self.instance_id(), media.id),
                    headers: HashMap::new(),
                    metadata: HashMap::from([
                        ("codec".to_string(), json!("hevc")),
                    ]),
                },
                PlaybackUrl {
                    name: "AVC (代理)".to_string(),
                    url: format!("/api/providers/{}/proxy/{}/mpd/avc",
                        self.instance_id(), media.id),
                    headers: HashMap::new(),
                    metadata: HashMap::from([
                        ("codec".to_string(), json!("avc")),
                    ]),
                },
            ],
            default_url_index: 0,
            subtitles: play_info.subtitles,
            default_subtitle_index: None,
            danmakus: vec![
                Danmaku {
                    name: "Bilibili弹幕 (代理)".to_string(),
                    url: format!("/api/providers/{}/proxy/{}/danmaku",
                        self.instance_id(), media.id),
                    format: Some("bilibili".to_string()),
                    headers: HashMap::new(),
                }
            ],
        });

        Ok(PlaybackResult {
            playback_infos,
            default_mode: "proxied".to_string(),
            metadata: HashMap::from([
                ("duration".to_string(), json!(play_info.duration)),
                ("thumbnail".to_string(), json!(play_info.thumbnail)),
            ]),
        })
    }

    fn supports_http_routes(&self) -> bool {
        true  // Bilibili 需要自定义路由
    }

    async fn register_routes(&self, router: &mut Router, instance_id: &str) -> Result<()> {
        let provider = Arc::new(self.clone());

        *router = router.clone()
            // MPD 代理
            .route(
                &format!("/api/providers/{}/proxy/:media_id/mpd/:variant", instance_id),
                get(Self::handle_mpd_proxy)
            )
            // 视频段代理
            .route(
                &format!("/api/providers/{}/proxy/:media_id/segment/:segment_id", instance_id),
                get(Self::handle_segment_proxy)
            )
            .with_state(provider);

        tracing::info!("Registered Bilibili HTTP routes for instance: {}", instance_id);
        Ok(())
    }

    fn generate_playback_url(
        &self,
        media: &Media,
        token: &str,
        room_id: &str,
        base_url: &str,
    ) -> String {
        if media.proxy {
            // 需要代理：返回 Bilibili Provider 的代理 URL
            self.config.build_full_proxy_url(
                base_url,
                &media.id.to_string(),
                &[
                    ("token", token),
                    ("room_id", room_id),
                    ("variant", "avc"),  // 默认 AVC
                ],
            )
        } else {
            // 不需要代理：返回 Bilibili 的直连 URL
            media.url.clone()
        }
    }
}
```

### 3.7.6 两阶段工作流示例

```rust
// ==================== 阶段1：添加媒体时（通过HTTP API） ====================

// 客户端调用: POST /api/providers/{provider_id}/parse
// Body: { "url": "https://www.bilibili.com/video/BV1xx411c7mD" }
//
// Provider 在 HTTP handler 中实现 parse 逻辑：
async fn parse_handler(
    Path(provider_id): Path<String>,
    Json(req): Json<ParseRequest>,
    Extension(registry): Extension<Arc<ProviderRegistry>>,
) -> Result<Json<ParseResult>> {
    let provider = registry.get(&provider_id)?;

    // Provider 内部实现 parse 逻辑（HTTP handler 方法）
    let result = match provider.name() {
        "bilibili" => {
            let bilibili = provider.as_any()
                .downcast_ref::<BilibiliProvider>()
                .unwrap();
            // 返回 BilibiliParseResponse（provider 特定的结构）
            bilibili.handle_parse_internal(&req.input).await?
        }
        _ => return Err(Error::NotSupported),
    };

    Ok(Json(result))
}

// Service 层处理添加媒体请求（三阶段工作流）
async fn add_media_handler(
    source_config: Value,  // 客户端构建的 source_config
    user_id: Uuid,
    room_id: String,
    provider_id: String,
) -> Result<Media> {
    // 1. 获取 provider
    let provider = registry.get(&provider_id)?;

    // 2. 构建校验上下文
    let ctx = ProviderContext::new()
        .with_requester_id(user_id);

    // 3. 调用 validate_source_config() 校验（trait 方法）
    provider.validate_source_config(&ctx, &source_config).await?;

    // 4. 存储到数据库
    let media = Media {
        id: Uuid::new_v4(),
        room_id,
        provider_name: provider.name().to_string(),
        source_config,  // 客户端构建的 source_config
        created_by: user_id,
        ..Default::default()
    };

    db.save_media(&media).await?;

    // 5. 返回给客户端
    Ok(media)
}

// ==================== 阶段2：播放媒体时 ====================

// 用户请求播放媒体
async fn get_playback_info_handler(
    media_id: Uuid,
    user_id: Uuid,
    room_id: String,
) -> Result<PlaybackResponse> {
    // 1. 从数据库读取媒体信息（包含source_config）
    let media = db.get_media(media_id).await?;

    // 2. 获取对应的Provider实例
    let provider = registry.get_instance(&media.provider_name).await
        .ok_or(Error::ProviderNotFound)?;

    // 3. 调用generate_playback动态生成播放信息
    let ctx = ProviderContext::new(Some(&user_id), &room_id);
    let playback_result = provider.generate_playback(&ctx, &media).await?;

    // 4. 返回给客户端
    Ok(PlaybackResponse {
        media_id,
        playback_infos: playback_result.playback_infos,
        default_mode: playback_result.default_mode,
        metadata: playback_result.metadata,
    })
}

// 客户端收到的响应示例：
// {
//   "media_id": "550e8400-e29b-41d4-a716-446655440000",
//   "playback_infos": {
//     "direct": {
//       "urls": [
//         {
//           "name": "1080P",
//           "url": "https://upos-xxx.bilivideo.com/upgcxcode/xxx.m4s",
//           "headers": { "Referer": "https://www.bilibili.com" },
//           "metadata": { "quality": "1080p", "codec": "hevc" }
//         }
//       ],
//       "default_url_index": 0,
//       "subtitles": [...],
//       "danmakus": [
//         {
//           "name": "Bilibili弹幕",
//           "url": "https://api.bilibili.com/x/v1/dm/list.so?oid=123456",
//           "format": "bilibili",
//           "headers": {}
//         }
//       ]
//     },
//     "proxied": {
//       "urls": [
//         {
//           "name": "HEVC (代理)",
//           "url": "/api/providers/bilibili_main/proxy/550e8400.../mpd/hevc",
//           "headers": {},
//           "metadata": { "codec": "hevc" }
//         }
//       ],
//       "default_url_index": 0,
//       "subtitles": [...],
//       "danmakus": [
//         {
//           "name": "Bilibili弹幕 (代理)",
//           "url": "/api/providers/bilibili_main/proxy/550e8400.../danmaku",
//           "format": "bilibili",
//           "headers": {}
//         }
//       ]
//     }
//   },
//   "default_mode": "proxied",
//   "metadata": {
//     "duration": 360.5,
//     "thumbnail": "https://i0.hdslb.com/bfs/archive/xxx.jpg"
//   }
// }
```

### 3.7.7 Provider 注册和初始化

```rust
// main.rs

use synctv::providers::{
    ProviderRegistry,
    bilibili::BilibiliProvider,
    alist::AlistProvider,
    emby::EmbyProvider,
};

#[tokio::main]
async fn main() -> Result<()> {
    // 1. 创建 provider 注册表
    let registry = Arc::new(ProviderRegistry::new());

    // 2. 注册 provider 工厂
    registry.register_factory("bilibili", Arc::new(|config| {
        Ok(Arc::new(BilibiliProvider::new(config)?))
    })).await;

    registry.register_factory("alist", Arc::new(|config| {
        Ok(Arc::new(AlistProvider::new(config)?))
    })).await;

    registry.register_factory("emby", Arc::new(|config| {
        Ok(Arc::new(EmbyProvider::new(config)?))
    })).await;

    // 3. 从配置文件或数据库加载Provider实例配置并创建实例
    let source_configs = load_source_configs_from_db(&db).await?;

    for config in source_configs {
        registry.create_instance(
            &config.provider_type,
            &config.instance_id,
            config,
        ).await?;
    }

    // 4. 构建 HTTP 路由（包含Provider自定义的代理路由）
    let provider_routes = registry.build_routes().await;

    // 5. 组合到主应用路由
    let app = Router::new()
        .nest("/", provider_routes)  // Provider 自定义路由（parse、browse、proxy 端点）
        .route("/api/media/add", post(add_media_handler))           // 添加媒体（调用 provider parse 端点）
        .route("/api/media/:id/playback", get(get_playback_info))   // 获取播放信息（调用generate_playback trait）
        // ... 其他路由
        .with_state(AppState {
            db,
            registry,
            // ...
        });

    // 6. 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    axum::serve(listener, app).await?;

    Ok(())
}

// ==================== 数据流向总结 ====================
//
// [解析输入阶段]
// 1. 客户端 POST /api/providers/{provider_id}/parse { input: "https://..." }
// 2. Provider parse handler 返回 provider 特定的响应（如 BilibiliParseResponse）
// 3. 客户端展示选项给用户
//
// [添加媒体阶段]
// 1. 用户选择选项 + 客户端构建 source_config
// 2. 客户端 POST /api/media/add { source_config, ... }
// 3. add_media_handler 调用 provider.validate_source_config(source_config) 校验
// 4. 存储到数据库: medias.source_config = source_config
//
// [播放媒体阶段]
// 1. 客户端 GET /api/media/{id}/playback
// 2. get_playback_info 从数据库读取 media（含source_config）
// 3. 调用 provider.generate_playback(ctx, source_config) trait 方法
// 4. generate_playback 根据 source_config 动态生成播放信息
// 5. 返回 PlaybackResult（包含urls、subtitles、danmakus等）
//
// [代理请求阶段]（可选，仅当客户端选择代理模式时）
// 1. 客户端请求代理URL: GET /api/providers/{instance}/proxy/*path
// 2. Provider 的 HTTP proxy handler 处理代理请求
// 3. 返回实际的视频数据流
```

### 3.7.8 设计优势

**核心优势**：

- ✅ **两阶段设计**：parse HTTP 端点（添加）和 generate_playback trait（播放）分离，职责清晰
- ✅ **轻量存储**：数据库只存source_config，播放信息动态生成，避免过期问题
- ✅ **插件化**：Provider 注册与创建分离，支持动态加载
- ✅ **独立路由**：每个 Provider 通过 register_http_routes() 注册自己的 HTTP 端点（parse、browse、proxy）
- ✅ **灵活模式**：Provider 可自定义任意数量的播放模式（direct、proxied等）
- ✅ **类型安全**：Rust 编译器保证类型正确
- ✅ **统一接口**：MediaProvider trait 统一抽象
- ✅ **并发安全**：Arc + RwLock 保证线程安全
- ✅ **易测试**：基于 trait 的设计便于单元测试
- ✅ **零成本**：Provider 特定功能通过默认实现，不影响其他 Provider

**两阶段设计的优势**：

1. **存储优化**：数据库只存储source_config配置，不存储易过期的播放URL
2. **实时性**：每次播放时动态生成最新的URL和元数据，避免缓存过期
3. **灵活性**：Provider可根据用户权限、网络环境等动态调整播放策略
4. **解耦**：添加媒体和播放媒体两个阶段职责分离，便于维护

---

## 3.8 ID 映射层

### 3.8.1 设计原则

**统一 ID 策略**：

- **数据库层**：使用 UUID 作为主键
- **API/缓存层**：使用 nanoid 作为外部标识符
- **双向映射**：IdMapper 提供 nanoid ↔ UUID 的双向转换
- **Service 层**：所有函数签名接受 `&str` (nanoid)，内部转换为 UUID

**优势**：

- ✅ nanoid 更短（21字符 vs 36字符），节省带宽和存储
- ✅ nanoid URL友好，无需转义
- ✅ 数据库保持 UUID 标准，便于扩展和迁移
- ✅ 统一的 Service 层接口

### 3.8.2 IdMapper 实现

```rust
// utils/id.rs
use dashmap::DashMap;
use nanoid::nanoid;
use uuid::Uuid;

/// ID 映射器（nanoid ↔ UUID）
pub struct IdMapper {
    /// nanoid -> UUID 映射
    nanoid_to_uuid: Arc<DashMap<String, Uuid>>,
    /// UUID -> nanoid 映射
    uuid_to_nanoid: Arc<DashMap<Uuid, String>>,
    /// Redis 客户端（用于持久化映射）
    redis: deadpool_redis::Pool,
}

impl IdMapper {
    pub fn new(redis: deadpool_redis::Pool) -> Self {
        Self {
            nanoid_to_uuid: Arc::new(DashMap::new()),
            uuid_to_nanoid: Arc::new(DashMap::new()),
            redis,
        }
    }

    /// 为新的 UUID 生成对应的 nanoid
    pub async fn generate_nanoid_for_uuid(&self, uuid: Uuid) -> Result<String> {
        // 检查是否已存在映射
        if let Some(nanoid) = self.uuid_to_nanoid.get(&uuid) {
            return Ok(nanoid.clone());
        }

        // 生成新的 nanoid
        let nanoid = nanoid!(21);  // 21 字符，与 UUID 安全性相当

        // 双向存储
        self.nanoid_to_uuid.insert(nanoid.clone(), uuid);
        self.uuid_to_nanoid.insert(uuid, nanoid.clone());

        // 持久化到 Redis（TTL 30天，用于缓存加速）
        let mut conn = self.redis.get().await?;
        let ttl = 30 * 24 * 3600; // 30天

        redis::pipe()
            .cmd("SET")
            .arg(&format!("id:n2u:{}", nanoid))
            .arg(uuid.to_string())
            .arg("EX")
            .arg(ttl)
            .cmd("SET")
            .arg(&format!("id:u2n:{}", uuid))
            .arg(&nanoid)
            .arg("EX")
            .arg(ttl)
            .query_async(&mut *conn)
            .await?;

        Ok(nanoid)
    }

    /// nanoid -> UUID 转换
    pub async fn nanoid_to_uuid(&self, nanoid: &str) -> Result<Uuid> {
        // 1. 检查本地缓存
        if let Some(uuid) = self.nanoid_to_uuid.get(nanoid) {
            return Ok(*uuid);
        }

        // 2. 查询 Redis
        let mut conn = self.redis.get().await?;
        let key = format!("id:n2u:{}", nanoid);

        if let Some(uuid_str): Option<String> = redis::cmd("GET")
            .arg(&key)
            .query_async(&mut *conn)
            .await?
        {
            let uuid = Uuid::parse_str(&uuid_str)?;
            // 更新本地缓存
            self.nanoid_to_uuid.insert(nanoid.to_string(), uuid);
            self.uuid_to_nanoid.insert(uuid, nanoid.to_string());
            return Ok(uuid);
        }

        // 3. 查询数据库（作为最后手段）
        // 这里假设有一个专门的 id_mappings 表存储映射关系
        let uuid = sqlx::query_scalar!(
            "SELECT uuid FROM id_mappings WHERE nanoid = $1",
            nanoid
        )
        .fetch_optional(&pool)
        .await?
        .ok_or(Error::IdNotFound)?;

        // 更新缓存
        self.nanoid_to_uuid.insert(nanoid.to_string(), uuid);
        self.uuid_to_nanoid.insert(uuid, nanoid.to_string());

        Ok(uuid)
    }

    /// UUID -> nanoid 转换
    pub async fn uuid_to_nanoid(&self, uuid: Uuid) -> Result<String> {
        // 1. 检查本地缓存
        if let Some(nanoid) = self.uuid_to_nanoid.get(&uuid) {
            return Ok(nanoid.clone());
        }

        // 2. 查询 Redis
        let mut conn = self.redis.get().await?;
        let key = format!("id:u2n:{}", uuid);

        if let Some(nanoid): Option<String> = redis::cmd("GET")
            .arg(&key)
            .query_async(&mut *conn)
            .await?
        {
            // 更新本地缓存
            self.nanoid_to_uuid.insert(nanoid.clone(), uuid);
            self.uuid_to_nanoid.insert(uuid, nanoid.clone());
            return Ok(nanoid);
        }

        // 3. 查询数据库
        let nanoid = sqlx::query_scalar!(
            "SELECT nanoid FROM id_mappings WHERE uuid = $1",
            uuid
        )
        .fetch_optional(&pool)
        .await?
        .ok_or(Error::IdNotFound)?;

        // 更新缓存
        self.nanoid_to_uuid.insert(nanoid.clone(), uuid);
        self.uuid_to_nanoid.insert(uuid, nanoid.clone());

        Ok(nanoid)
    }

    /// 批量转换（优化性能）
    pub async fn batch_uuid_to_nanoid(&self, uuids: &[Uuid]) -> Result<Vec<String>> {
        let mut result = Vec::with_capacity(uuids.len());

        for uuid in uuids {
            let nanoid = self.uuid_to_nanoid(*uuid).await?;
            result.push(nanoid);
        }

        Ok(result)
    }
}
```

### 3.8.3 数据模型规范

**所有数据模型遵循以下规范**：

```rust
// model/user.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    /// 外部 ID (nanoid)，用于 API 和缓存
    pub id: String,

    /// 内部 ID (UUID)，用于数据库操作（不序列化到 API）
    #[serde(skip)]
    pub uuid: Uuid,

    pub username: String,
    pub email: String,
    // ... 其他字段
}

impl User {
    /// 从数据库记录创建（包含 UUID）
    pub fn from_db(uuid: Uuid, nanoid: String, username: String, email: String) -> Self {
        Self {
            id: nanoid,
            uuid,
            username,
            email,
            // ...
        }
    }
}

// model/room.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Room {
    /// 外部 ID (nanoid)
    pub id: String,

    /// 内部 ID (UUID)
    #[serde(skip)]
    pub uuid: Uuid,

    pub name: String,
    pub creator_id: String,  // nanoid (外部引用也用 nanoid)
    // ... 其他字段
}
```

### 3.8.4 Service 层使用示例

```rust
// service/room_service.rs
impl RoomService {
    /// 创建房间（接受 nanoid，内部转 UUID）
    pub async fn create_room(
        &self,
        creator_id: &str,  // nanoid
        request: CreateRoomRequest,
    ) -> Result<Room> {
        // 转换 nanoid 到 UUID
        let creator_uuid = self.id_mapper
            .nanoid_to_uuid(creator_id)
            .await?;

        // 生成新的 UUID 和 nanoid
        let room_uuid = Uuid::new_v4();
        let room_nanoid = self.id_mapper
            .generate_nanoid_for_uuid(room_uuid)
            .await?;

        // 创建房间（使用 UUID）
        let room = self.room_repo.create(DbRoom {
            id: room_uuid,
            creator_id: creator_uuid,
            name: request.name,
            // ...
        }).await?;

        // 返回给客户端（使用 nanoid）
        Ok(Room {
            id: room_nanoid,
            uuid: room_uuid,
            creator_id: creator_id.to_string(),
            name: room.name,
            // ...
        })
    }

    /// 获取房间（接受 nanoid）
    pub async fn get_room(&self, room_id: &str) -> Result<Room> {
        // 转换 nanoid 到 UUID
        let room_uuid = self.id_mapper
            .nanoid_to_uuid(room_id)
            .await?;

        // 查询数据库（使用 UUID）
        let db_room = self.room_repo
            .get(room_uuid)
            .await?
            .ok_or(Error::RoomNotFound)?;

        // 转换回 nanoid 返回
        let creator_nanoid = self.id_mapper
            .uuid_to_nanoid(db_room.creator_id)
            .await?;

        Ok(Room {
            id: room_id.to_string(),
            uuid: room_uuid,
            creator_id: creator_nanoid,
            name: db_room.name,
            // ...
        })
    }
}
```

## 3.9 缓存模块

### 3.9.1 本地缓存

```rust
// cache/local.rs
use lru::LruCache;
use std::num::NonZeroUsize;

pub struct LocalCache<K, V> {
    cache: Arc<Mutex<LruCache<K, V>>>,
}

impl<K: Hash + Eq, V: Clone> LocalCache<K, V> {
    pub fn new(capacity: usize) -> Self {
        Self {
            cache: Arc::new(Mutex::new(
                LruCache::new(NonZeroUsize::new(capacity).unwrap())
            )),
        }
    }

    pub fn get(&self, key: &K) -> Option<V> {
        self.cache.lock().unwrap().get(key).cloned()
    }

    pub fn put(&self, key: K, value: V) {
        self.cache.lock().unwrap().put(key, value);
    }

    pub fn remove(&self, key: &K) -> Option<V> {
        self.cache.lock().unwrap().pop(key)
    }
}
```

## 3.10 认证授权模块

### 3.10.1 JWT 服务 (RS256)

**设计原则**：

- ✅ 使用 **RS256**（非对称加密）提供更高安全性
- ✅ Access Token 和 Refresh Token 使用不同的 Claims 结构
- ✅ 包含 `jti`（Token ID）用于撤销机制
- ✅ 包含 `iss`（签发者）用于多节点环境
- ✅ 支持 Token 黑名单/撤销

```rust
// auth/jwt.rs
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey, Algorithm};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Access Token Claims (短期有效)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessClaims {
    pub sub: String,        // 用户 ID (nanoid)
    pub username: String,   // 用户名
    pub role: String,       // 角色
    pub jti: String,        // Token ID (nanoid)
    pub iss: String,        // 签发者（节点 ID）
    pub exp: i64,           // 过期时间
    pub iat: i64,           // 签发时间
}

/// Refresh Token Claims (长期有效)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RefreshClaims {
    pub sub: String,        // 用户 ID (nanoid)
    pub jti: String,        // Token ID (nanoid)
    pub iss: String,        // 签发者（节点 ID）
    pub exp: i64,           // 过期时间
    pub iat: i64,           // 签发时间
}

/// JWT 服务（RS256）
pub struct JwtService {
    /// 私钥（用于签名）
    encoding_key: EncodingKey,
    /// 公钥（用于验证）
    decoding_key: DecodingKey,
    /// Access Token 有效期（秒）
    access_expiration: i64,
    /// Refresh Token 有效期（秒）
    refresh_expiration: i64,
    /// 签发者标识（节点 ID）
    issuer: String,
    /// Redis 客户端（用于黑名单）
    redis: deadpool_redis::Pool,
}

impl JwtService {
    /// 创建 JWT 服务（RS256）
    ///
    /// # Parameters
    /// - `private_key_pem`: RSA 私钥（PEM 格式）
    /// - `public_key_pem`: RSA 公钥（PEM 格式）
    /// - `access_expiration_seconds`: Access Token 有效期（秒），建议 3600 (1小时)
    /// - `refresh_expiration_seconds`: Refresh Token 有效期（秒），建议 2592000 (30天)
    /// - `issuer`: 签发者标识（节点 ID）
    pub fn new(
        private_key_pem: &[u8],
        public_key_pem: &[u8],
        access_expiration_seconds: i64,
        refresh_expiration_seconds: i64,
        issuer: String,
        redis: deadpool_redis::Pool,
    ) -> Result<Self> {
        let encoding_key = EncodingKey::from_rsa_pem(private_key_pem)?;
        let decoding_key = DecodingKey::from_rsa_pem(public_key_pem)?;

        Ok(Self {
            encoding_key,
            decoding_key,
            access_expiration: access_expiration_seconds,
            refresh_expiration: refresh_expiration_seconds,
            issuer,
            redis,
        })
    }

    /// 生成 Access Token
    pub async fn generate_access_token(
        &self,
        user_id: &str,      // nanoid
        username: String,
        role: String,
    ) -> Result<String> {
        let now = Utc::now().timestamp();
        let jti = nanoid::nanoid!(21);

        let claims = AccessClaims {
            sub: user_id.to_string(),
            username,
            role,
            jti,
            iss: self.issuer.clone(),
            exp: now + self.access_expiration,
            iat: now,
        };

        let mut header = Header::new(Algorithm::RS256);
        header.kid = Some(self.issuer.clone());  // Key ID

        encode(&header, &claims, &self.encoding_key)
            .map_err(|e| Error::TokenGenerationError(e.to_string()))
    }

    /// 生成 Refresh Token
    pub async fn generate_refresh_token(&self, user_id: &str) -> Result<String> {
        let now = Utc::now().timestamp();
        let jti = nanoid::nanoid!(21);

        let claims = RefreshClaims {
            sub: user_id.to_string(),
            jti: jti.clone(),
            iss: self.issuer.clone(),
            exp: now + self.refresh_expiration,
            iat: now,
        };

        // 存储 Refresh Token 到 Redis（用于撤销检查）
        self.store_refresh_token(user_id, &jti, self.refresh_expiration).await?;

        let mut header = Header::new(Algorithm::RS256);
        header.kid = Some(self.issuer.clone());

        encode(&header, &claims, &self.encoding_key)
            .map_err(|e| Error::TokenGenerationError(e.to_string()))
    }

    /// 验证 Access Token
    pub async fn verify_access_token(&self, token: &str) -> Result<AccessClaims> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.set_issuer(&[&self.issuer]);

        let token_data = decode::<AccessClaims>(token, &self.decoding_key, &validation)
            .map_err(|e| Error::TokenVerificationError(e.to_string()))?;

        let claims = token_data.claims;

        // 检查是否在黑名单中
        if self.is_token_revoked(&claims.jti).await? {
            return Err(Error::TokenRevoked);
        }

        Ok(claims)
    }

    /// 验证 Refresh Token
    pub async fn verify_refresh_token(&self, token: &str) -> Result<RefreshClaims> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.set_issuer(&[&self.issuer]);

        let token_data = decode::<RefreshClaims>(token, &self.decoding_key, &validation)
            .map_err(|e| Error::TokenVerificationError(e.to_string()))?;

        let claims = token_data.claims;

        // 检查 Refresh Token 是否存在于 Redis（未被撤销）
        if !self.is_refresh_token_valid(&claims.sub, &claims.jti).await? {
            return Err(Error::TokenRevoked);
        }

        Ok(claims)
    }

    /// 撤销 Access Token（加入黑名单）
    pub async fn revoke_access_token(&self, jti: &str, exp: i64) -> Result<()> {
        let mut conn = self.redis.get().await?;

        // 计算 TTL（黑名单只需保留到 token 过期）
        let now = Utc::now().timestamp();
        let ttl = (exp - now).max(0);

        if ttl > 0 {
            redis::cmd("SETEX")
                .arg(&format!("token:blacklist:{}", jti))
                .arg(ttl as usize)
                .arg("1")
                .query_async(&mut *conn)
                .await?;
        }

        Ok(())
    }

    /// 撤销 Refresh Token（从 Redis 删除）
    pub async fn revoke_refresh_token(&self, user_id: &str, jti: &str) -> Result<()> {
        let mut conn = self.redis.get().await?;

        redis::cmd("DEL")
            .arg(&format!("token:refresh:{}:{}", user_id, jti))
            .query_async(&mut *conn)
            .await?;

        Ok(())
    }

    /// 撤销用户所有 Refresh Token（强制重新登录）
    pub async fn revoke_all_refresh_tokens(&self, user_id: &str) -> Result<()> {
        let mut conn = self.redis.get().await?;

        // 查找该用户的所有 Refresh Token
        let pattern = format!("token:refresh:{}:*", user_id);
        let keys: Vec<String> = redis::cmd("KEYS")
            .arg(&pattern)
            .query_async(&mut *conn)
            .await?;

        if !keys.is_empty() {
            redis::cmd("DEL")
                .arg(&keys)
                .query_async(&mut *conn)
                .await?;
        }

        Ok(())
    }

    /// 使用 Refresh Token 刷新 Access Token
    pub async fn refresh_access_token(
        &self,
        refresh_token: &str,
        username: String,
        role: String,
    ) -> Result<String> {
        // 验证 Refresh Token
        let claims = self.verify_refresh_token(refresh_token).await?;

        // 生成新的 Access Token
        self.generate_access_token(&claims.sub, username, role).await
    }

    // ==================== 私有辅助方法 ====================

    /// 存储 Refresh Token 到 Redis
    async fn store_refresh_token(&self, user_id: &str, jti: &str, ttl: i64) -> Result<()> {
        let mut conn = self.redis.get().await?;

        redis::cmd("SETEX")
            .arg(&format!("token:refresh:{}:{}", user_id, jti))
            .arg(ttl as usize)
            .arg("1")
            .query_async(&mut *conn)
            .await?;

        Ok(())
    }

    /// 检查 Token 是否在黑名单中
    async fn is_token_revoked(&self, jti: &str) -> Result<bool> {
        let mut conn = self.redis.get().await?;

        let exists: bool = redis::cmd("EXISTS")
            .arg(&format!("token:blacklist:{}", jti))
            .query_async(&mut *conn)
            .await?;

        Ok(exists)
    }

    /// 检查 Refresh Token 是否有效
    async fn is_refresh_token_valid(&self, user_id: &str, jti: &str) -> Result<bool> {
        let mut conn = self.redis.get().await?;

        let exists: bool = redis::cmd("EXISTS")
            .arg(&format!("token:refresh:{}:{}", user_id, jti))
            .query_async(&mut *conn)
            .await?;

        Ok(exists)
    }
}

// ==================== RSA 密钥生成工具 ====================

/// 生成 RSA 密钥对（用于初始化）
///
/// # Example
/// ```rust
/// let (private_key_pem, public_key_pem) = generate_rsa_keypair(2048)?;
/// std::fs::write("private_key.pem", &private_key_pem)?;
/// std::fs::write("public_key.pem", &public_key_pem)?;
/// ```
pub fn generate_rsa_keypair(bits: usize) -> Result<(Vec<u8>, Vec<u8>)> {
    use rsa::{RsaPrivateKey, RsaPublicKey};
    use rsa::pkcs8::{EncodePrivateKey, EncodePublicKey};

    let mut rng = rand::thread_rng();
    let private_key = RsaPrivateKey::new(&mut rng, bits)?;
    let public_key = RsaPublicKey::from(&private_key);

    let private_pem = private_key.to_pkcs8_pem(rsa::pkcs8::LineEnding::LF)?;
    let public_pem = public_key.to_public_key_pem(rsa::pkcs8::LineEnding::LF)?;

    Ok((private_pem.as_bytes().to_vec(), public_pem.as_bytes().to_vec()))
}
```

### 3.10.2 Token 使用示例

```rust
// service/user_service.rs

impl UserService {
    /// 用户登录
    pub async fn login(&self, username: &str, password: &str) -> Result<LoginResponse> {
        // 验证用户名密码
        let user = self.user_repo.get_by_username(username).await?
            .ok_or(Error::InvalidCredentials)?;

        if !verify_password(password, &user.password_hash)? {
            return Err(Error::InvalidCredentials);
        }

        // 生成 nanoid
        let user_nanoid = self.id_mapper.uuid_to_nanoid(user.id).await?;

        // 生成 tokens
        let access_token = self.jwt_service
            .generate_access_token(&user_nanoid, user.username.clone(), user.role.clone())
            .await?;

        let refresh_token = self.jwt_service
            .generate_refresh_token(&user_nanoid)
            .await?;

        Ok(LoginResponse {
            user: user.into(),
            access_token,
            refresh_token,
            expires_in: 3600,  // 1 hour
        })
    }

    /// 刷新 Access Token
    pub async fn refresh_token(&self, refresh_token: &str) -> Result<RefreshResponse> {
        // 验证 Refresh Token
        let claims = self.jwt_service
            .verify_refresh_token(refresh_token)
            .await?;

        // 获取用户信息
        let user_uuid = self.id_mapper.nanoid_to_uuid(&claims.sub).await?;
        let user = self.user_repo.get(user_uuid).await?
            .ok_or(Error::UserNotFound)?;

        // 生成新的 Access Token
        let access_token = self.jwt_service
            .refresh_access_token(refresh_token, user.username, user.role)
            .await?;

        Ok(RefreshResponse {
            access_token,
            expires_in: 3600,
        })
    }

    /// 登出（撤销所有 tokens）
    pub async fn logout(&self, user_id: &str, access_token_jti: &str, access_token_exp: i64) -> Result<()> {
        // 撤销 Access Token（加入黑名单）
        self.jwt_service
            .revoke_access_token(access_token_jti, access_token_exp)
            .await?;

        // 撤销所有 Refresh Token
        self.jwt_service
            .revoke_all_refresh_tokens(user_id)
            .await?;

        Ok(())
    }
}
```

---

**上一章**: [02-整体架构](./02-整体架构.md)
**下一章**: [04-数据库设计](./04-数据库设计.md)
