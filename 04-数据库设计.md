# 04. 数据库设计

---

## 目录

- [1. 数据库选型](#1-数据库选型)
- [2. 核心表设计](#2-核心表设计)
- [3. 认证与授权表](#3-认证与授权表)
- [4. 索引设计](#4-索引设计)
- [5. 查询优化](#5-查询优化)
- [6. 数据迁移](#6-数据迁移)

---

## 1. 数据库选型

> 详细配置参见 [19-配置管理系统](./19-配置管理系统.md)

### 1.1 选型对比

| 数据库 | 优势 | 劣势 | 适用场景 |
|--------|------|------|---------|
| **PostgreSQL** | 成熟稳定、JSONB、丰富索引、主从复制 | 水平扩展复杂 | 推荐用于主数据库 |
| **CockroachDB** | 原生分布式、自动分片、强一致性 | 相对较新、学习成本 | 大规模部署 |
| **MySQL** | 生态成熟、工具丰富 | JSONB 支持较弱 | 备选方案 |

**最终选择**: PostgreSQL 15+ + Redis 7+

**理由**:

1. PostgreSQL 的 JSONB 非常适合存储动态字段
2. 丰富的索引类型（GIN、GiST、BRIN）支持复杂查询
3. sqlx 对 PostgreSQL 支持最好,编译时检查
4. 主从复制满足高可用需求
5. Redis 作为缓存和消息总线

### 1.2 连接配置

```rust
// db/connection.rs
pub async fn create_pool(config: &DatabaseConfig) -> Result<PgPool> {
    let pool = PgPoolOptions::new()
        .max_connections(50)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(5))
        .idle_timeout(Some(Duration::from_secs(600)))
        .max_lifetime(Some(Duration::from_secs(3600)))
        .connect(&config.url)
        .await?;

    // 运行迁移
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await?;

    Ok(pool)
}
```

---

## 2. 核心表设计

### 2.1 用户表 (users)

> 详细设计参见 [06-用户系统设计](./06-用户系统设计.md)

```sql
-- migrations/001_create_users.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 用户角色（权限级别）
CREATE TYPE user_role AS ENUM ('root', 'admin', 'user');

-- 用户状态（账号状态）
CREATE TYPE user_status AS ENUM ('active', 'pending', 'banned');

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    password_hash VARCHAR(255) NOT NULL,

    -- 角色与状态分离
    role user_role NOT NULL DEFAULT 'user',
    status user_status NOT NULL DEFAULT 'pending',

    avatar_url TEXT,
    bio TEXT,

    -- 登录信息
    last_login_at TIMESTAMPTZ,
    last_login_ip INET,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT username_length CHECK (length(username) >= 3 AND length(username) <= 50),
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
);

-- 索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role) WHERE role IN ('admin', 'root');
CREATE INDEX idx_users_status ON users(status) WHERE status IN ('pending', 'banned');
CREATE INDEX idx_users_email_verified ON users(email_verified) WHERE email_verified = FALSE;
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- 更新时间触发器
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE users IS '用户表（角色与状态分离设计）';
COMMENT ON COLUMN users.role IS '用户角色（权限级别）：root=超级管理员, admin=管理员, user=普通用户';
COMMENT ON COLUMN users.status IS '用户状态（账号状态）：active=正常, pending=待审核, banned=封禁';
COMMENT ON COLUMN users.email_verified IS '邮箱是否已验证';
```

**角色与状态说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `role` | user_role | 权限级别，决定用户可以执行的操作 |
| `status` | user_status | 账号状态，决定用户是否可以登录 |

**权限判断逻辑**：

- 用户必须同时满足 `status='active'` 和 `role` 权限要求
- 例如：`status='banned'` 的用户即使是 `role='admin'` 也无法登录
- 详细权限设计见 [07-权限系统设计](./07-权限系统设计.md)

```

### 2.2 房间表 (rooms)

```sql
-- migrations/002_create_rooms.sql
CREATE TYPE room_status AS ENUM ('banned', 'pending', 'active', 'deleted');

CREATE TABLE rooms (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    creator_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status room_status NOT NULL DEFAULT 'active',

    password_hash VARCHAR(255),  -- NULL 表示无密码
    description TEXT,

    -- 房间设置（JSONB 存储灵活配置）
    settings JSONB NOT NULL DEFAULT '{
        "hidden": false,
        "enable_guest": true,
        "max_members": 100,
        "enable_auto_play": true,
        "auto_play_mode": "sequential"
    }'::jsonb,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT name_length CHECK (length(name) >= 1 AND length(name) <= 100)
);

-- 索引
CREATE INDEX idx_rooms_creator ON rooms(creator_id);
CREATE INDEX idx_rooms_status ON rooms(status) WHERE status = 'active';
CREATE INDEX idx_rooms_created_at ON rooms(created_at DESC);
CREATE INDEX idx_rooms_name_gin ON rooms USING gin(to_tsvector('simple', name));
CREATE INDEX idx_rooms_settings ON rooms USING gin(settings);

CREATE TRIGGER update_rooms_updated_at
    BEFORE UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE rooms IS '房间表';
COMMENT ON COLUMN rooms.settings IS '房间设置（JSON格式）';
```

### 2.3 房间成员表 (room_members)

> 详细权限设计参见 [07-权限系统设计](./07-权限系统设计.md)

```sql
-- migrations/003_create_room_members.sql
CREATE TYPE room_role AS ENUM ('creator', 'admin', 'member', 'guest');
CREATE TYPE member_status AS ENUM ('banned', 'pending', 'active');

CREATE TABLE room_members (
    room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    role room_role NOT NULL DEFAULT 'member',
    status member_status NOT NULL DEFAULT 'active',

    -- Allow/Deny 权限模式 (详见 07-权限系统设计.md §8)
    -- NULL = 使用角色默认权限
    added_permissions BIGINT,      -- 额外添加的权限（在角色默认之上）
    removed_permissions BIGINT,    -- 移除的权限（从角色默认中移除）

    -- 用于乐观锁
    version BIGINT NOT NULL DEFAULT 0,

    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    PRIMARY KEY (room_id, user_id)
);

-- 索引
CREATE INDEX idx_room_members_user ON room_members(user_id);
CREATE INDEX idx_room_members_status ON room_members(room_id, status) WHERE status = 'active';
CREATE INDEX idx_room_members_role ON room_members(room_id, role);
CREATE INDEX idx_room_members_joined_at ON room_members(room_id, joined_at DESC);
CREATE INDEX idx_room_members_version ON room_members(room_id, user_id, version);

CREATE TRIGGER update_room_members_updated_at
    BEFORE UPDATE ON room_members
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE room_members IS '房间成员表';
COMMENT ON COLUMN room_members.role IS '房间角色：creator=创建者, admin=管理员, member=普通成员, guest=访客';
COMMENT ON COLUMN room_members.added_permissions IS '额外添加的权限（在角色默认之上），NULL表示无额外权限';
COMMENT ON COLUMN room_members.removed_permissions IS '移除的权限（从角色默认中移除），NULL表示不移除任何权限';
```

**权限计算方式** (详见 [07-权限系统设计 §8](./07-权限系统设计.md#8-权限更新与兼容性问题)):

```rust
// 有效权限 = (角色默认权限 | 额外添加的权限) & ~移除的权限
fn effective_permissions(&self, room: &Room) -> u64 {
    let base = self.get_role_base_permissions(room);
    let added = self.added_permissions.unwrap_or(0);
    let removed = self.removed_permissions.unwrap_or(0);

    (base | added) & !removed
}
```

**优势**：

- ✅ 新增权限自动生效（从角色默认继承）
- ✅ 用户个性化设置保留（added/removed独立存储）
- ✅ 符合直觉（增量修改而非完全覆盖）

**权限位定义** (与 [07-权限系统设计](./07-权限系统设计.md) 一致):

```rust
// model/permission.rs
pub struct Permissions(pub u64);

impl Permissions {
    // ===== 内容管理权限 (0-9) =====
    pub const SEND_CHAT: u64 = 1 << 0;
    pub const ADD_MOVIE: u64 = 1 << 1;
    pub const DELETE_MOVIE_SELF: u64 = 1 << 2;
    pub const DELETE_MOVIE_ANY: u64 = 1 << 3;
    pub const EDIT_MOVIE_SELF: u64 = 1 << 4;
    pub const EDIT_MOVIE_ANY: u64 = 1 << 5;
    pub const REORDER_PLAYLIST: u64 = 1 << 6;
    pub const CLEAR_PLAYLIST: u64 = 1 << 7;

    // ===== 播放控制权限 (10-19) =====
    pub const PLAY_CONTROL: u64 = 1 << 10;
    pub const CHANGE_CURRENT_MOVIE: u64 = 1 << 11;
    pub const CHANGE_PLAYBACK_RATE: u64 = 1 << 12;

    // ===== 成员管理权限 (20-29) =====
    pub const APPROVE_MEMBER: u64 = 1 << 20;
    pub const KICK_MEMBER: u64 = 1 << 21;
    pub const BAN_MEMBER: u64 = 1 << 22;
    pub const SET_MEMBER_PERMISSIONS: u64 = 1 << 23;
    pub const MANAGE_ADMIN: u64 = 1 << 24;

    // ===== 房间管理权限 (30-39) =====
    pub const SET_ROOM_SETTINGS: u64 = 1 << 30;
    pub const SET_ROOM_PASSWORD: u64 = 1 << 31;
    pub const DELETE_CHAT: u64 = 1 << 32;
    pub const VIEW_STATS: u64 = 1 << 33;
    pub const EXPORT_DATA: u64 = 1 << 34;
    pub const DELETE_ROOM: u64 = 1 << 35;

    // ===== 查看权限 (40-49) =====
    pub const VIEW_PLAYLIST: u64 = 1 << 40;
    pub const VIEW_MEMBER_LIST: u64 = 1 << 41;
    pub const VIEW_CHAT_HISTORY: u64 = 1 << 42;

    // ===== 通信权限 (50-59) =====
    pub const USE_WEBRTC: u64 = 1 << 50;

    // ===== 权限组合 =====
    pub const ALL: u64 = u64::MAX;

    pub const DEFAULT_MEMBER: u64 = Self::SEND_CHAT
        | Self::ADD_MOVIE
        | Self::DELETE_MOVIE_SELF
        | Self::EDIT_MOVIE_SELF
        | Self::VIEW_PLAYLIST
        | Self::VIEW_MEMBER_LIST
        | Self::VIEW_CHAT_HISTORY;

    pub const DEFAULT_ADMIN: u64 = Self::DEFAULT_MEMBER
        | Self::DELETE_MOVIE_ANY
        | Self::EDIT_MOVIE_ANY
        | Self::REORDER_PLAYLIST
        | Self::CLEAR_PLAYLIST
        | Self::PLAY_CONTROL
        | Self::CHANGE_CURRENT_MOVIE
        | Self::CHANGE_PLAYBACK_RATE
        | Self::APPROVE_MEMBER
        | Self::KICK_MEMBER
        | Self::BAN_MEMBER
        | Self::SET_ROOM_SETTINGS
        | Self::SET_ROOM_PASSWORD
        | Self::DELETE_CHAT
        | Self::VIEW_STATS;

    pub const DEFAULT_GUEST: u64 = Self::VIEW_PLAYLIST;

    pub fn has(&self, permission: u64) -> bool {
        (self.0 & permission) != 0
    }

    pub fn has_all(&self, permissions: u64) -> bool {
        (self.0 & permissions) == permissions
    }

    pub fn has_any(&self, permissions: u64) -> bool {
        (self.0 & permissions) != 0
    }
}
```

### 2.4 播放列表与视频内容表（类表继承设计）

> **设计思想**: 参考Unix文件系统的inode设计，将目录项（通用元数据）与内容（特定元数据）分离。

#### 2.4.1 播放列表（目录）表 (playlists)

存储播放列表的树形目录结构，类似文件系统的目录。

**设计理念**：

- 每个房间有一个根目录，name 为空字符串 `''`（parent_id=NULL）
- 支持无限层级嵌套：`/aaa/bbb/ccc`
- 同一目录下不能有同名子目录（唯一索引）
- 支持手动排序（position 字段）
- 完全禁止 name 中包含 `/` 字符

```sql
-- migrations/004_create_playlists.sql
CREATE TYPE source_provider AS ENUM (
    'direct_url',  -- 直接URL（点播视频）
    'bilibili',    -- B站视频（点播视频）
    'alist',       -- Alist文件（点播视频）
    'emby',        -- Emby媒体服务器（点播视频）
    'rtmp'         -- RTMP直播流（直播）
);

CREATE TABLE playlists (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- 基本信息
    room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    creator_id UUID NOT NULL REFERENCES users(id),

    -- 目录名称（根目录为空字符串）
    name VARCHAR(255) NOT NULL DEFAULT '',

    -- 树形结构（文件系统风格）
    parent_id UUID REFERENCES playlists(id) ON DELETE CASCADE,

    -- 排序位置（支持手动调整目录顺序）
    position INT NOT NULL DEFAULT 0,

    -- ========== 动态目录支持 ==========
    -- 如果 source_provider 不为 NULL，则为动态目录（内容由供应商动态提供）
    -- 如果 source_provider 为 NULL，则为静态目录（可手动添加子项）
    source_provider source_provider,
    source_config JSONB,                           -- 供应商配置
                                                   -- - Alist: {"path": "/{server_id}/movies", "password": ""}
                                                   -- - Bilibili: {"bvid": "BV1xx", "share": true}
    provider_instance_name VARCHAR(64),            -- 推荐的后端实例（可选，仅作为提示传递给 provider）

    -- 时间戳
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束：防止自引用
    CONSTRAINT valid_parent CHECK (parent_id IS NULL OR parent_id != id),

    -- 约束：同一目录下不能有同名子目录
    CONSTRAINT unique_playlist_name UNIQUE (room_id, parent_id, name),

    -- 约束：名称验证
    CONSTRAINT valid_name CHECK (
        -- 根目录（parent_id IS NULL）必须为空字符串
        (parent_id IS NULL AND name = '')
        OR
        -- 非根目录必须满足以下条件
        (parent_id IS NOT NULL AND (
            length(trim(name)) > 0       -- 不能为空或只有空格
            AND length(name) <= 255
            AND name NOT LIKE '%/%'      -- 禁止包含 / 字符
        ))
    ),

    -- 约束：动态目录验证
    CONSTRAINT valid_dynamic_folder CHECK (
        -- 如果是动态目录，必须有 source_config
        (source_provider IS NOT NULL AND source_config IS NOT NULL)
        OR
        -- 如果是静态目录，这些字段都应为 NULL
        (source_provider IS NULL AND source_config IS NULL)
    ),

    -- 外键约束
    CONSTRAINT fk_provider_instance FOREIGN KEY (provider_instance_name) REFERENCES provider_instances(name) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_playlists_room ON playlists(room_id);
CREATE INDEX idx_playlists_parent ON playlists(parent_id, position);
CREATE INDEX idx_playlists_tree ON playlists(room_id, parent_id, position);
CREATE INDEX idx_playlists_creator ON playlists(creator_id);
CREATE INDEX idx_playlists_source_provider ON playlists(source_provider) WHERE source_provider IS NOT NULL;
CREATE INDEX idx_playlists_provider_instance ON playlists(provider_instance_name) WHERE provider_instance_name IS NOT NULL;
CREATE INDEX idx_playlists_created_at ON playlists(created_at DESC);

CREATE TRIGGER update_playlists_updated_at
    BEFORE UPDATE ON playlists
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE playlists IS '播放列表目录表（支持静态目录和动态目录）';
COMMENT ON COLUMN playlists.name IS '目录名称（根目录为空字符串，非根目录禁止 / 字符）';
COMMENT ON COLUMN playlists.parent_id IS '父目录ID，NULL表示根目录';
COMMENT ON COLUMN playlists.position IS '在父目录中的排序位置（支持手动调整）';
COMMENT ON COLUMN playlists.source_provider IS '供应商类型（NULL=静态目录，非NULL=动态目录）';
COMMENT ON COLUMN playlists.source_config IS '供应商配置（动态目录必填），不同 Provider 有不同结构';
COMMENT ON COLUMN playlists.provider_instance_name IS '推荐的后端实例名称（可选），仅作为提示传递给 provider，具体是否使用由 provider 决定';
COMMENT ON CONSTRAINT unique_playlist_name ON playlists IS '同一目录下不能有同名子目录';
COMMENT ON CONSTRAINT valid_name ON playlists IS '名称验证：根目录必须为空字符串，非根目录不能为空/纯空格，禁止包含 / 字符';
COMMENT ON CONSTRAINT valid_dynamic_folder ON playlists IS '动态目录约束：source_provider/source_config 要么全有，要么全无';

-- 为每个房间自动创建根目录的触发器（name 为空字符串）
CREATE OR REPLACE FUNCTION create_root_playlist()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO playlists (room_id, creator_id, name, parent_id, position)
    VALUES (NEW.id, NEW.creator_id, '', NULL, 0);  -- 空字符串，静态根目录
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER create_room_root_playlist
    AFTER INSERT ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION create_root_playlist();

COMMENT ON FUNCTION create_root_playlist IS '房间创建时自动创建根目录（name 为空字符串）';
```

#### 2.4.2 媒体文件表 (medias)

#### 2.4.2.1 Provider Instance 表 (provider_instances)

存储跨地域解析的 gRPC 后端服务配置，用于分担主服务器压力。

**设计理念**：

- Instance 仅用于跨地域解析，不存储媒体配置
- 简化的后端配置（不包含服务发现机制）
- 敏感字段（jwt_secret, custom_ca）使用加密存储
- 参考 Go 版本的 VendorBackend，但移除 Consul/Etcd 服务发现

```sql
CREATE TABLE provider_instances (
    -- 主键
    name VARCHAR(64) PRIMARY KEY,

    -- 基本信息
    endpoint VARCHAR(512) NOT NULL,
    comment TEXT,

    -- gRPC 配置
    jwt_secret VARCHAR(256),        -- JWT密钥（加密存储）
    custom_ca TEXT,                 -- 自定义CA证书（加密存储）
    timeout VARCHAR(32) DEFAULT '10s',
    tls BOOLEAN NOT NULL DEFAULT false,
    insecure_tls BOOLEAN NOT NULL DEFAULT false,  -- 跳过TLS证书验证（不安全，仅用于开发/测试）

    -- Provider 支持（哪些提供商可以使用此后端）
    providers TEXT[] NOT NULL DEFAULT '{}',  -- 支持的提供商列表，如 {'bilibili', 'alist', 'emby'}

    -- 状态
    enabled BOOLEAN NOT NULL DEFAULT true,

    -- 审计
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT valid_name CHECK (length(trim(name)) > 0 AND length(name) <= 64),
    CONSTRAINT valid_endpoint CHECK (length(trim(endpoint)) > 0)
);

CREATE INDEX idx_provider_instances_enabled ON provider_instances(enabled);
CREATE INDEX idx_provider_instances_providers ON provider_instances USING gin(providers);
CREATE INDEX idx_provider_instances_endpoint ON provider_instances(endpoint);

CREATE TRIGGER update_provider_instances_updated_at
    BEFORE UPDATE ON provider_instances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE provider_instances IS 'gRPC 后端配置表（用于跨地域解析）';
COMMENT ON COLUMN provider_instances.name IS '实例名称（唯一标识符，用于引用）';
COMMENT ON COLUMN provider_instances.endpoint IS 'gRPC 服务地址（如 grpc://beijing.example.com:50051）';
COMMENT ON COLUMN provider_instances.jwt_secret IS 'JWT 密钥（加密存储）';
COMMENT ON COLUMN provider_instances.custom_ca IS '自定义 CA 证书（加密存储）';
COMMENT ON COLUMN provider_instances.timeout IS '请求超时时间（如 10s, 30s）';
COMMENT ON COLUMN provider_instances.tls IS '是否启用 TLS';
COMMENT ON COLUMN provider_instances.insecure_tls IS '是否跳过 TLS 证书验证（不安全，仅开发/测试环境使用）';
COMMENT ON COLUMN provider_instances.providers IS '支持的提供商列表（数组），如 {bilibili, alist, emby}';
COMMENT ON CONSTRAINT valid_name ON provider_instances IS '名称不能为空或纯空格';
COMMENT ON CONSTRAINT valid_endpoint ON provider_instances IS '端点地址不能为空或纯空格';
```

**配置示例**：

```sql
-- 添加北京节点（支持所有提供商，启用TLS，验证证书）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('beijing-node', 'grpc://beijing.example.com:50051', '北京节点', '10s', true, false, '{bilibili,alist,emby}', true);

-- 添加上海节点（仅支持 Bilibili）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('shanghai-node', 'grpc://shanghai.example.com:50051', '上海节点', '10s', true, false, '{bilibili}', true);

-- 添加开发环境节点（跳过证书验证，仅用于测试）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('dev-node', 'grpc://dev.example.com:50051', '开发节点', '10s', true, true, '{bilibili,alist,emby}', true);

-- 查询支持 Alist 的后端
SELECT * FROM provider_instances WHERE 'alist' = ANY(providers) AND enabled = true;

-- 通过名称查询后端
SELECT * FROM provider_instances WHERE name = 'beijing-node';
```

#### 2.4.2.2 用户 Provider 凭证表 (user_provider_credentials)

存储用户的媒体源提供商凭证（如 Bilibili Cookie、Alist 账户、Emby API Key）。

**设计理念**：

- **单表存储所有凭证**：使用 JSONB 灵活适配不同 Provider
- **ServerID 必需**：用于区分不同的服务器/账号
  - Bilibili: `server_id = "bilibili"`（固定常量，确保每个用户只能绑定一个账号）
  - Alist/Emby: `server_id = MD5(host)`（支持绑定多个服务器）
- **无需加密**：简化实现（Rust 版本不需要加密）
- **后端关联**：可选关联 provider_instances，用于指定解析后端

```sql
CREATE TABLE user_provider_credentials (
    -- 主键
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 用户和提供商
    user_id UUID NOT NULL,
    provider VARCHAR(32) NOT NULL,  -- bilibili, alist, emby

    -- 服务器标识（必需，用于区分不同服务器/账号）
    server_id VARCHAR(64) NOT NULL,  -- Alist/Emby: MD5(host), Bilibili: "bilibili" 或账号标识

    -- 关联的后端实例（可选）
    provider_instance_name VARCHAR(64),

    -- 凭证数据（JSONB，加密存储）
    credential_data BYTEA NOT NULL,  -- AES-256-GCM 加密后的 JSONB 数据

    -- 过期时间（可选）
    expires_at TIMESTAMPTZ,

    -- 审计
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_provider_instance FOREIGN KEY (provider_instance_name) REFERENCES provider_instances(name) ON DELETE SET NULL,
    CONSTRAINT unique_user_provider_server UNIQUE(user_id, provider, server_id),
    CONSTRAINT valid_server_id CHECK (length(trim(server_id)) > 0 AND length(server_id) <= 64)
);

CREATE INDEX idx_user_credentials_user ON user_provider_credentials(user_id);
CREATE INDEX idx_user_credentials_provider ON user_provider_credentials(provider);
CREATE INDEX idx_user_credentials_instance ON user_provider_credentials(provider_instance_name);
CREATE INDEX idx_user_credentials_expires ON user_provider_credentials(expires_at) WHERE expires_at IS NOT NULL;

CREATE TRIGGER update_user_credentials_updated_at
    BEFORE UPDATE ON user_provider_credentials
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE user_provider_credentials IS '用户媒体源凭证表（AES-256-GCM 加密存储）';
COMMENT ON COLUMN user_provider_credentials.provider IS '提供商类型（bilibili, alist, emby）';
COMMENT ON COLUMN user_provider_credentials.server_id IS '服务器标识（必需），Bilibili 使用固定值 "bilibili"（每个用户只能绑定一个账号），Alist/Emby 使用 MD5(host)';
COMMENT ON COLUMN user_provider_credentials.provider_instance_name IS '关联的后端实例名称（可选，用于指定解析后端）';
COMMENT ON COLUMN user_provider_credentials.credential_data IS '凭证数据（BYTEA，AES-256-GCM 加密的 JSONB）';
COMMENT ON COLUMN user_provider_credentials.expires_at IS '凭证过期时间（可选，用于 token/cookie 等会过期的凭证）';
COMMENT ON CONSTRAINT valid_server_id ON user_provider_credentials IS 'server_id 不能为空或纯空格';
COMMENT ON CONSTRAINT unique_user_provider_server ON user_provider_credentials IS '用户在同一提供商的同一服务器上只能有一个凭证（Bilibili 每用户唯一，Alist/Emby 可多个）';
```

**credential_data 结构示例**：

```json
// Bilibili 凭证
{
  "cookies": {
    "SESSDATA": "xxx",
    "bili_jct": "yyy",
    "DedeUserID": "123"
  }
}

// Alist 凭证
{
  "host": "https://alist.example.com",
  "username": "alice",
  "password": "hashed_password"  // 已经哈希过
}

// Emby 凭证
{
  "host": "https://emby.example.com",
  "api_key": "abc123456",
  "emby_user_id": "user-uuid"
}
```

**server_id 生成规则**：

```rust
// Bilibili: 使用固定常量（确保每个用户只能绑定一个账号）
const BILIBILI_SERVER_ID: &str = "bilibili";
let server_id = BILIBILI_SERVER_ID;

// Alist: MD5(host)
let server_id = UserProviderCredential::generate_server_id("https://alist.example.com");

// Emby: MD5(host)
let server_id = UserProviderCredential::generate_server_id("https://emby.example.com");
```

**使用示例**：

```sql
-- 用户添加 Bilibili 凭证（使用固定常量 "bilibili"，每个用户只能绑定一个账号）
INSERT INTO user_provider_credentials (user_id, provider, server_id, provider_instance_name, credential_data, expires_at)
VALUES (
  'user-uuid',
  'bilibili',
  'bilibili',  -- 固定常量，确保每个用户只能有一个 Bilibili 账号
  NULL,        -- 不指定后端，系统自动选择
  '{"cookies": {"SESSDATA": "xxx", "bili_jct": "yyy", "DedeUserID": "123"}}'::jsonb,
  NOW() + INTERVAL '7 days'  -- 7 天后过期
);

-- 尝试为同一用户添加第二个 Bilibili 账号会失败（违反唯一约束）
-- ERROR: duplicate key value violates unique constraint "unique_user_provider_server"

-- 用户添加 Alist 服务器凭证（指定使用北京节点，永不过期）
INSERT INTO user_provider_credentials (user_id, provider, server_id, provider_instance_name, credential_data, expires_at)
VALUES (
  'user-uuid',
  'alist',
  'abc123def456',  -- MD5('https://alist.example.com')
  'beijing-node',  -- 指定使用北京节点
  '{"host": "https://alist.example.com", "username": "alice", "password": "hashed"}'::jsonb,
  NULL  -- 永不过期
);

-- 用户可以添加多个 Alist 服务器（不同的 server_id）
INSERT INTO user_provider_credentials (user_id, provider, server_id, provider_instance_name, credential_data, expires_at)
VALUES (
  'user-uuid',
  'alist',
  'def456abc789',  -- MD5('https://alist2.example.com') - 不同的 host
  NULL,
  '{"host": "https://alist2.example.com", "username": "bob", "password": "hashed2"}'::jsonb,
  NULL
);

-- 用户添加 Emby 服务器凭证（不指定后端，30 天后过期）
INSERT INTO user_provider_credentials (user_id, provider, server_id, provider_instance_name, credential_data, expires_at)
VALUES (
  'user-uuid',
  'emby',
  'xyz789abc123',  -- MD5('https://emby.example.com')
  NULL,            -- 系统自动选择后端
  '{"host": "https://emby.example.com", "api_key": "abc123", "emby_user_id": "uuid"}'::jsonb,
  NOW() + INTERVAL '30 days'  -- 30 天后过期
);

-- 查询用户的 Bilibili 凭证
SELECT * FROM user_provider_credentials
WHERE user_id = 'user-uuid' AND provider = 'bilibili' AND server_id = 'bilibili';

-- 查询用户的特定 Alist 服务器凭证
SELECT * FROM user_provider_credentials
WHERE user_id = 'user-uuid' AND provider = 'alist' AND server_id = 'abc123def456';

-- 查询用户的所有 Alist 服务器
SELECT * FROM user_provider_credentials
WHERE user_id = 'user-uuid' AND provider = 'alist';

-- 查询用户在特定后端实例上的凭证
SELECT * FROM user_provider_credentials
WHERE user_id = 'user-uuid' AND provider_instance_name = 'beijing-node';

-- 查询所有已过期的凭证（用于清理）
SELECT * FROM user_provider_credentials
WHERE expires_at IS NOT NULL AND expires_at <= NOW();

-- 查询用户的有效凭证（未过期）
SELECT * FROM user_provider_credentials
WHERE user_id = 'user-uuid'
  AND (expires_at IS NULL OR expires_at > NOW());
```

**Rust 数据模型**：

```rust
// models/user_credential.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Provider Instance (gRPC后端配置)
#[derive(Debug, Clone, Queryable, Identifiable)]
#[diesel(primary_key(name))]
pub struct ProviderInstance {
    pub name: String,                // 实例名称（主键）
    pub endpoint: String,
    pub comment: Option<String>,
    pub jwt_secret: Option<String>,  // 加密存储
    pub custom_ca: Option<String>,   // 加密存储
    pub timeout: String,
    pub tls: bool,
    pub insecure_tls: bool,          // 跳过TLS证书验证（不安全）
    pub providers: Vec<String>,      // 支持的提供商列表
    pub enabled: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// 用户 Provider 凭证
#[derive(Debug, Clone, Queryable, Identifiable)]
pub struct UserProviderCredential {
    pub id: Uuid,
    pub user_id: Uuid,
    pub provider: String,
    pub server_id: String,                       // 服务器标识（必需）
    pub provider_instance_name: Option<String>,  // 关联的后端实例名称
    pub credential_data: Vec<u8>,                // BYTEA，AES-256-GCM 加密的 JSONB
    pub expires_at: Option<DateTime<Utc>>,       // 凭证过期时间（可选）
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Provider 凭证数据（枚举）
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "provider", rename_all = "snake_case")]
pub enum ProviderCredential {
    Bilibili {
        cookies: HashMap<String, String>,
    },
    Alist {
        host: String,
        username: String,
        password: String,  // 已哈希
    },
    Emby {
        host: String,
        api_key: String,
        emby_user_id: String,
    },
}

impl UserProviderCredential {
    /// Bilibili 的固定 server_id（确保每个用户只能绑定一个账号）
    pub const BILIBILI_SERVER_ID: &'static str = "bilibili";

    /// 解密并获取凭证数据
    ///
    /// # 参数
    /// - `encryption_key`: AES-256-GCM 加密密钥（32 bytes）
    pub fn get_credential(&self, encryption_key: &[u8]) -> Result<ProviderCredential> {
        // 1. 解密 BYTEA
        let decrypted = decrypt_aes256gcm(&self.credential_data, encryption_key)?;

        // 2. 反序列化 JSONB
        serde_json::from_slice(&decrypted)
            .map_err(|e| Error::InvalidCredential(e.to_string()))
    }

    /// 加密并存储凭证数据（用于创建/更新凭证）
    ///
    /// # 参数
    /// - `credential`: Provider 凭证数据
    /// - `encryption_key`: AES-256-GCM 加密密钥（32 bytes）
    pub fn encrypt_credential(
        credential: &ProviderCredential,
        encryption_key: &[u8],
    ) -> Result<Vec<u8>> {
        // 1. 序列化为 JSON
        let json = serde_json::to_vec(credential)?;

        // 2. 加密
        let encrypted = encrypt_aes256gcm(&json, encryption_key)?;

        Ok(encrypted)
    }

    /// 生成 ServerID（用于 Alist/Emby）
    pub fn generate_server_id(host: &str) -> String {
        use md5::{Md5, Digest};
        let mut hasher = Md5::new();
        hasher.update(host.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// 检查凭证是否已过期
    pub fn is_expired(&self) -> bool {
        if let Some(expires_at) = self.expires_at {
            expires_at <= Utc::now()
        } else {
            false  // 没有设置过期时间，视为永不过期
        }
    }

    /// 检查凭证是否有效（未过期）
    pub fn is_valid(&self) -> bool {
        !self.is_expired()
    }

    /// 获取关联的 Provider Instance
    pub async fn get_provider_instance(&self) -> Result<Option<ProviderInstance>> {
        if let Some(ref name) = self.provider_instance_name {
            provider_instances::table
                .find(name)
                .first::<ProviderInstance>(&mut get_conn())
                .optional()
                .map_err(Into::into)
        } else {
            Ok(None)
        }
    }

    /// 获取用户的 Bilibili 凭证（仅返回未过期的）
    pub async fn get_bilibili(user_id: Uuid) -> Result<Option<Self>> {
        let cred = user_provider_credentials::table
            .filter(user_provider_credentials::user_id.eq(user_id))
            .filter(user_provider_credentials::provider.eq("bilibili"))
            .filter(user_provider_credentials::server_id.eq(Self::BILIBILI_SERVER_ID))
            .first::<Self>(&mut get_conn())
            .optional()?;

        // 过滤已过期的凭证
        Ok(cred.filter(|c| c.is_valid()))
    }

    /// 获取用户在特定 Alist 服务器的凭证（仅返回未过期的）
    pub async fn get_alist(user_id: Uuid, server_id: &str) -> Result<Option<Self>> {
        let cred = user_provider_credentials::table
            .filter(user_provider_credentials::user_id.eq(user_id))
            .filter(user_provider_credentials::provider.eq("alist"))
            .filter(user_provider_credentials::server_id.eq(server_id))
            .first::<Self>(&mut get_conn())
            .optional()?;

        // 过滤已过期的凭证
        Ok(cred.filter(|c| c.is_valid()))
    }

    /// 获取用户的所有 Alist 服务器（仅返回未过期的）
    pub async fn list_alist_servers(user_id: Uuid) -> Result<Vec<Self>> {
        let creds = user_provider_credentials::table
            .filter(user_provider_credentials::user_id.eq(user_id))
            .filter(user_provider_credentials::provider.eq("alist"))
            .load::<Self>(&mut get_conn())?;

        // 过滤已过期的凭证
        Ok(creds.into_iter().filter(|c| c.is_valid()).collect())
    }

    /// 查找所有已过期的凭证（用于清理任务）
    pub async fn find_expired() -> Result<Vec<Self>> {
        user_provider_credentials::table
            .filter(user_provider_credentials::expires_at.is_not_null())
            .filter(user_provider_credentials::expires_at.le(Utc::now()))
            .load::<Self>(&mut get_conn())
            .map_err(Into::into)
    }
}

// ==================== 加密/解密辅助函数 ====================

use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};
use rand::RngCore;

/// AES-256-GCM 加密
///
/// # 参数
/// - `data`: 待加密的原始数据
/// - `key`: 256-bit (32 bytes) 加密密钥
///
/// # 返回
/// 加密后的数据格式：[12-byte nonce][encrypted data][16-byte tag]
fn encrypt_aes256gcm(data: &[u8], key: &[u8]) -> Result<Vec<u8>> {
    // 验证密钥长度
    if key.len() != 32 {
        return Err(Error::InvalidEncryptionKey("key must be 32 bytes"));
    }

    // 创建加密器
    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| Error::EncryptionError(e.to_string()))?;

    // 生成随机 nonce (12 bytes)
    let mut nonce_bytes = [0u8; 12];
    OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);

    // 加密数据
    let ciphertext = cipher
        .encrypt(nonce, data)
        .map_err(|e| Error::EncryptionError(e.to_string()))?;

    // 组合 nonce + ciphertext（ciphertext 已包含 authentication tag）
    let mut result = Vec::with_capacity(12 + ciphertext.len());
    result.extend_from_slice(&nonce_bytes);
    result.extend_from_slice(&ciphertext);

    Ok(result)
}

/// AES-256-GCM 解密
///
/// # 参数
/// - `encrypted_data`: 加密后的数据（[nonce][ciphertext+tag]）
/// - `key`: 256-bit (32 bytes) 加密密钥
fn decrypt_aes256gcm(encrypted_data: &[u8], key: &[u8]) -> Result<Vec<u8>> {
    // 验证密钥长度
    if key.len() != 32 {
        return Err(Error::InvalidEncryptionKey("key must be 32 bytes"));
    }

    // 验证数据长度（至少 12 bytes nonce + 16 bytes tag）
    if encrypted_data.len() < 28 {
        return Err(Error::DecryptionError("invalid encrypted data length"));
    }

    // 创建解密器
    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| Error::DecryptionError(e.to_string()))?;

    // 提取 nonce 和 ciphertext
    let (nonce_bytes, ciphertext) = encrypted_data.split_at(12);
    let nonce = Nonce::from_slice(nonce_bytes);

    // 解密数据
    let plaintext = cipher
        .decrypt(nonce, ciphertext)
        .map_err(|e| Error::DecryptionError(e.to_string()))?;

    Ok(plaintext)
}

// ==================== 实现示例 ====================

impl ProviderInstance {
    /// 查找支持指定 Provider 的所有实例
    pub async fn find_by_provider(provider: &str) -> Result<Vec<Self>> {
        provider_instances::table
            .filter(provider_instances::enabled.eq(true))
            .filter(sql::<Bool>(&format!("'{}' = ANY(providers)", provider)))
            .load::<Self>(&mut get_conn())
            .map_err(Into::into)
    }

    /// 根据名称查找实例
    pub async fn find_by_name(name: &str) -> Result<Option<Self>> {
        provider_instances::table
            .find(name)
            .first::<Self>(&mut get_conn())
            .optional()
            .map_err(Into::into)
    }
}
```

#### 2.4.2.3 媒体文件表 (medias)

存储媒体文件（视频、直播），类似文件系统的文件。

**设计理念**：

- 媒体文件属于某个播放列表（目录）
- **三阶段设计**：
  1. **解析输入**：用户调用 parse 端点（HTTP/gRPC），Provider 返回 ParseResult（多种选项）供用户选择
  2. **添加媒体**：客户端构建 source_config → 调用 add_media API → validate_source_config() 校验 → 存入数据库
  3. **播放媒体**：调用 `generate_playback(source_config)` 动态生成播放信息
- **数据库只存储持久化配置**（`source_config`），不存储播放信息
- **播放信息智能缓存**：根据 `cache_key()` 缓存到 Redis，支持过期时间（解决URL过期问题）
- 支持**用户级别的凭证**（不同用户可能有不同的凭证和权限）
- 同一目录下不能有同名文件（唯一索引）
- 支持手动排序（position 字段）
- 完全禁止 name 中包含 `/` 字符

```sql
-- migrations/005_create_medias.sql
-- 注意：source_provider 枚举类型已在 004_create_playlists.sql 中定义

CREATE TABLE medias (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- ========== 所属目录 ==========
    playlist_id UUID NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,

    -- ========== 基本信息 ==========
    room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    creator_id UUID NOT NULL REFERENCES users(id),

    -- 文件名
    name VARCHAR(255) NOT NULL,

    -- 排序位置（支持手动调整播放顺序）
    position INT NOT NULL DEFAULT 0,

    -- ========== 视频源类型 ==========
    -- 注意：媒体类型（video/live）由 source_provider 和提供者决定
    --      - rtmp → live（直播）
    --      - 其他 → video（点播）
    source_provider source_provider NOT NULL DEFAULT 'direct_url',

    -- ========== 视频源配置（持久化存储） ==========
    source_config JSONB NOT NULL,   -- 媒体特定配置（无敏感信息）
                                      -- 不同 Provider 的配置结构：
                                      -- - Bilibili: {"bvid": "BV1xx", "cid": 123, "quality": 80, "share": true}
                                      -- - Alist: {"path": "/{server_id}/movies/example.mp4", "password": ""}
                                      -- - Emby: {"path": "/{server_id}/{item_id}", "transcode": false}
                                      -- - Direct URL: {"headers": {...}, "proxy": false}
                                      -- - RTMP: {"stream_key": "live123"}
                                      --
                                      -- share 字段（可选）：是否共享缓存，仅 Bilibili 支持
                                      -- path 格式（Alist/Emby）：/{server_id}/actual/path
                                      --   其中 server_id = MD5(host)
                                      -- 注意：不包含敏感凭证（token、cookie等），这些存储在 user_provider_credentials 表中

    provider_instance_name VARCHAR(64),  -- 推荐的后端实例（可选，仅作为提示传递给 provider）

    -- 时间戳
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束：同一目录下不能有同名文件
    CONSTRAINT unique_media_name UNIQUE (playlist_id, name),

    -- 约束：文件名验证
    CONSTRAINT valid_name CHECK (
        length(trim(name)) > 0       -- 不能为空或只有空格
        AND length(name) <= 255
        AND name NOT LIKE '%/%'      -- 禁止包含 / 字符
    ),

    -- 外键约束
    CONSTRAINT fk_provider_instance FOREIGN KEY (provider_instance_name) REFERENCES provider_instances(name) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_medias_playlist ON medias(playlist_id, position);
CREATE INDEX idx_medias_room ON medias(room_id);
CREATE INDEX idx_medias_creator ON medias(creator_id);
CREATE INDEX idx_medias_source_provider ON medias(source_provider);
CREATE INDEX idx_medias_source_config ON medias USING gin(source_config);
CREATE INDEX idx_medias_provider_instance ON medias(provider_instance_name) WHERE provider_instance_name IS NOT NULL;
CREATE INDEX idx_medias_created_at ON medias(created_at DESC);

CREATE TRIGGER update_medias_updated_at
    BEFORE UPDATE ON medias
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE medias IS '媒体文件表（两阶段设计：存储source_config，播放时动态生成播放信息）';
COMMENT ON COLUMN medias.playlist_id IS '所属播放列表（目录）';
COMMENT ON COLUMN medias.name IS '文件名（禁止 / 字符）';
COMMENT ON COLUMN medias.position IS '在播放列表中的排序位置（支持手动调整播放顺序）';
COMMENT ON COLUMN medias.source_provider IS '视频源类型（决定媒体类型：rtmp=直播，其他=点播视频）';
COMMENT ON COLUMN medias.source_config IS 'Provider配置（JSONB），由 parse HTTP 端点生成（用户添加视频时），用于 generate_playback() trait 方法动态生成播放信息（播放时），不包含敏感凭证';
COMMENT ON COLUMN medias.provider_instance_name IS '推荐的后端实例名称（可选），仅作为提示传递给 provider，具体是否使用由 provider 决定';
COMMENT ON CONSTRAINT unique_media_name ON medias IS '同一目录下不能有同名文件';
COMMENT ON CONSTRAINT valid_name ON medias IS '文件名验证：不能为空/纯空格，长度1-255，禁止包含 / 字符';
```

#### 2.4.2.1 三阶段工作流与数据流向

**设计（三阶段 + 智能缓存）**：

```
[阶段1：解析输入]
用户输入 → parse 端点（HTTP/gRPC）→ ParseResult（多种选项）→ 展示给用户

[阶段2：添加媒体]
用户选择 + 客户端构建 source_config → POST /api/media/add → validate_source_config() 校验 → 存入数据库（medias.source_config）

[阶段3：播放媒体]
数据库读取source_config → generate_playback() → PlaybackResult → 缓存到Redis（根据cache_key）→ 返回客户端
```

**智能缓存策略**：

- ✅ **根据 cache_key 缓存**：Provider 自定义缓存键（如 `{provider}:{bvid}:{quality}`）
- ✅ **支持过期时间**：Provider 设置合理的 TTL（如 Bilibili 链接 1小时，Alist 签名 24小时）
- ✅ **自动刷新**：客户端检测链接即将过期时主动刷新
- ✅ **灵活性**：Provider 可根据 `source_config.prefer_proxy` 等参数动态调整策略

**缓存实现**：

```rust
// 05-缓存设计.md
pub async fn get_or_generate_playback(
    source_config: &Value,
    provider: &dyn MediaProvider,
) -> Result<PlaybackResult> {
    let cache_key = provider.cache_key(ctx, source_config);

    // 1. 尝试从 Redis 读取
    if let Some(cached) = redis.get(&cache_key).await? {
        return Ok(cached);
    }

    // 2. 缓存未命中，调用 provider 生成
    let result = provider.generate_playback(ctx, source_config).await?;

    // 3. 缓存到 Redis（TTL 由 provider 决定）
    let ttl = provider.cache_ttl(&result);
    redis.set_ex(&cache_key, &result, ttl).await?;

    Ok(result)
}
```

**`source_config` JSONB 结构示例**（不含敏感凭证）：

```json
// Direct URL
{
  "url": "https://cdn.com/video.mp4",
  "headers": {
    "Referer": "https://example.com"
  }
}

// Alist（凭证存储在 user_provider_credentials 表）
{
  "server_id": "abc123def456",  // MD5(host)
  "path": "/电影/example.mp4",
  "password": ""
}

// Bilibili（凭证存储在 user_provider_credentials 表）
{
  "bvid": "BV1xx4y1x7xx",
  "cid": 123456,
  "quality": 80
}

// Emby（凭证存储在 user_provider_credentials 表）
{
  "server_id": "xyz789abc123",  // MD5(host)
  "item_id": "item-uuid-123",
  "transcode": false
}

// RTMP
{
  "stream_key": "live_stream_123"
}
```

**source_config 设计原则**：

- 只存储**必要的持久化配置**（如bvid、cid、path等）
- 不存储**易变的播放信息**（URL、过期时间等）
- 不存储**敏感凭证**（token、cookie等，存user_provider_credentials表）
- 用于generate_playback()动态生成完整的播放信息

**用户凭证结构**（加密存储在 `user_provider_credentials.credential_data`）：

```json
// Alist
{
  "token": "xxx",
  "password": "yyy"
}

// Bilibili
{
  "cookie": "SESSDATA=xxx; bili_jct=yyy",
  "access_token": "zzz"
}

// Emby
{
  "api_key": "xxx",
  "user_id": "yyy"
}
```

**Redis 缓存的 `parsed_data` 结构**：

```json
{
  "playback_url": "https://cdn.com/video.mp4",  // 必填
  "duration": 3600,                              // 可选
  "thumbnail_url": "https://cdn.com/thumb.jpg",  // 可选
  "description": "视频描述",                      // 可选
  "is_live": false,                              // 可选
  "subtitles": [...],                            // 可选
  "headers": {"Referer": "..."},                 // 可选
  "proxy": false,                                // 可选
  "parsed_at": "2026-01-30T12:00:00Z",          // 解析时间
  "expires_at": "2026-01-30T13:00:00Z"          // 过期时间
}
```

**注意**：

- **敏感凭证**（token、cookie）存储在 `user_provider_credentials` 表，AES-256-GCM 加密保护
- **source_config** 只存储非敏感配置（路径、BV号、share等）
- **parsed_data** 存储在 Redis 缓存中，不存数据库
- **share 字段**（可选）：仅部分 provider 支持（如 bilibili），控制缓存策略

##### 2.4.2.3 Provider 缓存键实现

各个 provider 通过实现 `cache_key()` 方法来自定义缓存策略：

**1. BilibiliProvider（支持 share）**：

```rust
impl MediaProvider for BilibiliProvider {
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // 读取 source_config 中的 share 字段
        let is_shared = media.source_config
            .get("share")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if is_shared {
            // 共享模式：所有用户共享缓存（使用创建者的凭证）
            format!("media:parsed:{}:shared", media.id)
        } else if let Some(requester) = ctx.requester {
            // 非共享模式：每个用户使用自己的凭证，独立缓存
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供 requester 时使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            // 都没有时，使用共享缓存
            format!("media:parsed:{}:shared", media.id)
        }
    }
}
```

**2. AlistProvider / EmbyProvider（不支持 share）**：

```rust
impl MediaProvider for AlistProvider {
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // Alist 不支持 share，始终使用用户级缓存
        // 因为每个用户有不同的 token 和权限

        // 优先使用请求者的缓存
        if let Some(requester) = ctx.requester {
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供请求者时，使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            // 都没有时，使用特殊的无用户缓存键
            format!("media:parsed:{}:no-user", media.id)
        }
    }
}

impl MediaProvider for EmbyProvider {
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // Emby 同样不支持 share，始终使用用户级缓存

        // 优先使用请求者的缓存
        if let Some(requester) = ctx.requester {
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供请求者时，使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            format!("media:parsed:{}:no-user", media.id)
        }
    }
}
```

**3. DirectUrlProvider（可共享）**：

```rust
impl MediaProvider for DirectUrlProvider {
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // 直接URL通常不需要凭证，可以共享缓存
        format!("media:parsed:{}:shared", media.id)
    }
}
```

**4. RtmpProvider（可共享）**：

```rust
impl MediaProvider for RtmpProvider {
    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // RTMP 直播流通常不需要用户凭证，可以共享缓存
        format!("media:parsed:{}:shared", media.id)
    }
}
```

**缓存策略总结**：

| Provider | 支持 share | 默认策略 | 备注 |
|----------|-----------|---------|------|
| **bilibili** | ✅ 是 | 根据 `source_config.share` 决定 | 灵活配置 |
| **alist** | ❌ 否 | 用户级缓存 | 每个用户有独立 token |
| **emby** | ❌ 否 | 用户级缓存 | 每个用户有独立 api_key |
| **direct_url** | ❌ 否（但默认共享） | 共享缓存 | 公共URL，无需凭证 |
| **rtmp** | ❌ 否（但默认共享） | 共享缓存 | 直播流，无需凭证 |

**使用场景**（数据库+缓存+多租户）：

所有视频源类型都走 MediaProvider 解析流程，支持灵活的缓存策略：

### 场景 1: Direct URL（默认非共享）

**数据库**：

```json
{
  "source_provider": "direct_url",
  "source_config": {
    "url": "https://cdn.com/video.mp4"
  }
  // direct_url 不支持 share 字段，始终非共享
}
```

**Redis 缓存**（key: `video:parsed:{item_id}:user:{user_id}`）：

```json
{
  "playback_url": "https://cdn.com/video.mp4",
  "is_live": false,
  "proxy": false,
  "parsed_at": "2026-01-30T12:00:00Z",
  "expires_at": "2026-01-31T12:00:00Z"
}
```

**解析行为**：每个用户独立缓存。Redis TTL 根据 `expires_at` 自动计算。

---

### 场景 2: Alist 视频（始终非共享）

**数据库**：

```json
{
  "source_provider": "alist",
  "source_config": {
    "path": "/电影/example.mp4",
    "server": "https://alist.example.com"
  }
  // alist 不支持 share 字段，始终非共享
}
```

**用户凭证**（`user_provider_credentials` 表，AES-256-GCM 加密存储）：

```json
{
  "user_id": "user_123",
  "source_provider": "alist",
  "credentials": "encrypted('{\"token\": \"xxx\", \"password\": \"yyy\"}')"
}
```

**Redis 缓存**（key: `video:parsed:{item_id}:user:user_123`）：

```json
{
  "playback_url": "https://alist.example.com/d/电影/example.mp4?sign=abc123",
  "thumbnail_url": "https://alist.example.com/thumb.jpg",
  "is_live": false,
  "proxy": false,
  "parsed_at": "2026-01-30T12:00:00Z",
  "expires_at": "2026-01-30T13:00:00Z"
}
```

**解析行为**：每个用户使用自己的 Alist token，单独解析和缓存。Redis TTL 根据 `expires_at` 自动计算。

---

### 场景 3: Bilibili 视频（share=true，共享房主会员）

**数据库**：

```json
{
  "source_provider": "bilibili",
  "source_config": {
    "bvid": "BV1xx4y1x7xx",
    "quality": "1080p",
    "share": true  // 共享缓存模式
  }
}
```

**创建者凭证**（`user_provider_credentials` 表，AES-256-GCM 加密存储）：

```json
{
  "user_id": "creator_id",
  "source_provider": "bilibili",
  "credentials": "encrypted('{\"cookie\": \"SESSDATA=xxx\"}')"
}
```

**Redis 缓存**（key: `video:parsed:{item_id}:shared`）：

```json
{
  "playback_url": "https://upos-xxx.bilivideo.com/...",
  "duration": 3600,
  "thumbnail_url": "https://i0.hdslb.com/...",
  "subtitles": [...],
  "headers": {"Referer": "https://www.bilibili.com"},
  "is_live": false,
  "proxy": true,
  "parsed_at": "2026-01-30T12:00:00Z",
  "expires_at": "2026-01-30T14:00:00Z"
}
```

**解析行为**：使用创建者的 B站会员解析一次，所有房间成员共享缓存。Redis TTL 根据 `expires_at` 自动计算。

---

### 场景 4: Bilibili 视频（share=false/未设置，每用户独立会员）

**数据库**：

```json
{
  "source_provider": "bilibili",
  "source_config": {
    "bvid": "BV1xx4y1x7xx",
    "quality": "1080p"
    // share 未设置，默认为 false（非共享）
  }
}
```

**解析行为**：每个用户使用自己的 B站会员，可能解析出不同画质（取决于会员等级）。缓存 TTL 由提供者返回的 `expires_at` 决定。

#### 2.4.3 辅助视图

##### 2.4.3.1 播放列表完整路径视图 (playlist_paths_view)

用于生成完整的目录路径（如 `/aaa/bbb/ccc`）：

```sql
-- migrations/006_create_playlist_paths_view.sql
CREATE OR REPLACE VIEW playlist_paths_view AS
WITH RECURSIVE playlist_tree AS (
    -- 根目录（name 为空字符串，path 显示为 /）
    SELECT
        id,
        room_id,
        name,
        parent_id,
        position,
        '/' AS path,  -- 根目录显示为 /（实际 name 为空字符串）
        0 AS depth
    FROM playlists
    WHERE parent_id IS NULL

    UNION ALL

    -- 递归：子目录
    SELECT
        p.id,
        p.room_id,
        p.name,
        p.parent_id,
        p.position,
        CASE
            WHEN pt.path = '/' THEN '/' || p.name  -- 根目录的子目录: /child
            ELSE pt.path || '/' || p.name  -- 其他子目录: /parent/child
        END AS path,
        pt.depth + 1 AS depth
    FROM playlists p
    INNER JOIN playlist_tree pt ON p.parent_id = pt.id
)
SELECT * FROM playlist_tree;

COMMENT ON VIEW playlist_paths_view IS '播放列表完整路径视图（递归生成 /aaa/bbb/ccc 格式路径）';
```

**使用示例**：

```sql
-- 查询某个目录的完整路径
SELECT path FROM playlist_paths_view WHERE id = 'playlist-uuid';
-- 结果: /电影/动作片/漫威

-- 查询某个房间的所有目录树（按路径排序）
SELECT id, path, depth
FROM playlist_paths_view
WHERE room_id = 'room-uuid'
ORDER BY path;
```

#### 2.4.4 Rust 数据模型

```rust
// model/playlist.rs

/// 播放列表（目录）
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct Playlist {
    pub id: Uuid,
    pub room_id: Uuid,
    pub creator_id: Uuid,

    /// 目录名称
    pub name: String,

    /// 树形结构
    pub parent_id: Option<Uuid>,
    pub position: i32,

    /// 动态目录支持
    pub source_provider: Option<SourceProvider>,
    pub source_config: Option<SourceConfig>,
    pub source_provider_backend: Option<String>,

    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Playlist {
    /// 判断是否是根目录
    pub fn is_root(&self) -> bool {
        self.parent_id.is_none()
    }

    /// 判断是否是动态目录
    ///
    /// 动态目录由第三方供应商（Alist/Emby/Bilibili）提供内容，
    /// 内容实时从供应商获取，不持久化到数据库
    pub fn is_dynamic(&self) -> bool {
        self.source_provider.is_some()
    }

    /// 判断是否可以添加子项
    ///
    /// - 静态目录：可以手动添加子目录和媒体文件
    /// - 动态目录：内容由供应商提供，不能手动添加子项
    pub fn can_add_children(&self) -> bool {
        !self.is_dynamic()
    }

    /// 获取基础路径（动态目录）
    ///
    /// 从 source_config 中提取基础路径，用于拼接 relative_path
    pub fn base_path(&self) -> Option<String> {
        self.source_config.as_ref()?.get_base_path()
    }
}

/// 媒体文件（视频/直播）
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct Media {
    pub id: Uuid,

    /// 所属播放列表（目录）
    pub playlist_id: Uuid,

    /// 基本信息
    pub room_id: Uuid,
    pub creator_id: Uuid,

    /// 文件名
    pub name: String,

    /// 排序位置
    pub position: i32,

    /// 视频源配置
    pub source_provider: SourceProvider,
    pub source_config: SourceConfig,
    pub source_provider_backend: Option<String>,

    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Media {
    /// 获取媒体类型（从 source_provider 推导）
    ///
    /// 注意：实际的媒体类型应该由提供者返回（在 ParseResult.is_live 字段中）
    /// 此方法仅作为快速判断，某些情况下可能不准确（如 direct_url 可能是直播或点播）
    pub fn infer_media_type(&self) -> MediaType {
        self.source_provider.default_media_type()
    }

    /// 检查是否为共享缓存模式
    ///
    /// 从 source_config 中读取 share 字段（仅部分 provider 支持）
    pub fn is_shared_cache(&self) -> bool {
        self.source_config.get_share().unwrap_or(false)
    }
}

/// 媒体类型（由提供者返回）
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum MediaType {
    Video,  // 点播视频
    Live,   // 直播流
}

/// 视频源类型
#[derive(Debug, Clone, Copy, Serialize, Deserialize, sqlx::Type, PartialEq, Eq)]
#[sqlx(type_name = "source_provider", rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum SourceProvider {
    DirectUrl,  // 直接URL（可能是点播或直播）
    Bilibili,   // B站视频（点播）
    Alist,      // Alist文件（点播）
    Emby,       // Emby媒体服务器（点播）
    Rtmp,       // RTMP直播流（直播）
}

impl SourceProvider {
    /// 返回该视频源类型的默认媒体类型
    ///
    /// 注意：这只是默认推断，实际媒体类型应该由提供者在 `ParseResult.is_live` 中返回
    /// 例如：direct_url 默认返回 Video，但实际可能是 Live
    pub fn default_media_type(&self) -> MediaType {
        match self {
            Self::Rtmp => MediaType::Live,  // RTMP 一定是直播
            _ => MediaType::Video,          // 其他默认为点播
        }
    }

    /// 检查该 provider 是否支持 share 字段
    pub fn supports_share(&self) -> bool {
        matches!(self, Self::Bilibili)
    }
}

/// 视频源配置（不含凭证）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceConfig {
    /// 通用字段（各视频源自定义）
    #[serde(flatten)]
    pub fields: HashMap<String, serde_json::Value>,
}

impl SourceConfig {
    /// 创建Direct URL配置
    pub fn direct_url(url: impl Into<String>) -> Self {
        Self {
            fields: HashMap::from([
                ("url".to_string(), json!(url.into())),
            ]),
        }
    }

    /// 创建Alist配置（不含token）
    pub fn alist(path: impl Into<String>, server: impl Into<String>) -> Self {
        Self {
            fields: HashMap::from([
                ("path".to_string(), json!(path.into())),
                ("server".to_string(), json!(server.into())),
            ]),
        }
    }

    /// 创建Bilibili配置（支持 share 字段）
    pub fn bilibili(bvid: impl Into<String>, quality: impl Into<String>, share: bool) -> Self {
        Self {
            fields: HashMap::from([
                ("bvid".to_string(), json!(bvid.into())),
                ("quality".to_string(), json!(quality.into())),
                ("share".to_string(), json!(share)),
            ]),
        }
    }

    /// 获取字段值
    pub fn get(&self, key: &str) -> Option<&serde_json::Value> {
        self.fields.get(key)
    }

    /// 获取 share 字段（是否共享缓存）
    ///
    /// 仅部分 provider 支持此字段（如 bilibili）
    /// 返回 None 表示该 provider 不支持或未设置
    pub fn get_share(&self) -> Option<bool> {
        self.fields.get("share")?.as_bool()
    }

    /// 获取基础路径（用于动态目录导航）
    ///
    /// 从不同 provider 的配置中提取基础路径
    pub fn get_base_path(&self) -> Option<String> {
        // Alist: 使用 path 字段
        if let Some(path) = self.fields.get("path") {
            return path.as_str().map(String::from);
        }
        // Emby: 使用 item_id 字段
        if let Some(item_id) = self.fields.get("item_id") {
            return item_id.as_str().map(String::from);
        }
        None
    }
}

/// 用户凭证（加密存储）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserCredentials {
    /// 通用字段（各视频源自定义）
    #[serde(flatten)]
    pub fields: HashMap<String, serde_json::Value>,
}

impl UserCredentials {
    /// 创建Alist凭证
    pub fn alist(token: impl Into<String>, password: Option<String>) -> Self {
        let mut fields = HashMap::from([
            ("token".to_string(), json!(token.into())),
        ]);
        if let Some(p) = password {
            fields.insert("password".to_string(), json!(p));
        }
        Self { fields }
    }

    /// 创建Bilibili凭证
    pub fn bilibili(cookie: impl Into<String>) -> Self {
        Self {
            fields: HashMap::from([
                ("cookie".to_string(), json!(cookie.into())),
            ]),
        }
    }

    /// 获取字段值
    pub fn get(&self, key: &str) -> Option<&serde_json::Value> {
        self.fields.get(key)
    }
}

/// 解析后的视频数据（提供者返回）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedVideoData {
    /// 实际播放URL（必填）
    pub playback_url: String,

    /// 其他字段（各视频源自定义）
    #[serde(flatten)]
    pub fields: HashMap<String, serde_json::Value>,
}

impl ParsedVideoData {
    /// 获取播放URL
    pub fn playback_url(&self) -> &str {
        &self.playback_url
    }

    /// 获取是否直播
    pub fn is_live(&self) -> bool {
        self.fields.get("is_live")
            .and_then(|v| v.as_bool())
            .unwrap_or(false)
    }

    /// 获取视频时长
    pub fn duration(&self) -> Option<i32> {
        self.fields.get("duration")
            .and_then(|v| v.as_i64())
            .map(|v| v as i32)
    }

    /// 获取是否需要代理
    pub fn proxy(&self) -> bool {
        self.fields.get("proxy")
            .and_then(|v| v.as_bool())
            .unwrap_or(false)
    }
}

/// 完整视频对象（组合）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Movie {
    #[serde(flatten)]
    pub item: PlaylistItem,

    #[serde(flatten)]
    pub metadata: Option<VideoMetadata>,  // ✅ 文件夹时为None
}

impl Movie {
    /// ✅ 类型安全：只有视频才能获取播放URL
    pub fn get_playback_url(&self) -> Result<&str> {
        match self.item.item_type {
            ItemType::Video | ItemType::Live => {
                self.metadata
                    .as_ref()
                    .map(|m| m.get_playback_url())
                    .ok_or(Error::InvalidMovie)
            }
            ItemType::Folder => Err(Error::NotAVideo),
        }
    }

    /// ✅ 类型安全：只有视频才有duration
    pub fn get_duration(&self) -> Option<i32> {
        self.metadata.as_ref()?.duration
    }

    /// 检查是否需要刷新元数据
    pub fn needs_refresh(&self) -> bool {
        self.metadata
            .as_ref()
            .map(|m| m.needs_refresh())
            .unwrap_or(false)
    }

    /// 检查是否是文件夹
    pub fn is_folder(&self) -> bool {
        self.item.item_type == ItemType::Folder
    }
}
```

#### 2.4.5 MediaProvider 接口（支持用户凭证）

> **重要说明**：本节的 MediaProvider 定义已**过时**。
>
> **最终权威定义**请参考：[08-视频内容管理.md § 6.1.2](./08-视频内容管理.md#612-核心接口设计)
>
> **关键架构决策**：
>
> - `parse` **不是 trait 方法**，而是通过 `register_http_routes()` 注册的 **HTTP 端点**
> - `proxy_stream` **不是 trait 方法**，而是通过 `register_http_routes()` 注册的 **HTTP 端点**
> - **核心 trait 方法**：`generate_playback(ctx, source_config) -> PlaybackResult`
> - **可选 trait**：`DynamicFolder::list_directory()` 用于动态播放列表
>
> 本节保留仅供参考数据库字段注释，实际实现请以 06 章为准。

---

**以下内容为历史参考版本，实际实现请以 08-视频内容管理.md 为准**

```rust
// media/provider.rs (历史参考版本)

/// 解析上下文（包含配置和凭证）
#[derive(Debug, Clone)]
pub struct ParseContext {
    /// 视频源配置
    pub config: SourceConfig,

    /// 用户凭证（可选）
    pub credentials: Option<UserCredentials>,

    /// 用户ID（用于日志）
    pub user_id: Option<Uuid>,

    /// 房间ID（用于日志）
    pub room_id: Option<Uuid>,
}

/// 目录项类型
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ItemType {
    /// 视频文件
    Video,
    /// 直播流
    Live,
    /// 文件夹/目录
    Folder,
}

/// 目录项（提供者返回的统一结构）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectoryItem {
    /// 项目唯一标识符（相对于当前源）
    pub id: String,

    /// 项目名称/标题
    pub title: String,

    /// 项目类型
    pub item_type: ItemType,

    /// 视频源配置（用于存储到 video_metadata.source_config）
    pub source_config: SourceConfig,

    /// 缩略图 URL（可选）
    pub thumbnail: Option<String>,

    /// 视频时长（秒，仅视频类型有效）
    pub duration: Option<i32>,

    /// 描述信息（可选）
    pub description: Option<String>,

    /// 子项数量（仅文件夹类型有效）
    pub children_count: Option<i32>,

    /// 额外元数据（各提供者自定义）
    #[serde(flatten)]
    pub metadata: HashMap<String, serde_json::Value>,
}

/// 播放生命周期上下文
#[derive(Debug, Clone)]
pub struct PlaybackContext {
    /// 播放列表项ID
    pub item_id: Uuid,

    /// 用户ID
    pub user_id: Uuid,

    /// 房间ID
    pub room_id: Uuid,

    /// 播放会话ID（用于标识唯一播放会话）
    pub session_id: String,

    /// 视频源配置
    pub source_config: SourceConfig,

    /// 用户凭证（可选）
    pub credentials: Option<UserCredentials>,

    /// 当前播放位置（秒）
    pub position: f64,

    /// 额外元数据（用于传递自定义信息）
    pub metadata: HashMap<String, serde_json::Value>,
}

/// 用户抽象 trait
pub trait UserLike {
    /// 获取用户ID
    fn id(&self) -> Uuid;

    /// 获取用户名（可选，用于日志）
    fn username(&self) -> Option<&str> {
        None
    }

    /// 获取用户凭证（可选）
    fn credentials(&self, provider: &str, backend: Option<&str>) -> Option<UserCredentials> {
        None
    }
}

/// MediaProvider 通用上下文
///
/// 包含执行操作所需的通用上下文信息（用户、房间等）。
/// 特定于媒体的信息（source_config、source_provider）通过方法参数（Media/Playlist）传入。
#[derive(Debug, Clone)]
pub struct ProviderContext<'a> {
    // ========== 房间信息 ==========
    /// 房间ID（可选）
    pub room_id: Option<Uuid>,

    // ========== 用户信息 ==========
    /// 创建者（媒体创建者，用于获取凭证）
    pub creator: Option<&'a dyn UserLike>,

    /// 请求者（当前请求的用户）
    pub requester: Option<&'a dyn UserLike>,

    // ========== Provider 配置 ==========
    /// 推荐的后端实例名称（可选）
    /// 这个字段从 Media/Playlist 的 provider_instance_name 传入
    /// 仅作为提示，provider 可以选择使用或忽略
    pub provider_instance_name: Option<String>,

    // ========== 扩展信息 ==========
    /// 额外元数据（用于扩展，可传递自定义信息）
    pub metadata: HashMap<String, serde_json::Value>,
}

impl<'a> ProviderContext<'a> {
    /// 创建新的 Provider 上下文（最小化构造）
    pub fn new() -> Self {
        Self {
            room_id: None,
            creator: None,
            requester: None,
            provider_instance_name: None,
            metadata: HashMap::new(),
        }
    }

    /// 设置房间ID
    pub fn with_room_id(mut self, room_id: Uuid) -> Self {
        self.room_id = Some(room_id);
        self
    }

    /// 设置创建者
    pub fn with_creator(mut self, creator: &'a dyn UserLike) -> Self {
        self.creator = Some(creator);
        self
    }

    /// 设置请求者
    pub fn with_requester(mut self, requester: &'a dyn UserLike) -> Self {
        self.requester = Some(requester);
        self
    }

    /// 设置推荐的后端实例
    pub fn with_provider_instance_name(mut self, name: Option<String>) -> Self {
        self.provider_instance_name = name;
        self
    }

    /// 添加元数据
    pub fn with_metadata(mut self, key: String, value: serde_json::Value) -> Self {
        self.metadata.insert(key, value);
        self
    }

    /// 获取请求者的凭证
    ///
    /// 仅查找当前请求用户的凭证。
    ///
    /// # 使用场景
    /// - 用户播放自己添加的视频
    /// - 每个用户使用自己的账号访问 Alist/Emby
    ///
    /// # 参数
    /// - provider: 提供商名称（如 "bilibili", "alist", "emby"）
    /// - server_id: 服务器标识（Bilibili 使用 "bilibili"，Alist/Emby 使用 MD5(host)）
    pub async fn get_requester_credential(
        &self,
        provider: &str,
        server_id: &str,
    ) -> Result<Option<UserProviderCredential>> {
        if let Some(requester) = self.requester {
            load_credential(requester.id(), provider, server_id).await
        } else {
            Ok(None)
        }
    }

    /// 获取创建者的凭证
    ///
    /// 仅查找媒体创建者的凭证。
    ///
    /// # 使用场景
    /// - Bilibili 共享模式（share = true），所有用户使用创建者的会员权限
    /// - 视频创建者分享自己有权限访问的内容
    ///
    /// # 参数
    /// - provider: 提供商名称（如 "bilibili", "alist", "emby"）
    /// - server_id: 服务器标识（Bilibili 使用 "bilibili"，Alist/Emby 使用 MD5(host)）
    pub async fn get_creator_credential(
        &self,
        provider: &str,
        server_id: &str,
    ) -> Result<Option<UserProviderCredential>> {
        if let Some(creator) = self.creator {
            load_credential(creator.id(), provider, server_id).await
        } else {
            Ok(None)
        }
    }
}

/// # 凭证获取设计说明
///
/// ## 为什么不提供自动降级的 get_credential() 方法？
///
/// 不同场景需要不同的凭证策略，无法用统一的优先级规则处理：
///
/// ### 场景 1: Bilibili 共享模式
/// ```rust
/// let share = media.source_config.get("share").and_then(|v| v.as_bool()).unwrap_or(false);
/// let credential = if share {
///     // 共享模式：仅使用创建者凭证
///     ctx.get_creator_credential("bilibili", "bilibili").await?
/// } else {
///     // 非共享模式：优先请求者，降级到创建者
///     ctx.get_requester_credential("bilibili", "bilibili").await?
///         .or(ctx.get_creator_credential("bilibili", "bilibili").await?)
/// }.ok_or(Error::CredentialRequired)?;
/// ```
///
/// ### 场景 2: Alist 私有访问
/// ```rust
/// // 每个用户必须使用自己的凭证访问 Alist
/// let credential = ctx.get_requester_credential("alist", &server_id).await?
///     .ok_or(Error::CredentialRequired)?;
/// ```
///
/// ### 场景 3: Emby 灵活策略
/// ```rust
/// // 优先请求者，如果没有则尝试创建者（降级）
/// let credential = ctx.get_requester_credential("emby", &server_id).await?
///     .or(ctx.get_creator_credential("emby", &server_id).await?)
///     .ok_or(Error::CredentialRequired)?;
/// ```
///
/// ## 设计原则
///
/// 1. **明确性**：Provider 必须明确指定使用哪个用户的凭证
/// 2. **灵活性**：支持不同的业务逻辑（共享、私有、降级等）
/// 3. **透明性**：调用代码清晰表达凭证获取策略
/// 4. **类型安全**：编译时保证凭证来源明确

**MediaProvider Trait 定义**：

> 完整定义见：[08-视频内容管理.md § 6.1.2](./08-视频内容管理.md#612-mediaprovider-trait)

#### 2.4.8 动态目录设计

动态目录是 playlists 表的特殊类型，内容由第三方供应商（Alist/Emby）动态提供，不持久化子项到数据库。

##### 1. 核心概念

```rust
// 判断是否为动态目录
pub fn is_dynamic(&self) -> bool {
    self.source_provider.is_some()
}
```

**动态目录特征**：

- ✅ playlists 表中只有 **1 条记录**（目录本身）
- ✅ `source_provider` 不为 NULL（如 'alist', 'emby'）
- ✅ `source_config` 包含基础路径（如 Alist 的 `/movies`，Emby 的 `library-id`）
- ✅ 子项**不持久化**到数据库，每次请求时实时从供应商获取
- ✅ 支持 `relative_path` 导航（见 2.4.9）
- ❌ 不能手动添加子项（`can_add_children() == false`）

##### 2. 创建动态目录

**API 请求**：

```json
POST /api/v1/rooms/{room_id}/playlists

{
  "name": "我的Alist电影",
  "source_provider": "alist",
  "source_config": {
    "fields": {
      "server": "https://alist.example.com",
      "path": "/movies"
    }
  },
  "source_provider_backend": "my-alist-backend",  // 可选
  "parent_id": null  // 根目录
}
```

**数据库记录**（只插入 1 条）：

```sql
INSERT INTO playlists (
    room_id, creator_id, name,
    source_provider, source_config, source_provider_backend
)
VALUES (
    'room-uuid',
    'user-uuid',
    '我的Alist电影',
    'alist',
    '{"fields": {"server": "https://alist.example.com", "path": "/movies"}}',
    'my-alist-backend'
);
```

##### 3. 列出动态目录内容

**API 请求**：

```http
GET /api/v1/playlists/{playlist_id}/items?relative_path=/action&page=1&page_size=20&keyword=spider
```

**服务器处理流程**：

```rust
pub async fn list_playlist_items(
    Path(id): Path<Uuid>,
    Query(params): Query<ListParams>,
) -> Result<Json<PlaylistItemsResponse>> {
    let playlist = db.get_playlist(id).await?;

    if playlist.is_dynamic() {
        // 动态目录：实时调用供应商 API
        let provider = registry.get(playlist.source_provider.unwrap())?;

        // 拼接完整路径：base_path + relative_path
        let base_path = playlist.source_config.get_base_path().unwrap();
        let full_path = join_path(base_path, params.relative_path);

        // 安全检查：防止路径穿越
        if !full_path.starts_with(&base_path) {
            return Err("Invalid relative_path");
        }

        // 调用供应商 API
        let ctx = ParseContext {
            source_config: playlist.source_config.clone(),
            credentials: get_user_credentials(...).await?,
            ...
        };

        let listing = provider.list_directory(
            &ctx,
            params.relative_path,
            params.keyword,
            params.page,
            params.page_size,
        ).await?;

        Ok(Json(PlaylistItemsResponse {
            items: listing.items,
            total: listing.total,
            is_dynamic: true,
            parent_id: id,
        }))
    } else {
        // 静态目录：从数据库查询 medias 表
        let medias = db.list_medias(id, params.page, params.page_size).await?;
        Ok(Json(PlaylistItemsResponse {
            items: medias,
            total: medias.len(),
            is_dynamic: false,
            parent_id: id,
        }))
    }
}
```

##### 4. 动态目录 vs 静态目录

| 特性 | 动态目录 | 静态目录 |
|-----|---------|---------|
| **source_provider** | 非 NULL (alist/emby) | NULL |
| **子项存储** | 不持久化（临时生成） | medias 表（持久化） |
| **内容来源** | 实时从供应商 API 获取 | 数据库查询 |
| **手动添加** | ❌ 不支持 | ✅ 支持 |
| **导航方式** | relative_path 参数 | parent_id 关联 |
| **更新机制** | 自动同步供应商最新状态 | 需要手动更新 |
| **性能** | 依赖供应商 API 响应速度 | 数据库查询速度 |

##### 5. 支持的供应商

| Provider | 支持动态目录 | 备注 |
|---------|------------|------|
| **alist** | ✅ 是 | 列出文件夹，支持搜索 |
| **emby** | ✅ 是 | 列出媒体库，支持搜索 |
| **bilibili** | ❌ 否 | 不支持目录结构 |
| **direct_url** | ❌ 否 | 单个 URL，无目录 |
| **rtmp** | ❌ 否 | 直播流，无目录 |

##### 6. MediaProvider 实现要求

> **注意**：以下定义已简化，仅供理解数据库设计。
>
> **完整权威定义**：[08-视频内容管理.md § 6.1.2](./08-视频内容管理.md#612-核心接口设计)
>
> **关键变化**：
>
> - `list_directory` 应该是单独的 `DynamicFolder` trait（可选）
> - 核心 MediaProvider trait 只需要 `generate_playback()` 方法

```rust
// 注意：list_directory 应该是单独的 DynamicFolder trait
// 详见：08-视频内容管理.md § 6.1.9.2
#[async_trait]
pub trait DynamicFolder: MediaProvider {  // ✅ 正确：单独的可选 trait
    /// 列出目录内容（动态目录必需）
    ///
    /// 返回临时生成的子项列表，不持久化到数据库
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing>;
}

pub struct DirectoryListing {
    pub items: Vec<DirectoryItem>,
    pub total: usize,
    pub has_more: bool,
}

pub struct DirectoryItem {
    pub name: String,
    pub item_type: ItemType,  // Folder | Video | Live
    pub relative_path: String,  // 相对于动态目录基础路径
    pub source_config: SourceConfig,  // 完整配置（用于播放）
}
```

**完整实现见**：[08-视频内容管理.md § 6.1.9.2](./08-视频内容管理.md#6192-dynamicfolder-trait可选能力)

##### 7. 数据流示例

**用户操作流程**：

```
1. 用户创建动态目录
   POST /api/v1/rooms/{room_id}/playlists
   {source_provider: "alist", source_config: {path: "/movies"}}
   ↓
   数据库插入 1 条 playlists 记录

2. 用户打开动态目录
   GET /api/v1/playlists/{id}/items
   ↓
   服务器调用 AlistProvider.list_directory(ctx, None, ...)
   ↓
   返回临时生成的子项列表（不保存到数据库）:
   [
     {name: "action", item_type: "Folder", relative_path: "/action"},
     {name: "comedy", item_type: "Folder", relative_path: "/comedy"},
     {name: "movie1.mp4", item_type: "Video", relative_path: "/movie1.mp4"}
   ]

3. 用户点击 "action" 子目录
   GET /api/v1/playlists/{id}/items?relative_path=/action
   ↓
   full_path = "/movies" + "/action" = "/movies/action"
   ↓
   服务器调用 AlistProvider.list_directory(ctx, "/action", ...)
   ↓
   返回 /movies/action 下的文件列表

4. 用户点击 "spider-man.mp4" 播放
   选择该文件（item.source_config 包含完整路径）
   ↓
   调用 AlistProvider.generate_url(item.source_config, ...)
   ↓
   返回播放 URL
```

##### 8. 安全性设计

**路径穿越防护**：

```rust
// 服务器端验证
let base_path = "/movies";
let relative_path = "../../etc/passwd";  // 恶意路径
let full_path = join_path(base_path, relative_path);  // "/etc/passwd"

if !full_path.starts_with(base_path) {
    return Err("Path traversal attack detected");
}
```

**权限检查**：

- ✅ 只有动态目录**创建者**可以列出内容（Go SyncTV 设计）
- ✅ 其他成员只能看到静态添加的媒体文件
- ✅ 凭证使用创建者的凭证（从 `user_provider_credentials` 表获取，AES-256-GCM 加密存储）

---

#### 2.4.9 relative_path 导航机制

`relative_path` 是动态目录的核心导航机制，用于在供应商目录结构中无限层级导航。

##### 1. relative_path 概念

**定义**：相对于动态目录基础路径（`source_config.path`）的相对路径。

**重要约定**：

- ✅ `relative_path` **总是以 `/` 开头**（即使是根目录下的第一层子路径）
- ✅ 拼接逻辑统一为：`full_path = base_path.trim_end_matches('/') + relative_path`
- ✅ 不需要在拼接时对 `relative_path` 进行 `trim_start_matches('/')`

**示例**：

```
base_path:      "/movies"
relative_path:  "/action/marvel"
full_path:      "/movies/action/marvel"

base_path:      "/movies/"  (末尾有斜杠)
relative_path:  "/action"
full_path:      "/movies/action"  (trim_end_matches 自动处理)
```

**命名理由**（为什么不叫 `subPath`）：

- ✅ **relative_path**: 准确描述其性质（相对路径），符合 Rust 命名习惯
- ❌ **subPath**: "sub" 前缀有歧义（subscript? submodule?），且驼峰命名不符合 Rust 规范

##### 2. API 设计

**查询参数**：

```http
GET /api/v1/playlists/{id}/items
    ?relative_path=/action/marvel  # 相对路径
    &page=1                        # 页码
    &page_size=20                  # 每页数量
    &keyword=iron                  # 搜索关键词（可选）
```

**响应示例**：

```json
{
  "items": [
    {
      "name": "iron-man.mp4",
      "item_type": "Video",
      "relative_path": "/action/marvel/iron-man.mp4",
      "source_config": {
        "fields": {
          "server": "https://alist.example.com",
          "path": "/movies/action/marvel/iron-man.mp4"  // 完整绝对路径
        }
      }
    },
    {
      "name": "avengers",
      "item_type": "Folder",
      "relative_path": "/action/marvel/avengers",
      "source_config": {
        "fields": {
          "server": "https://alist.example.com",
          "path": "/movies/action/marvel/avengers"
        }
      }
    }
  ],
  "total": 2,
  "is_dynamic": true,
  "parent_id": "playlist-uuid"
}
```

##### 3. 路径拼接逻辑

```rust
/// 安全的路径拼接
pub fn join_path(base: &str, relative: Option<&str>) -> String {
    match relative {
        None | Some("") | Some("/") => base.to_string(),
        Some(rel) => {
            let base = base.trim_end_matches('/');
            let rel = rel.trim_start_matches('/');
            format!("{}/{}", base, rel)
        }
    }
}

/// 路径穿越检查
pub fn validate_path(base: &str, full: &str) -> Result<()> {
    if !full.starts_with(base) {
        return Err("Path traversal detected");
    }
    Ok(())
}
```

**使用示例**：

```rust
let base_path = "/movies";

// 正常路径
assert_eq!(join_path(base_path, Some("/action")), "/movies/action");
assert_eq!(join_path(base_path, Some("action")), "/movies/action");
assert_eq!(join_path(base_path, Some("/action/")), "/movies/action/");
assert_eq!(join_path(base_path, None), "/movies");

// 恶意路径（会被检测）
let full = join_path(base_path, Some("../../etc/passwd"));
assert!(validate_path(base_path, &full).is_err());
```

##### 4. 导航流程

**用户点击子目录**：

```
1. 当前: GET /playlists/{id}/items
   显示: [action/, comedy/, movie1.mp4]

2. 用户点击 "action"
   请求: GET /playlists/{id}/items?relative_path=/action
   显示: [marvel/, dc/, action-movie1.mp4]

3. 用户点击 "marvel"
   请求: GET /playlists/{id}/items?relative_path=/action/marvel
   显示: [iron-man.mp4, avengers/, ...]

4. 用户点击 "avengers"
   请求: GET /playlists/{id}/items?relative_path=/action/marvel/avengers
   显示: [avengers1.mp4, avengers2.mp4, ...]
```

**面包屑导航**：

```rust
/// 生成面包屑路径
pub fn generate_breadcrumbs(relative_path: &str) -> Vec<Breadcrumb> {
    let mut breadcrumbs = vec![
        Breadcrumb { name: "根目录", path: "" }
    ];

    let parts: Vec<&str> = relative_path.trim_matches('/').split('/').collect();
    let mut current_path = String::new();

    for part in parts {
        if part.is_empty() { continue; }
        current_path = format!("{}/{}", current_path, part);
        breadcrumbs.push(Breadcrumb {
            name: part.to_string(),
            path: current_path.clone(),
        });
    }

    breadcrumbs
}
```

**返回示例**：

```json
// relative_path = "/action/marvel/avengers"
[
  {"name": "根目录", "path": ""},
  {"name": "action", "path": "/action"},
  {"name": "marvel", "path": "/action/marvel"},
  {"name": "avengers", "path": "/action/marvel/avengers"}
]
```

##### 5. DirectoryItem 结构

每个返回的子项都包含 **两个路径**：

```rust
pub struct DirectoryItem {
    /// 相对路径（用于继续导航）
    pub relative_path: String,  // "/action/marvel/iron-man.mp4"

    /// 完整配置（用于播放，包含绝对路径）
    pub source_config: SourceConfig,  // {path: "/movies/action/marvel/iron-man.mp4"}

    pub name: String,
    pub item_type: ItemType,
}
```

**为什么需要两个路径**：

- **relative_path**: 前端用于导航，点击子目录时作为查询参数
- **source_config.path**: 后端用于播放，调用 `generate_url()` 时使用绝对路径

**示例**：

```json
{
  "name": "iron-man.mp4",
  "relative_path": "/action/marvel/iron-man.mp4",  // ← 前端导航用
  "source_config": {
    "fields": {
      "path": "/movies/action/marvel/iron-man.mp4",  // ← 后端播放用（绝对路径）
      "server": "https://alist.example.com"
    }
  }
}
```

##### 6. 搜索功能

**API 请求**：

```http
GET /api/v1/playlists/{id}/items
    ?relative_path=/action  # 在此目录下搜索
    &keyword=spider         # 搜索关键词
    &page=1
```

**搜索行为**：

- ✅ 在 `relative_path` 指定的目录及其子目录中递归搜索
- ✅ 匹配文件名包含 `keyword` 的项
- ✅ 返回的 `relative_path` 是相对于搜索根目录的完整路径

**示例**（Alist）：

```rust
// 搜索 /movies/action 下包含 "spider" 的文件
let response = client.search(
    server,
    "/movies/action",  // parent 路径
    "spider",          // 关键词
    page,
    page_size,
).await?;

// 返回结果可能在不同子目录中
// /movies/action/marvel/spider-man.mp4 → relative_path: "/marvel/spider-man.mp4"
// /movies/action/sony/spider-verse.mp4 → relative_path: "/sony/spider-verse.mp4"
```

##### 7. 缓存策略

**Provider 端缓存**：

```rust
// Alist Provider 可以缓存目录列表（可选）
pub struct AlistMovieCache {
    cache: RefreshCache<DirectoryListing>,
}

impl AlistProvider {
    async fn list_directory(&self, ctx: &ParseContext, relative_path: Option<&str>, ...) -> Result<DirectoryListing> {
        let cache_key = format!("{}:{}", ctx.source_config.get("server")?, relative_path.unwrap_or(""));

        // 尝试从缓存获取
        if let Some(cached) = self.cache.get(&cache_key).await {
            return Ok(cached);
        }

        // 调用 API
        let listing = self.fetch_from_api(...).await?;

        // 缓存结果（TTL 5分钟）
        self.cache.set(&cache_key, listing.clone(), Duration::from_secs(300)).await;

        Ok(listing)
    }
}
```

**客户端缓存**：

- ✅ 前端可以缓存已访问过的目录列表
- ✅ 用户后退时无需重新请求
- ✅ 可以添加"刷新"按钮清除缓存

##### 8. 性能优化

**分页加载**：

```rust
// 每次只加载 20 项
pub const DEFAULT_PAGE_SIZE: usize = 20;

// 前端实现虚拟滚动，按需加载更多
GET /playlists/{id}/items?relative_path=/action&page=1&page_size=20
GET /playlists/{id}/items?relative_path=/action&page=2&page_size=20
```

**并行请求**：

```rust
// 前端可以并行请求多个子目录
let futures = vec![
    fetch("/playlists/{id}/items?relative_path=/action"),
    fetch("/playlists/{id}/items?relative_path=/comedy"),
    fetch("/playlists/{id}/items?relative_path=/horror"),
];
let results = join_all(futures).await;
```

**懒加载**：

- ✅ 只在用户点击时才加载子目录内容
- ✅ 避免一次性加载整个目录树（可能有成千上万个文件）

##### 9. 错误处理

**常见错误**：

```rust
pub enum ListDirectoryError {
    /// 动态目录不存在
    PlaylistNotFound,

    /// 不是动态目录
    NotDynamicFolder,

    /// 路径穿越攻击
    PathTraversal,

    /// 供应商 API 错误
    ProviderError(String),

    /// 凭证无效
    InvalidCredentials,

    /// 权限不足（非创建者）
    PermissionDenied,
}
```

**错误响应示例**：

```json
{
  "error": "ProviderError",
  "message": "Alist API 返回 404: 目录不存在",
  "details": {
    "provider": "alist",
    "path": "/movies/not-exist"
  }
}
```

##### 10. 总结

**relative_path 设计优势**：

- ✅ **无限层级**: 支持任意深度的目录导航
- ✅ **安全**: 路径穿越检查，防止访问非授权目录
- ✅ **高效**: 懒加载 + 分页 + 缓存
- ✅ **灵活**: 支持搜索、排序、过滤
- ✅ **简洁**: API 设计简单，前端易于实现

**与 Go SyncTV 的对应**：

- Go: `subPath` (驼峰命名)
- Rust: `relative_path` (蛇形命名，更准确的语义)

**关键实现点**：

1. 服务器端拼接完整路径：`base_path + relative_path`
2. 安全检查：`full_path.starts_with(base_path)`
3. Provider 返回包含完整绝对路径的 `source_config`
4. 前端使用 `relative_path` 进行导航
5. 后端使用 `source_config` 生成播放 URL

---

#### 2.4.10 设计优势

1. **扁平化设计（Flat Design）**：
   - ✅ 媒体内容存储在 `medias` 表
   - ✅ 播放列表存储在 `playlists` 表
   - ✅ 简化数据结构，减少 JOIN 操作
   - ✅ 支持动态文件夹（通过 `source_provider` + `source_config`）
   - ✅ 支持文件夹层级（通过 `relative_path`）

2. **数据库+缓存架构**：
   - ✅ 数据库只存储持久化配置（`source_config`）
   - ✅ 解析结果存储在 Redis 缓存中（`parsed_data`）
   - ✅ 敏感凭证（token、cookie）加密存储在独立表中
   - ✅ 缓存策略从 `source_config.share` 字段推导（仅部分 provider 支持）
   - ✅ 缓存自动过期和刷新
   - ✅ 减少数据库负载，提升性能

3. **多租户凭证管理**：
   - ✅ bilibili: 支持 share 字段（共享/非共享缓存）
   - ✅ alist/emby: 默认非共享缓存（每用户独立凭证）
   - ✅ 用户可以使用自己的账号（如自己的 B站会员）
   - ✅ 不同用户解析同一视频可能得到不同链接（权限不同）
   - ✅ 凭证与配置分离，安全且灵活

4. **动态目录支持**：
   - ✅ playlists 表支持动态目录（source_provider 不为 NULL）
   - ✅ 动态目录内容实时从供应商获取，不持久化子项
   - ✅ 支持 relative_path 无限层级导航
   - ✅ 支持搜索、分页、缓存
   - ✅ 安全的路径穿越检查

### 2.5 房间播放会话表 (room_playback_session)

```sql
-- migrations/007_create_room_playback_session.sql
CREATE TYPE play_status AS ENUM ('paused', 'playing');

CREATE TABLE room_playback_session (
    room_id UUID PRIMARY KEY REFERENCES rooms(id) ON DELETE CASCADE,

    -- ========== 播放源 ==========
    -- 播放列表上下文（始终记录，表示"在哪个列表中播放"）
    playlist_id UUID REFERENCES playlists(id) ON DELETE SET NULL,

    -- 静态媒体：引用具体的 media 记录
    media_id UUID REFERENCES medias(id) ON DELETE SET NULL,

    -- 动态媒体：播放列表内的相对路径（当 media_id 为空时使用）
    relative_path TEXT,

    -- 约束：media_id 和 relative_path 二选一
    CONSTRAINT playback_source_check CHECK (
        (media_id IS NOT NULL AND relative_path IS NULL) OR
        (media_id IS NULL AND relative_path IS NOT NULL)
    ),

    -- ========== 播放状态 ==========
    status play_status NOT NULL DEFAULT 'paused',
    position DOUBLE PRECISION NOT NULL DEFAULT 0,  -- 播放位置（秒）

    -- 播放速率（1.0 = 正常，2.0 = 2倍速）
    rate DOUBLE PRECISION NOT NULL DEFAULT 1.0,

    -- 最后更新时间（用于时间同步）
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_by UUID REFERENCES users(id)
);

CREATE INDEX idx_playback_playlist ON room_playback_session(playlist_id);
CREATE INDEX idx_playback_media ON room_playback_session(media_id);

COMMENT ON TABLE room_playback_session IS '房间播放会话（记录正在播放的内容和进度）';
COMMENT ON COLUMN room_playback_session.playlist_id IS '播放列表上下文（来自哪个播放列表）';
COMMENT ON COLUMN room_playback_session.media_id IS '静态媒体：引用 medias.id';
COMMENT ON COLUMN room_playback_session.relative_path IS '动态媒体：播放列表内相对路径（如 "/movies/action/movie.mp4"）';
COMMENT ON COLUMN room_playback_session.position IS '播放位置（秒，视频播放器标准术语）';
COMMENT ON COLUMN room_playback_session.rate IS '播放速率（倍速，1.0 = 正常）';
```

**使用场景**：

```sql
-- 场景1：播放静态媒体（从播放列表添加的视频）
UPDATE room_playback_session
SET playlist_id = 'playlist-uuid',
    media_id = 'media-uuid',
    relative_path = NULL,
    status = 'playing',
    position = 0
WHERE room_id = 'room-uuid';

-- 场景2：播放动态播放列表中的文件（Alist/Emby）
UPDATE room_playback_session
SET playlist_id = 'playlist-uuid',  -- 动态播放列表
    media_id = NULL,
    relative_path = '/movies/action/movie.mp4',
    status = 'playing',
    position = 0
WHERE room_id = 'room-uuid';
```

**业务逻辑**：

```rust
// service/room_service.rs
pub async fn get_current_playback(&self, room_id: &str) -> Result<PlaybackInfo> {
    let session = self.repo.get_playback_session(room_id).await?;

    let playback = if let Some(media_id) = session.media_id {
        // 场景1：静态媒体（有 media_id）
        let media = self.media_repo.get(media_id).await?;
        let provider = self.provider_registry.get(&media.source_provider)?;

        provider.generate_playback(
            &ProviderContext::new(room_id),
            &media.source_config,
        ).await?

    } else if let (Some(playlist_id), Some(relative_path)) =
        (session.playlist_id, session.relative_path) {
        // 场景2：动态媒体（无 media_id，从播放列表配置 + 相对路径生成）
        let playlist = self.playlist_repo.get(playlist_id).await?;

        // 验证是动态播放列表
        let (provider_name, base_config) = playlist.source_provider
            .ok_or(Error::NotDynamicPlaylist)?;

        let provider = self.provider_registry.get(&provider_name)?;

        // 合并基础配置 + 相对路径
        let full_config = merge_config(&base_config, &relative_path)?;

        provider.generate_playback(
            &ProviderContext::new(room_id),
            &full_config,
        ).await?

    } else {
        return Err(Error::NoCurrentMedia);
    };

    Ok(PlaybackInfo {
        urls: playback.urls,
        subtitles: playback.subtitles,
        danmaku_urls: playback.danmaku_urls,
        position: session.position,
        status: session.status,
        rate: session.rate,
    })
}

/// 合并基础配置和相对路径
///
/// # 约定
/// - `relative_path` 总是以 `/` 开头
/// - 拼接逻辑：`base_path.trim_end_matches('/') + relative_path`
///
/// # 示例
/// ```
/// base_path = "/movies", relative_path = "/action/movie.mp4"
/// → full_path = "/movies/action/movie.mp4"
/// ```
fn merge_config(base_config: &Value, relative_path: &str) -> Result<Value> {
    let mut config = base_config.clone();

    if let Some(base_path) = config.get("path").and_then(|v| v.as_str()) {
        // 直接拼接（relative_path 已经以 '/' 开头）
        let full_path = format!("{}{}", base_path.trim_end_matches('/'), relative_path);
        config["path"] = json!(full_path);
    } else {
        // 如果没有 base_path，直接使用 relative_path
        config["path"] = json!(relative_path);
    }

    Ok(config)
}
```

**关键设计点**：

1. **playlist_id 始终记录**：提供播放上下文，方便后续功能（如"自动连播下一个"）

2. **media_id 和 relative_path 互斥**：
   - 有 `media_id` → 静态媒体，从 medias 表读取完整配置
   - 无 `media_id` → 动态媒体，从 playlists 表读取基础配置 + relative_path

3. **配置合并逻辑**：

   ```rust
   // Alist 示例
   playlist.source_config = {"path": "/movies", "password": ""}
   relative_path = "/action/movie.mp4"
   → 最终配置 = {"path": "/movies/action/movie.mp4", "password": ""}
   ```

4. **约束保证一致性**：

   ```sql
   CHECK (
       (media_id IS NOT NULL AND relative_path IS NULL) OR
       (media_id IS NULL AND relative_path IS NOT NULL)
   )
   ```

### 2.6 直播流表 (streams)

```sql
-- migrations/008_create_streams.sql
CREATE TYPE stream_status AS ENUM ('offline', 'online');

CREATE TABLE streams (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    stream_key VARCHAR(255) UNIQUE NOT NULL,
    media_id UUID NOT NULL REFERENCES medias(id) ON DELETE CASCADE,

    -- Publisher 节点信息 (无 master/slave 概念)
    publisher_node_id VARCHAR(100) NOT NULL,
    status stream_status NOT NULL DEFAULT 'offline',

    -- 流信息
    codec_video VARCHAR(50),
    codec_audio VARCHAR(50),
    bitrate INT,
    resolution VARCHAR(20),

    -- 统计
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    total_bytes BIGINT DEFAULT 0,
    viewer_count INT DEFAULT 0,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_streams_stream_key ON streams(stream_key);
CREATE INDEX idx_streams_media ON streams(media_id);
CREATE INDEX idx_streams_publisher_node ON streams(publisher_node_id);
CREATE INDEX idx_streams_status ON streams(status) WHERE status = 'online';
CREATE INDEX idx_streams_start_time ON streams(start_time DESC);

CREATE TRIGGER update_streams_updated_at
    BEFORE UPDATE ON streams
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE streams IS '直播流表';
COMMENT ON COLUMN streams.media_id IS '关联的 medias.id（source_provider 必须是 rtmp）';
COMMENT ON COLUMN streams.publisher_node_id IS '当前流的 Publisher 节点ID';
```

### 2.7 聊天消息表 (chat_messages)

```sql
-- migrations/009_create_chat_messages.sql
CREATE TABLE chat_messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    username VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'text',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT content_not_empty CHECK (length(content) > 0 AND length(content) <= 2000)
);

-- 索引
CREATE INDEX idx_chat_messages_room_time ON chat_messages(room_id, created_at DESC);
CREATE INDEX idx_chat_messages_user ON chat_messages(user_id);

-- 自动清理触发器：保留每个房间最近500条消息
CREATE OR REPLACE FUNCTION cleanup_old_messages()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM chat_messages
    WHERE room_id = NEW.room_id
    AND id NOT IN (
        SELECT id FROM chat_messages
        WHERE room_id = NEW.room_id
        ORDER BY created_at DESC
        LIMIT 500
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cleanup_messages
AFTER INSERT ON chat_messages
FOR EACH ROW
EXECUTE FUNCTION cleanup_old_messages();

COMMENT ON TABLE chat_messages IS '聊天消息表,每个房间仅保留最近500条记录';
```

---

## 3. 认证与授权表

> 详细设计参见 [06-用户系统设计](./06-用户系统设计.md)

### 3.1 OAuth2 绑定表 (oauth2_bindings)

```sql
-- migrations/010_create_oauth2_bindings.sql
CREATE TYPE oauth2_provider AS ENUM ('github', 'gitlab', 'google', 'discord', 'microsoft', 'oidc');

CREATE TABLE oauth2_bindings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    provider oauth2_provider NOT NULL,
    provider_user_id VARCHAR(255) NOT NULL,
    provider_username VARCHAR(255),
    provider_email VARCHAR(255),

    -- OAuth2 Token (加密存储,用于刷新)
    access_token TEXT,
    refresh_token TEXT,
    token_expires_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE (provider, provider_user_id)
);

-- 索引
CREATE INDEX idx_oauth2_bindings_user ON oauth2_bindings(user_id);
CREATE INDEX idx_oauth2_bindings_provider ON oauth2_bindings(provider, provider_user_id);

CREATE TRIGGER update_oauth2_bindings_updated_at
    BEFORE UPDATE ON oauth2_bindings
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE oauth2_bindings IS 'OAuth2 提供商绑定表';
COMMENT ON COLUMN oauth2_bindings.provider IS 'OAuth2 提供商：github, gitlab, google, discord, microsoft, oidc';
```

### 3.2 邮件验证令牌表 (email_verification_tokens)

```sql
-- migrations/011_create_email_verification_tokens.sql
CREATE TABLE email_verification_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    token VARCHAR(64) UNIQUE NOT NULL,
    email VARCHAR(255) NOT NULL,

    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_email_verification_tokens_token ON email_verification_tokens(token) WHERE used_at IS NULL;
CREATE INDEX idx_email_verification_tokens_user ON email_verification_tokens(user_id);
CREATE INDEX idx_email_verification_tokens_expires ON email_verification_tokens(expires_at) WHERE used_at IS NULL;

-- 自动清理过期令牌
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS void AS $$
BEGIN
    DELETE FROM email_verification_tokens
    WHERE expires_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

COMMENT ON TABLE email_verification_tokens IS '邮箱验证令牌表';
```

### 3.3 密码重置令牌表 (password_reset_tokens)

```sql
-- migrations/012_create_password_reset_tokens.sql
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    token VARCHAR(64) UNIQUE NOT NULL,

    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token) WHERE used_at IS NULL;
CREATE INDEX idx_password_reset_tokens_user ON password_reset_tokens(user_id);
CREATE INDEX idx_password_reset_tokens_expires ON password_reset_tokens(expires_at) WHERE used_at IS NULL;

COMMENT ON TABLE password_reset_tokens IS '密码重置令牌表';
```

### 3.4 审计日志表 (audit_logs)

> 详细设计参见 [15-安全与故障处理](./24-安全故障.md)

```sql
-- migrations/013_create_audit_logs.sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,

    action VARCHAR(100) NOT NULL,
    resource_provider VARCHAR(50) NOT NULL,
    resource_id VARCHAR(100),

    details JSONB,

    ip_address INET,
    user_agent TEXT,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_provider, resource_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
CREATE INDEX idx_audit_logs_details ON audit_logs USING gin(details);

-- 分区表 (按月分区)
CREATE TABLE audit_logs_y2026m01 PARTITION OF audit_logs
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE audit_logs_y2026m02 PARTITION OF audit_logs
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- 自动清理旧日志 (保留90天)
CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS void AS $$
BEGIN
    DELETE FROM audit_logs
    WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

COMMENT ON TABLE audit_logs IS '审计日志表（按月分区）';
```

---

## 4. 索引设计

### 4.1 索引策略

| 表 | 索引类型 | 列 | 用途 |
|---|---------|---|------|
| users | B-Tree | username | 登录查询 |
| users | B-Tree | email | 邮箱查询 |
| users | Partial | (email_verified) WHERE FALSE | 未验证用户 |
| rooms | B-Tree | creator_id | 查询用户创建的房间 |
| rooms | GIN | to_tsvector(name) | 全文搜索 |
| playlists | B-Tree | (room_id, position) | 播放列表排序 |
| medias | B-Tree | (playlist_id, position) | 播放列表内媒体排序 |
| medias | B-Tree | (room_id, created_at) | 房间媒体查询 |
| medias | GIN | source_config | JSON查询 |
| room_members | B-Tree | (room_id, status) | 查询活跃成员 |
| chat_messages | B-Tree | (room_id, created_at DESC) | 消息历史 |
| audit_logs | B-Tree | (created_at DESC) | 审计查询 |

### 4.2 部分索引 (Partial Index)

部分索引可以显著减少索引大小:

```sql
-- 只索引活跃房间
CREATE INDEX idx_rooms_active ON rooms(created_at DESC)
    WHERE status = 'active';

-- 只索引在线流
CREATE INDEX idx_streams_online ON streams(publisher_node_id)
    WHERE status = 'online';

-- 只索引未使用的令牌
CREATE INDEX idx_reset_tokens_active ON password_reset_tokens(token)
    WHERE used_at IS NULL AND expires_at > NOW();
```

### 4.3 表达式索引

```sql
-- 用户名小写索引（不区分大小写查询）
CREATE INDEX idx_users_username_lower ON users(LOWER(username));

-- 房间名全文搜索
CREATE INDEX idx_rooms_name_fts ON rooms USING gin(to_tsvector('simple', name));
```

---

## 5. 查询优化

### 5.1 N+1 查询问题

**问题示例**:

```rust
// ❌ 错误：N+1 查询
let rooms = room_repo.list().await?;
for room in rooms {
    let creator = user_repo.get(room.creator_id).await?;  // N次查询
}
```

**优化方案**:

```rust
// ✅ 正确：JOIN 查询
let rooms_with_creator = sqlx::query_as!(
    RoomWithCreator,
    r#"
    SELECT
        r.*,
        u.id as creator_id,
        u.username as creator_username,
        u.avatar_url as creator_avatar_url
    FROM rooms r
    JOIN users u ON r.creator_id = u.id
    WHERE r.status = 'active'
    ORDER BY r.created_at DESC
    "#
)
.fetch_all(&pool)
.await?;
```

### 5.2 批量查询优化

```rust
// db/user_repo.rs
impl UserRepository {
    /// 批量获取用户
    pub async fn get_many(&self, ids: &[Uuid]) -> Result<Vec<User>> {
        if ids.is_empty() {
            return Ok(Vec::new());
        }

        let users = sqlx::query_as!(
            User,
            r#"
            SELECT id, username, email, email_verified, role as "role: UserRole",
                   avatar_url, bio, last_login_at, created_at, updated_at
            FROM users
            WHERE id = ANY($1)
            "#,
            ids
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(users)
    }
}
```

### 5.3 分页查询优化

```sql
-- 使用 Keyset Pagination (游标分页) 而非 OFFSET
-- ❌ 慢：OFFSET 随着页码增大变慢
SELECT * FROM rooms
WHERE status = 'active'
ORDER BY created_at DESC
LIMIT 20 OFFSET 1000;

-- ✅ 快：Keyset Pagination
SELECT * FROM rooms
WHERE status = 'active'
  AND created_at < $1  -- 上一页最后一条的 created_at
ORDER BY created_at DESC
LIMIT 20;
```

---

## 6. 并发控制

在多副本架构下，需要处理多个副本同时修改同一数据的并发冲突问题。

### 6.1 乐观锁机制

使用版本号字段实现乐观锁，避免并发修改冲突。

#### 数据库表修改

```sql
-- migrations/xxx_add_version_columns.sql

-- 房间表添加version字段
ALTER TABLE rooms ADD COLUMN version BIGINT NOT NULL DEFAULT 0;
CREATE INDEX idx_rooms_version ON rooms(id, version);

-- 房间当前状态表添加version
ALTER TABLE room_current_state ADD COLUMN version BIGINT NOT NULL DEFAULT 0;
CREATE INDEX idx_room_state_version ON room_current_state(room_id, version);

-- 房间成员表添加version
ALTER TABLE room_members ADD COLUMN version BIGINT NOT NULL DEFAULT 0;
CREATE INDEX idx_room_members_version ON room_members(room_id, user_id, version);
```

#### Repository实现

```rust
// db/room_repo.rs
impl RoomRepository {
    /// 使用乐观锁更新房间设置
    pub async fn update_settings_versioned(
        &self,
        room_id: &str,
        settings: &RoomSettings,
        expected_version: i64,
    ) -> Result<()> {
        let result = sqlx::query!(
            r#"
            UPDATE rooms
            SET settings = $1,
                version = version + 1,
                updated_at = NOW()
            WHERE id = $2 AND version = $3
            "#,
            serde_json::to_value(settings)?,
            room_id,
            expected_version
        )
        .execute(&self.pool)
        .await?;

        if result.rows_affected() == 0 {
            return Err(Error::ConcurrentModification {
                resource: "room_settings".to_string(),
                id: room_id.to_string(),
                expected_version,
            });
        }

        Ok(())
    }

    /// 获取房间（包含version）
    pub async fn get_with_version(&self, room_id: &str) -> Result<(Room, i64)> {
        let row = sqlx::query!(
            r#"
            SELECT *, version
            FROM rooms
            WHERE id = $1
            "#,
            room_id
        )
        .fetch_one(&self.pool)
        .await?;

        let room = Room {
            id: row.id,
            name: row.name,
            // ... 其他字段
        };

        Ok((room, row.version))
    }

    /// 更新成员权限（乐观锁 + Allow/Deny模式）
    pub async fn update_member_permissions_versioned(
        &self,
        room_id: &str,
        user_id: Uuid,
        added_permissions: Option<u64>,
        removed_permissions: Option<u64>,
        expected_version: i64,
    ) -> Result<()> {
        let result = sqlx::query!(
            r#"
            UPDATE room_members
            SET added_permissions = $1,
                removed_permissions = $2,
                version = version + 1,
                updated_at = NOW()
            WHERE room_id = $3 AND user_id = $4 AND version = $5
            "#,
            added_permissions.map(|p| p as i64),
            removed_permissions.map(|p| p as i64),
            room_id,
            user_id,
            expected_version
        )
        .execute(&self.pool)
        .await?;

        if result.rows_affected() == 0 {
            return Err(Error::ConcurrentModification {
                resource: "member_permissions".to_string(),
                id: format!("{}:{}", room_id, user_id),
                expected_version,
            });
        }

        Ok(())
    }
}
```

#### Service层处理

```rust
// service/room_service.rs
impl RoomService {
    pub async fn update_settings(
        &self,
        room_id: &str,
        user_id: Uuid,
        settings: RoomSettings,
        expected_version: i64,
    ) -> Result<()> {
        // 检查权限
        self.check_admin_permission(room_id, user_id).await?;

        // 使用乐观锁更新
        match self.room_repo.update_settings_versioned(
            room_id,
            &settings,
            expected_version,
        ).await {
            Ok(_) => {
                // 成功：清除缓存并发布事件
                self.cache.delete(&format!("room:{}", room_id)).await?;

                self.cluster_sync.publish(ClusterEvent::RoomUpdated {
                    room_id: room_id.to_string(),
                    fields_changed: vec!["settings".to_string()],
                }).await?;

                Ok(())
            }
            Err(Error::ConcurrentModification { expected_version, .. }) => {
                // 冲突：返回409错误，让客户端重新获取最新版本
                Err(Error::ConcurrentModification {
                    resource: "room_settings".to_string(),
                    id: room_id.to_string(),
                    expected_version,
                })
            }
            Err(e) => Err(e),
        }
    }
}
```

#### API响应

```rust
// api/v1/room.rs
#[derive(Deserialize)]
pub struct UpdateSettingsRequest {
    pub settings: RoomSettings,
    pub version: i64,  // 客户端必须提供当前版本号
}

async fn update_room_settings(
    Path(room_id): Path<String>,
    State(state): State<AppState>,
    Extension(user): Extension<User>,
    Json(request): Json<UpdateSettingsRequest>,
) -> Result<impl IntoResponse> {
    match state.room_service.update_settings(
        &room_id,
        user.id,
        request.settings,
        request.version,
    ).await {
        Ok(_) => Ok((StatusCode::OK, Json(ApiResponse::success(())))),
        Err(Error::ConcurrentModification { expected_version, .. }) => {
            Ok((
                StatusCode::CONFLICT,
                Json(ApiResponse::error(
                    409,
                    &format!(
                        "设置已被其他人修改（期望版本: {}），请刷新后重试",
                        expected_version
                    ),
                )),
            ))
        }
        Err(e) => Err(e),
    }
}
```

### 6.2 适用场景

| 场景 | 是否使用乐观锁 | 说明 |
|------|-------------|------|
| 更新房间设置 | ✅ 是 | 冲突概率中等，适合乐观锁 |
| 更新成员权限 | ✅ 是 | 冲突概率低，适合乐观锁 |
| 播放状态同步 | ❌ 否 | 高频操作，使用最后写入胜出（LWW） |
| 聊天消息 | ❌ 否 | 追加操作，不会冲突 |
| 创建房间 | ❌ 否 | 使用分布式锁（见12章） |

### 6.4 乐观锁 vs 悲观锁

| 方面 | 乐观锁 | 悲观锁 (SELECT FOR UPDATE) |
|------|--------|---------------------------|
| 冲突处理 | 检测冲突，回滚重试 | 阻塞等待，串行执行 |
| 性能 | 高并发下更好 | 低并发下更好 |
| 实现复杂度 | 简单（version字段） | 复杂（需要事务管理） |
| 适用场景 | 冲突概率低-中 | 冲突概率高 |
| 分布式友好 | ✅ 是 | ❌ 否（需要全局锁） |

### 6.5 设计要点

**版本号自增**：

- 每次更新自动递增（`version = version + 1`）
- 使用数据库原子操作，无需应用层管理

**冲突检测**：

- `WHERE version = expected_version`确保只更新正确版本
- `rows_affected() == 0`表示冲突

**客户端重试**：

- 409 Conflict错误码通知客户端
- 客户端重新获取最新数据并重试

**组合使用**：

- 乐观锁 + 分布式锁：先用分布式锁获取写入权，再用乐观锁保证数据库一致性
- 乐观锁 + 缓存失效：更新成功后清除缓存

---

## 7. 数据迁移

### 6.1 迁移工具

使用 sqlx-cli:

```bash
# 安装
cargo install sqlx-cli --no-default-features --features postgres

# 创建迁移
sqlx migrate add create_users

# 运行迁移
sqlx migrate run

# 回滚
sqlx migrate revert

# 生成编译时检查
cargo sqlx prepare
```

### 6.2 数据库 ER 图

```text
┌─────────────┐
│   users     │
│─────────────│
│ id (PK)     │◄──────────┐
│ username    │           │
│ email       │           │
│ role        │           │
└─────────────┘           │
      │                   │
      │                   │
      │           ┌───────┴──────────┐
      │           │  oauth2_bindings │
      │           │──────────────────│
      │           │ user_id (FK)     │
      │           │ provider         │
      │           └──────────────────┘
      │
      │           ┌──────────────────┐
      │           │ audit_logs       │
      │           │──────────────────│
      │           │ user_id (FK)     │
      │           │ action           │
      │           └──────────────────┘
      │
      ├───────────────────────────────────┐
      │                                   │
┌─────┴────────┐              ┌───────────┴──────┐
│    rooms     │              │  room_members    │
│──────────────│              │──────────────────│
│ id (PK)      │◄─────────────│ room_id (FK)     │
│ name         │              │ user_id (FK)     │
│ creator_id(FK)│             │ role             │
│ settings     │              │ added_perms      │
└──────┬───────┘              │ removed_perms    │
       │                      └──────────────────┘
       │
┌──────┴─────────────┐
│ room_current_state │
│────────────────────│
│ room_id (PK)(FK)   │
│ current_media_id(FK)│ ─┐
│ current_status     │  │
│ current_time       │  │
└────────────────────┘  │
                        │
       ┌────────────────┘
       │
┌──────┴────────────┐        ┌──────────────┐
│   playlists       │        │    medias    │
│───────────────────│        │──────────────│
│ id (PK)           │◄───────│ playlist_id(FK)│
│ room_id (FK)      │        │ room_id (FK) │
│ creator_id (FK)   │        │ creator_id(FK)│
│ name              │        │ name         │
│ parent_id (FK)    │───┐    │ source_provider  │
│ position          │   │    │ source_config│
└───────────────────┘   │    │ credential_  │
        ▲               │    │   source     │
        │               │    └──────┬───────┘
        └───────────────┘           │
         (self-ref)                 │
                                    │
                             ┌──────┴───────┐
                             │   streams    │
                             │──────────────│
                             │ id (PK)      │
                             │ stream_key   │
                             │ media_id (FK)│
                             │ publisher_   │
                             │   node       │
                             │ status       │
                             └──────────────┘

┌───────────────┐
│ chat_messages │
│───────────────│
│ id (PK)       │
│ room_id (FK)  │
│ user_id (FK)  │
│ content       │
│ created_at    │
└───────────────┘
```

**关键关系**：

- `playlists` 支持树形结构（`parent_id` 自引用，构建 /aaa/bbb/ccc 路径）
- `medias` 属于某个 `playlists`（必须指定 playlist_id）
- `streams` 引用 `medias`（仅直播类型的媒体）
- `room_current_state.current_media_id` 引用 `medias`（当前播放的媒体文件）

---

## 8. 总结

### 核心表设计要点

1. **用户表**: UUID主键、OAuth2支持、邮箱验证、审计字段
2. **房间表**: JSONB 灵活配置、全文搜索支持、version字段、自动创建根目录
3. **成员表**: 64位权限掩码、Allow/Deny权限模式、version字段
4. **播放列表表**: 纯文件系统设计、目录与文件分离、类型安全
   - `playlists`: 目录表（树形结构，支持 /aaa/bbb/ccc 路径）
   - `medias`: 媒体文件表（所属某个目录，包含视频源配置）
   - 同一目录下不能有同名子目录或文件（唯一约束）
5. **流表**: Publisher 节点记录、状态跟踪、引用 medias
6. **认证表**: OAuth2、邮件验证、密码重置
7. **审计表**: 按月分区、自动清理
8. **并发控制**: 乐观锁版本控制、多副本并发安全

### 性能优化

- 合理使用索引（B-Tree、GIN、Partial）
- 避免 N+1 查询
- 批量查询优化
- Keyset Pagination 替代 OFFSET
- 自动清理机制
- 表分区（audit_logs）
- 兼容性视图（简化JOIN查询）

### 播放列表设计亮点

**纯文件系统设计**（参考Unix文件系统）:

- ✅ **目录与文件分离**: `playlists`（目录） + `medias`（文件）
- ✅ **类型安全**: 目录永远是目录，文件永远是文件，编译期保证
- ✅ **无字段冗余**: 目录不需要 source_provider/source_config，文件不需要 parent_id 树形字段
- ✅ **路径表达**: 支持完整路径表达 `/电影/动作片/漫威`
- ✅ **同名保护**: 同一目录下不能有同名子目录或文件（唯一约束）
- ✅ **树形结构**: 支持无限层级目录嵌套
- ✅ **自动根目录**: 每个房间自动创建根目录 `/`（触发器）
- ✅ **易于扩展**: 新增音频/图片只需修改 medias 的 source_provider

**详细设计**: 参见 [13-自动连播设计-文件夹支持补充](./13-自动连播设计-文件夹支持补充.md)

### 视频源提供者设计亮点

**生命周期钩子模式**:

- ✅ **事件驱动**: 支持播放开始/停止/暂停/恢复/完毕/进度/错误等7种事件
- ✅ **可选实现**: 默认空操作，只有需要的 provider实现（如 Emby），零开销抽象
- ✅ **异步非阻塞**: 使用 `tokio::spawn` 异步执行，不阻塞主播放流程
- ✅ **错误隔离**: 钩子失败只记录日志，不影响播放体验
- ✅ **完整上下文**: 传递用户ID、房间ID、会话ID、凭证等完整信息
- ✅ **资源管理**: Emby 可通过钩子控制转码任务，及时释放服务器资源
- ✅ **统计分析**: 可记录完整的播放行为数据（开始/暂停/跳转/完成）
- ✅ **可扩展**: 容易添加新的生命周期事件，不影响现有代码

**使用场景**:

- **Emby/Plex**: 通知服务器播放状态，控制转码任务，更新观看进度
- **统计分析**: 记录用户播放行为，生成观看报告
- **日志审计**: 记录详细的播放日志，用于问题排查
- **第三方集成**: 通知外部系统（如 Webhook、消息队列）

**最佳实践**:

1. 钩子方法应该快速返回，耗时操作使用异步任务
2. 不应假设钩子一定成功，要处理失败情况
3. 频繁调用的钩子（如 `on_playback_progress`）必须高效
4. 使用结构化日志记录钩子执行情况

**下一章**: [05-缓存设计](./05-缓存设计.md)
