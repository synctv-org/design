# 05. 缓存设计

---

## 5.0 统一 Key 设计

### 5.0.1 Key 前缀配置

**设计原则**：所有 Redis key 使用统一的可配置前缀，便于：

- 多环境隔离（dev/staging/prod）
- 命名空间管理
- 批量清理

**配置**：

```toml
# config.toml
[redis]
url = "redis://localhost:6379"
key_prefix = "synctv"  # 默认前缀，可配置
```

### 5.0.2 KeyBuilder 实现

```rust
// utils/key_builder.rs

/// Redis Key 构建器
///
/// 统一管理所有 Redis key 的命名规范
pub struct KeyBuilder {
    prefix: String,
}

impl KeyBuilder {
    pub fn new(prefix: impl Into<String>) -> Self {
        Self {
            prefix: prefix.into(),
        }
    }

    // ==================== 集群管理 ====================

    /// 节点注册信息
    pub fn cluster_node(&self, node_id: &str) -> String {
        format!("{}:cluster:nodes:{}", self.prefix, node_id)
    }

    /// 活跃节点列表（Sorted Set）
    pub fn cluster_nodes_active(&self) -> String {
        format!("{}:cluster:nodes:active", self.prefix)
    }

    // ==================== 直播流管理 ====================

    /// 流发布者信息（Hash）
    pub fn stream_info(&self, stream_key: &str) -> String {
        format!("{}:stream:info:{}", self.prefix, stream_key)
    }

    /// 流拉取会话（Set）
    pub fn stream_subscribers(&self, stream_key: &str) -> String {
        format!("{}:stream:subscribers:{}", self.prefix, stream_key)
    }

    // ==================== 房间状态 ====================

    /// 房间当前状态（Hash）
    pub fn room_state(&self, room_id: &str) -> String {
        format!("{}:room:{}:state", self.prefix, room_id)
    }

    /// 房间成员列表（Set）
    pub fn room_members(&self, room_id: &str) -> String {
        format!("{}:room:{}:members", self.prefix, room_id)
    }

    /// 房间在线用户（Sorted Set，按最后活跃时间）
    pub fn room_online_users(&self, room_id: &str) -> String {
        format!("{}:room:{}:online", self.prefix, room_id)
    }

    // ==================== 播放缓存 ====================

    /// 播放信息缓存
    pub fn playback_cache(&self, cache_key: &str) -> String {
        format!("{}:playback:{}", self.prefix, cache_key)
    }

    // ==================== 会话管理 ====================

    /// 用户会话
    pub fn user_session(&self, session_id: &str) -> String {
        format!("{}:session:{}", self.prefix, session_id)
    }

    // ==================== 速率限制 ====================

    /// API 速率限制
    pub fn rate_limit(&self, identifier: &str, window: &str) -> String {
        format!("{}:ratelimit:{}:{}", self.prefix, identifier, window)
    }
}
```

### 5.0.3 使用示例

所有 ID 直接使用 nanoid(12)，无需转换。

```rust
// 在 API handler 中使用
use nanoid::nanoid;

/// 获取房间信息
async fn get_room_handler(
    State(state): State<AppState>,
    Path(room_id): Path<String>,  // 直接使用 nanoid(12)
) -> Result<Json<RoomResponse>> {
    // 从数据库查询（使用 nanoid）
    let room = state.db.get_room_by_id(&room_id).await?;

    // 构建 API 响应
    let response = RoomResponse {
        id: room.id,  // 直接使用 nanoid
        name: room.name,
        creator_id: room.creator_id,  // 也是 nanoid
        // ...
    };

    Ok(Json(response))
}

/// 创建房间
async fn create_room_handler(
    State(state): State<AppState>,
    Json(req): Json<CreateRoomRequest>,
) -> Result<Json<RoomResponse>> {
    // 生成 nanoid(12) 作为房间 ID
    let room_id = nanoid!(12);

    let room = Room {
        id: room_id.clone(),
        name: req.name,
        creator_id: req.user_id,  // 也是 nanoid
        // ...
    };

    state.db.create_room(&room).await?;

    // 返回响应
    let response = RoomResponse {
        id: room_id,
        // ...
    };

    Ok(Json(response))
}
```

### 5.0.4 Key 命名规范总结

| 功能 | Key 格式 | 类型 | TTL |
|------|---------|------|-----|
| **集群** |
| 节点信息 | `{prefix}:cluster:nodes:{node_id}` | String | 60s |
| 活跃节点 | `{prefix}:cluster:nodes:active` | Sorted Set | - |
| **直播流** |
| 流信息 | `{prefix}:stream:info:{stream_key}` | Hash | 300s |
| 订阅者 | `{prefix}:stream:subscribers:{stream_key}` | Set | 300s |
| **房间** |
| 房间状态 | `{prefix}:room:{room_id}:state` | Hash | - |
| 房间成员 | `{prefix}:room:{room_id}:members` | Set | - |
| 在线用户 | `{prefix}:room:{room_id}:online` | Sorted Set | - |
| **播放** |
| 播放缓存 | `{prefix}:playback:{cache_key}` | String | 动态 |

**注意**：所有 ID（room_id、user_id 等）均为 nanoid(12) 字符串格式。

---

## 5.1 Redis 数据结构

### 5.1.1 节点注册

```
类型: String + TTL
键: cluster:nodes:{node_id}
值: JSON {
  "node_id": "pod-synctv-0",
  "addr": "10.244.0.10:8080",
  "rtmp_port": 1935,
  "grpc_port": 50051,
  "status": "online",
  "last_heartbeat": 1706500000
}
TTL: 60秒

# 有序集合（按心跳时间）
类型: Sorted Set
键: cluster:nodes:active
成员: node_id
分数: timestamp
```

**操作**:

```rust
// 注册节点
async fn register_node(node: &NodeInfo) -> Result<()> {
    let key = format!("cluster:nodes:{}", node.node_id);
    let value = serde_json::to_string(node)?;

    let mut conn = redis.get().await?;

    // 设置节点信息（60秒TTL）
    redis::cmd("SET")
        .arg(&key)
        .arg(&value)
        .arg("EX")
        .arg(60)
        .query_async(&mut conn)
        .await?;

    // 添加到活跃节点集合
    redis::cmd("ZADD")
        .arg("cluster:nodes:active")
        .arg(Utc::now().timestamp())
        .arg(&node.node_id)
        .query_async(&mut conn)
        .await?;

    Ok(())
}

// 获取所有活跃节点
async fn get_active_nodes() -> Result<Vec<String>> {
    let mut conn = redis.get().await?;

    // 获取最近60秒内活跃的节点
    let cutoff = Utc::now().timestamp() - 60;

    let nodes: Vec<String> = redis::cmd("ZRANGEBYSCORE")
        .arg("cluster:nodes:active")
        .arg(cutoff)
        .arg("+inf")
        .query_async(&mut conn)
        .await?;

    Ok(nodes)
}
```

### 5.1.2 流注册

```
类型: String + TTL
键: stream:publisher:{stream_key}
值: JSON {
  "node_id": "pod-synctv-1",
  "addr": "10.244.0.11:50051",
  "started_at": "2024-01-29T10:00:00Z"
}
TTL: 300秒（5分钟）

# 流统计
类型: Hash
键: stream:stats:{stream_key}
字段:
  viewers: 观众数
  bitrate: 码率
  packets: 包数
  bytes: 字节数
```

**操作**:

```rust
// 注册流的 Publisher 节点
async fn register_stream_publisher(
    stream_key: &str,
    node_id: &str,
    ttl: usize,
) -> Result<()> {
    let key = format!("stream:publisher:{}", stream_key);
    let value = serde_json::to_string(&StreamPublisher {
        node_id: node_id.to_string(),
        started_at: Utc::now(),
    })?;

    let mut conn = redis.get().await?;

    redis::cmd("SET")
        .arg(&key)
        .arg(&value)
        .arg("EX")
        .arg(ttl)
        .query_async(&mut conn)
        .await?;

    Ok(())
}

// 获取流的 Publisher 节点
async fn get_stream_publisher(stream_key: &str) -> Result<Option<StreamPublisher>> {
    let key = format!("stream:publisher:{}", stream_key);

    let mut conn = redis.get().await?;

    let data: Option<String> = redis::cmd("GET")
        .arg(&key)
        .query_async(&mut conn)
        .await?;

    match data {
        Some(json) => Ok(Some(serde_json::from_str(&json)?)),
        None => Ok(None),
    }
}

// 更新流统计
async fn update_stream_stats(
    stream_key: &str,
    viewers: usize,
    bitrate: usize,
) -> Result<()> {
    let key = format!("stream:stats:{}", stream_key);

    let mut conn = redis.get().await?;

    redis::cmd("HSET")
        .arg(&key)
        .arg("viewers")
        .arg(viewers)
        .arg("bitrate")
        .arg(bitrate)
        .arg("updated_at")
        .arg(Utc::now().timestamp())
        .query_async(&mut conn)
        .await?;

    // 设置过期时间
    redis::cmd("EXPIRE")
        .arg(&key)
        .arg(600)  // 10分钟
        .query_async(&mut conn)
        .await?;

    Ok(())
}
```

### 5.1.3 房间在线人数

```
类型: String
键: room:viewers:{room_id}
值: 数字
TTL: 60秒
```

**操作**:

```rust
// 更新房间在线人数
async fn update_viewer_count(room_id: &str, count: usize) -> Result<()> {
    let key = format!("room:viewers:{}", room_id);  // room_id 是 nanoid(12)

    let mut conn = redis.get().await?;

    redis::cmd("SET")
        .arg(&key)
        .arg(count)
        .arg("EX")
        .arg(60)
        .query_async(&mut conn)
        .await?;

    Ok(())
}

// 获取房间在线人数
async fn get_viewer_count(room_id: &str) -> Result<usize> {
    let key = format!("room:viewers:{}", room_id);  // room_id 是 nanoid(12)

    let mut conn = redis.get().await?;

    let count: Option<usize> = redis::cmd("GET")
        .arg(&key)
        .query_async(&mut conn)
        .await?;

    Ok(count.unwrap_or(0))
}
```

### 5.1.4 Pub/Sub 消息总线

```
频道: cluster:events
消息格式: JSON {
  "event_id": "nanoid(12)",
  "node_id": "pod-synctv-0",
  "event": {...},
  "timestamp": 1706500000
}
```

**发布订阅**:

```rust
// 发布事件
async fn publish_event(event: ClusterEvent) -> Result<()> {
    let envelope = ClusterEventEnvelope {
        event_id: nanoid!(12),
        node_id: local_node_id(),
        event,
        timestamp: Utc::now().timestamp_millis(),
    };

    let json = serde_json::to_string(&envelope)?;

    let mut conn = redis.get().await?;

    let subscribers: usize = redis::cmd("PUBLISH")
        .arg("cluster:events")
        .arg(&json)
        .query_async(&mut conn)
        .await?;

    tracing::debug!(subscribers = subscribers, "Published event");

    Ok(())
}

// 订阅事件
async fn subscribe_events() -> Result<()> {
    let mut conn = redis.get().await?;
    let mut pubsub = conn.into_pubsub();

    pubsub.subscribe("cluster:events").await?;

    let mut stream = pubsub.on_message();

    while let Some(msg) = stream.next().await {
        let payload: String = msg.get_payload()?;
        let envelope: ClusterEventEnvelope = serde_json::from_str(&payload)?;

        // 处理事件
        handle_event(envelope).await;
    }

    Ok(())
}
```

## 5.2 本地缓存策略

### 5.2.1 LRU 缓存实现

```rust
// cache/local.rs
use lru::LruCache;
use std::num::NonZeroUsize;

pub struct LocalCache<K, V> {
    cache: Arc<Mutex<LruCache<K, V>>>,
}

impl<K: Hash + Eq, V: Clone> LocalCache<K, V> {
    pub fn new(capacity: usize) -> Self {
        Self {
            cache: Arc::new(Mutex::new(
                LruCache::new(NonZeroUsize::new(capacity).unwrap())
            )),
        }
    }

    pub fn get(&self, key: &K) -> Option<V> {
        self.cache.lock().unwrap().get(key).cloned()
    }

    pub fn put(&self, key: K, value: V) {
        self.cache.lock().unwrap().put(key, value);
    }

    pub fn remove(&self, key: &K) -> Option<V> {
        self.cache.lock().unwrap().pop(key)
    }

    pub fn clear(&self) {
        self.cache.lock().unwrap().clear();
    }

    pub fn len(&self) -> usize {
        self.cache.lock().unwrap().len()
    }
}
```

### 5.2.2 多级缓存

```rust
// cache/distributed.rs
pub struct DistributedCache<K, V> {
    local: LocalCache<K, V>,
    redis: deadpool_redis::Pool,
    ttl: Duration,
}

impl<K, V> DistributedCache<K, V>
where
    K: Hash + Eq + Display + Clone,
    V: Serialize + DeserializeOwned + Clone,
{
    pub fn new(
        local_capacity: usize,
        redis: deadpool_redis::Pool,
        ttl: Duration,
    ) -> Self {
        Self {
            local: LocalCache::new(local_capacity),
            redis,
            ttl,
        }
    }

    // 获取（L1 本地 → L2 Redis → L3 数据库）
    pub async fn get(&self, key: &K) -> Result<Option<V>> {
        // L1: 检查本地缓存
        if let Some(value) = self.local.get(key) {
            return Ok(Some(value));
        }

        // L2: 检查 Redis
        let redis_key = self.redis_key(key);
        let mut conn = self.redis.get().await?;

        let data: Option<String> = redis::cmd("GET")
            .arg(&redis_key)
            .query_async(&mut conn)
            .await?;

        if let Some(json) = data {
            let value: V = serde_json::from_str(&json)?;

            // 回填 L1
            self.local.put(key.clone(), value.clone());

            return Ok(Some(value));
        }

        Ok(None)
    }

    // 设置（同时更新 L1 和 L2）
    pub async fn set(&self, key: K, value: V) -> Result<()> {
        // 更新 L1
        self.local.put(key.clone(), value.clone());

        // 更新 L2
        let redis_key = self.redis_key(&key);
        let json = serde_json::to_string(&value)?;

        let mut conn = self.redis.get().await?;

        redis::cmd("SET")
            .arg(&redis_key)
            .arg(&json)
            .arg("EX")
            .arg(self.ttl.as_secs() as usize)
            .query_async(&mut conn)
            .await?;

        Ok(())
    }

    // 删除（同时删除 L1 和 L2）
    pub async fn delete(&self, key: &K) -> Result<()> {
        // 删除 L1
        self.local.remove(key);

        // 删除 L2
        let redis_key = self.redis_key(key);
        let mut conn = self.redis.get().await?;

        redis::cmd("DEL")
            .arg(&redis_key)
            .query_async(&mut conn)
            .await?;

        Ok(())
    }

    fn redis_key(&self, key: &K) -> String {
        format!("cache:{}", key)
    }
}
```

## 5.3 缓存一致性

### 5.3.1 Cache-Aside 模式

```rust
// 读取时
pub async fn get_room(&self, room_id: &str) -> Result<Room> {
    // 1. 尝试从缓存获取 (room_id 是 nanoid(12))
    if let Some(room) = self.cache.get(room_id).await? {
        return Ok(room);
    }

    // 2. 缓存未命中，查询数据库
    let room = self.db.get_room(room_id).await?
        .ok_or(Error::RoomNotFound)?;

    // 3. 写入缓存
    self.cache.set(room_id, room.clone()).await?;

    Ok(room)
}

// 更新时
pub async fn update_room(&self, room: Room) -> Result<()> {
    // 1. 更新数据库
    self.db.update_room(&room).await?;

    // 2. 删除缓存（下次读取时自动更新）
    self.cache.delete(&room.id).await?;

    Ok(())
}
```

### 5.3.2 Write-Through 模式

```rust
// 更新时同时更新数据库和缓存
pub async fn update_room_settings(
    &self,
    room_id: &str,  // nanoid(12)
    settings: RoomSettings,
) -> Result<()> {
    // 1. 更新数据库
    self.db.update_room_settings(room_id, &settings).await?;

    // 2. 更新缓存
    if let Some(mut room) = self.cache.get(room_id).await? {
        room.settings = settings;
        self.cache.set(room_id, room).await?;
    }

    Ok(())
}
```

### 5.3.3 缓存失效策略

#### 事件驱动失效

在多副本架构下，使用`ClusterEvent`触发缓存失效，保证所有副本缓存一致：

```rust
// 事件驱动的缓存失效
impl EventHandler for CacheInvalidator {
    async fn handle(&self, event: &ClusterEvent) -> Result<()> {
        match event {
            // 房间设置变更
            ClusterEvent::RoomSettingsChanged { room_id, .. } => {
                self.cache.delete(&format!("room:{}", room_id)).await?;
                tracing::debug!(room_id = %room_id, "Room cache invalidated");
            }

            // 房间删除
            ClusterEvent::RoomDeleted { room_id, .. } => {
                // 删除房间相关的所有缓存
                self.cache.delete(&format!("room:{}", room_id)).await?;
                self.cache.delete(&format!("movies:{}", room_id)).await?;
                self.cache.delete(&format!("room_state:{}", room_id)).await?;
                tracing::info!(room_id = %room_id, "All room caches invalidated");
            }

            // 房间更新（名称、描述等）
            ClusterEvent::RoomUpdated { room_id, .. } => {
                self.cache.delete(&format!("room:{}", room_id)).await?;
                tracing::debug!(room_id = %room_id, "Room info cache invalidated");
            }

            // 成员权限变更
            ClusterEvent::MemberPermissionsChanged { room_id, user_id, .. } => {
                let key = format!("member:{}:{}", room_id, user_id);
                self.cache.delete(&key).await?;
                tracing::debug!(
                    room_id = %room_id,
                    user_id = %user_id,
                    "Member permission cache invalidated"
                );
            }

            // 成员踢出
            ClusterEvent::MemberKicked { room_id, user_id, .. } => {
                let key = format!("member:{}:{}", room_id, user_id);
                self.cache.delete(&key).await?;
                tracing::debug!(
                    room_id = %room_id,
                    user_id = %user_id,
                    "Kicked member cache invalidated"
                );
            }

            // 影片列表变更
            ClusterEvent::MovieListChanged { room_id, .. } => {
                self.cache.delete(&format!("movies:{}", room_id)).await?;
                tracing::debug!(room_id = %room_id, "Movie list cache invalidated");
            }

            // 流停止
            ClusterEvent::StreamStopped { stream_key, .. } => {
                self.cache.delete(&format!("stream:{}", stream_key)).await?;
                tracing::debug!(stream_key = %stream_key, "Stream cache invalidated");
            }

            _ => {
                // 其他事件不需要缓存失效
            }
        }

        Ok(())
    }
}
```

#### 缓存失效场景

| 事件 | 失效缓存键 | 说明 |
|------|----------|------|
| `RoomSettingsChanged` | `room:{room_id}` | 房间设置修改 |
| `RoomDeleted` | `room:{room_id}`<br>`movies:{room_id}`<br>`room_state:{room_id}` | 房间删除，清理所有相关缓存 |
| `RoomUpdated` | `room:{room_id}` | 房间基本信息修改 |
| `MemberPermissionsChanged` | `member:{room_id}:{user_id}` | 成员权限修改 |
| `MemberKicked` | `member:{room_id}:{user_id}` | 成员被踢出 |
| `MovieListChanged` | `movies:{room_id}` | 影片列表修改 |
| `StreamStopped` | `stream:{stream_key}` | 直播流停止 |

**注意**：所有 ID（room_id、user_id 等）均为 nanoid(12) 字符串。

#### 批量失效优化

对于影响多个用户的操作，使用批量失效：

```rust
impl CacheInvalidator {
    /// 批量失效房间成员缓存
    pub async fn invalidate_room_members(
        &self,
        room_id: &str,  // nanoid(12)
        member_ids: Vec<String>,  // nanoid(12)
    ) -> Result<()> {
        let mut pipeline = redis::pipe();

        for user_id in member_ids {
            let key = format!("member:{}:{}", room_id, user_id);
            pipeline.del(&key);
        }

        let mut conn = self.redis.get().await?;
        pipeline.query_async(&mut conn).await?;

        tracing::info!(
            room_id = %room_id,
            count = member_ids.len(),
            "Batch invalidated member caches"
        );

        Ok(())
    }

    /// 失效房间的所有相关缓存
    pub async fn invalidate_room_all(&self, room_id: &str) -> Result<()> {
        let keys = vec![
            format!("room:{}", room_id),
            format!("movies:{}", room_id),
            format!("room_state:{}", room_id),
        ];

        let mut conn = self.redis.get().await?;
        redis::cmd("DEL")
            .arg(&keys)
            .query_async(&mut conn)
            .await?;

        tracing::info!(
            room_id = %room_id,
            "Invalidated all room caches"
        );

        Ok(())
    }
}
```

#### 缓存一致性保证

**写操作流程**：

1. 更新数据库
2. 删除缓存（Cache-Aside）
3. 发布ClusterEvent（通知其他副本）

**示例：更新房间设置**

```rust
impl RoomService {
    pub async fn update_settings(
        &self,
        room_id: &str,  // nanoid(12)
        settings: RoomSettings,
    ) -> Result<()> {
        // 1. 更新数据库
        self.room_repo.update_settings(room_id, &settings).await?;

        // 2. 删除本地缓存
        self.cache.delete(&format!("room:{}", room_id)).await?;

        // 3. 发布集群事件（触发其他副本失效缓存）
        self.cluster_sync.publish(ClusterEvent::RoomUpdated {
            room_id: room_id.to_string(),
            fields_changed: vec!["settings".to_string()],
        }).await?;

        Ok(())
    }
}
```

#### 设计要点

**最终一致性**：

- 使用删除而非更新缓存（避免并发更新冲突）
- ClusterEvent通过Redis Pub/Sub传播（延迟<100ms）
- 下次读取时自动从数据库加载最新数据

**事件顺序**：

- 先写数据库，后删缓存（保证数据持久化）
- 即使缓存失效失败，下次读取时也会获取到新数据

**性能优化**：

- 批量失效减少Redis往返次数
- 只失效受影响的缓存键，不全局清理

## 5.4 缓存预热

```rust
// 启动时预热常用数据
pub async fn warmup_cache(&self) -> Result<()> {
    tracing::info!("Warming up cache...");

    // 1. 预热活跃房间
    let active_rooms = self.db.get_active_rooms(100).await?;
    for room in active_rooms {
        self.cache.set(&room.id, room).await?;
    }

    // 2. 预热在线流
    let online_streams = self.db.get_online_streams().await?;
    for stream in online_streams {
        let key = format!("stream:{}", stream.stream_key);
        self.cache.set(&key, stream).await?;
    }

    tracing::info!("Cache warmup completed");
    Ok(())
}
```

## 5.5 缓存淘汰

### 5.5.1 TTL 自动过期

```rust
// Redis 自动 TTL
redis::cmd("SET")
    .arg(key)
    .arg(value)
    .arg("EX")
    .arg(300)  // 5 分钟后自动过期
    .query_async(&mut conn)
    .await?;
```

### 5.5.2 LRU 淘汰

```rust
// 本地缓存使用 LRU，自动淘汰最久未使用的数据
let cache = LruCache::new(NonZeroUsize::new(1000).unwrap());
```

### 5.5.3 主动清理

```rust
// 定期清理过期数据
pub async fn cleanup_expired_cache() -> Result<()> {
    let mut conn = redis.get().await?;

    // 清理过期节点
    let cutoff = Utc::now().timestamp() - 60;
    redis::cmd("ZREMRANGEBYSCORE")
        .arg("cluster:nodes:active")
        .arg("-inf")
        .arg(cutoff)
        .query_async(&mut conn)
        .await?;

    Ok(())
}

// 启动定期清理任务
tokio::spawn(async {
    let mut interval = tokio::time::interval(Duration::from_secs(60));

    loop {
        interval.tick().await;

        if let Err(e) = cleanup_expired_cache().await {
            tracing::error!(error = ?e, "Failed to cleanup cache");
        }
    }
});
```

## 5.6 弹幕内存缓存（特殊设计）

```rust
// danmaku/cache.rs
use std::collections::VecDeque;
use dashmap::DashMap;

/// 弹幕内存缓存（用于新用户加入时快速同步）
pub struct DanmakuCache {
    cache: Arc<DashMap<String, RwLock<VecDeque<Danmaku>>>>,  // room_id(nanoid) -> 弹幕队列
    max_duration: Duration,  // 最多缓存10秒的弹幕
}

impl DanmakuCache {
    pub fn new() -> Self {
        Self {
            cache: Arc::new(DashMap::new()),
            max_duration: Duration::from_secs(10),
        }
    }

    /// 添加弹幕到缓存
    pub async fn add(&self, room_id: &str, danmaku: Danmaku) {  // room_id 是 nanoid(12)
        let queue = self.cache
            .entry(room_id.to_string())
            .or_insert_with(|| RwLock::new(VecDeque::new()));

        let mut queue = queue.write().await;
        queue.push_back(danmaku);

        // 清理过期弹幕（超过10秒）
        let now = Utc::now().timestamp_millis();
        let cutoff = now - self.max_duration.as_millis() as i64;

        while let Some(front) = queue.front() {
            if front.send_time < cutoff {
                queue.pop_front();
            } else {
                break;
            }
        }

        // 限制队列大小（最多100条）
        while queue.len() > 100 {
            queue.pop_front();
        }
    }

    /// 获取最近的弹幕（用于新用户加入）
    pub async fn get_recent(&self, room_id: &str) -> Vec<Danmaku> {  // room_id 是 nanoid(12)
        if let Some(queue) = self.cache.get(room_id) {
            let queue = queue.read().await;
            queue.iter().cloned().collect()
        } else {
            Vec::new()
        }
    }

    /// 清空房间缓存
    pub fn clear(&self, room_id: &str) {  // room_id 是 nanoid(12)
        self.cache.remove(room_id);
    }
}
```

## 5.7 缓存监控

```rust
// cache/metrics.rs
pub struct CacheMetrics {
    hit_count: AtomicU64,
    miss_count: AtomicU64,
    error_count: AtomicU64,
}

impl CacheMetrics {
    pub fn record_hit(&self) {
        self.hit_count.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_miss(&self) {
        self.miss_count.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_error(&self) {
        self.error_count.fetch_add(1, Ordering::Relaxed);
    }

    pub fn hit_rate(&self) -> f64 {
        let hits = self.hit_count.load(Ordering::Relaxed);
        let misses = self.miss_count.load(Ordering::Relaxed);
        let total = hits + misses;

        if total == 0 {
            0.0
        } else {
            hits as f64 / total as f64
        }
    }

    pub fn get_stats(&self) -> CacheStats {
        CacheStats {
            hits: self.hit_count.load(Ordering::Relaxed),
            misses: self.miss_count.load(Ordering::Relaxed),
            errors: self.error_count.load(Ordering::Relaxed),
            hit_rate: self.hit_rate(),
        }
    }
}
```

## 5.8 总结

### 缓存层次

1. **L1 本地缓存**（LRU）
   - 容量：1000-10000 项
   - TTL：内存淘汰策略
   - 用途：热点数据

2. **L2 Redis 缓存**
   - TTL：5-30 分钟
   - 用途：分布式共享数据

3. **L3 数据库**
   - 持久化存储
   - 最终数据源

### ID 设计

- **统一使用 nanoid(12)**：所有实体 ID（room_id、user_id 等）直接使用 nanoid(12) 字符串
- **无需转换**：数据库、缓存、API 全链路使用相同格式
- **类型**：所有 ID 字段使用 `String` 类型

### 特殊缓存

- **弹幕缓存**：仅内存、10秒、最多100条
- **聊天记录**：数据库、最近500条、自动清理

### 性能特点

- 多级缓存提高命中率
- 事件驱动失效保证一致性
- 自动清理避免内存泄漏
- 监控指标支持性能优化

---

**上一章**: [04-数据库设计](./04-数据库设计.md)
**下一章**: [06-用户系统设计](./08-视频内容管理.md)
