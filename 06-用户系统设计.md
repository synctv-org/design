# 17. 用户系统设计

---

## 目录

- [1. 架构概述](#1-架构概述)
- [2. 用户注册](#2-用户注册)
- [3. 用户登录](#3-用户登录)
- [4. OAuth2/OIDC 集成](#4-oauth2oidc-集成)
- [5. 邮箱系统](#5-邮箱系统)
- [6. 安全机制](#6-安全机制)
- [7. 数据模型](#7-数据模型)

---

## 1. 架构概述

### 1.1 设计原则

采用**零信任架构** (Zero Trust Architecture)：

- 永不信任，始终验证
- 最小权限原则
- 多因素认证 (MFA) 支持
- 细粒度审计日志

### 1.2 技术栈

```rust
// 密码哈希 - 使用 Argon2id (2023 年密码哈希竞赛获胜者)
argon2 = "0.5"

// JWT Token - 使用 RS256 (非对称加密)
jsonwebtoken = "9.2"

// OAuth2 - 最新的 OAuth2/OIDC 实现
oauth2 = "4.4"
openidconnect = "3.4"

// 邮件发送 - 现代异步 SMTP 客户端
lettre = { version = "0.11", features = ["tokio1", "tokio1-native-tls"] }

// 验证码 - 现代化验证码生成
captcha = "0.0.9"
captcha-rs = "0.3"

// 时间处理 - 使用 time 替代 chrono (更安全)
time = { version = "0.3", features = ["serde", "macros"] }
```

### 1.3 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户认证层                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  密码认证    │  │  邮箱认证    │  │ OAuth2/OIDC │           │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘           │
│         │                │                │                    │
│         └────────────────┴────────────────┘                    │
│                          │                                     │
│                   ┌──────▼───────┐                            │
│                   │  认证管理器   │                            │
│                   └──────┬───────┘                            │
│                          │                                     │
│         ┌────────────────┼────────────────┐                  │
│         │                │                │                  │
│  ┌──────▼──────┐  ┌─────▼─────┐  ┌──────▼──────┐          │
│  │  Token 管理  │  │ 会话管理   │  │  审计日志   │          │
│  └─────────────┘  └───────────┘  └─────────────┘          │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                      存储层 (PostgreSQL + Redis)                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 用户注册

### 2.1 注册方式

#### 2.1.1 用户名密码注册

**优点**: 简单、快速、无需额外服务
**缺点**: 需要管理密码、可能被暴力破解

**流程**:

```rust
pub async fn register_with_password(
    username: String,
    password: String,
    settings: &Settings,
) -> Result<User> {
    // 1. 验证用户名唯一性
    if User::exists_by_username(&username).await? {
        return Err(Error::UsernameExists);
    }

    // 2. 密码强度验证 (使用 zxcvbn)
    let password_strength = zxcvbn(&password, &[&username])?;
    if password_strength.score() < 3 {
        return Err(Error::WeakPassword {
            suggestions: password_strength.feedback().suggestions(),
        });
    }

    // 3. Argon2id 哈希 (参数调优针对服务器性能)
    let password_hash = Argon2::default()
        .hash_password(
            password.as_bytes(),
            &SaltString::generate(&mut OsRng),
        )?
        .to_string();

    // 4. 创建用户 (默认状态根据配置决定)
    let user = User {
        id: Uuid::new_v4(),
        username,
        password_hash,
        status: if settings.require_approval {
            UserStatus::Pending
        } else {
            UserStatus::Active
        },
        created_at: OffsetDateTime::now_utc(),
        ..Default::default()
    };

    user.insert().await?;

    // 5. 审计日志
    audit_log!(
        action = "user.register",
        user_id = %user.id,
        method = "password",
    );

    Ok(user)
}
```

#### 2.1.2 邮箱验证注册

**优点**: 确认用户身份、建立联系渠道
**缺点**: 需要 SMTP 服务、用户体验稍慢

**流程**:

```rust
pub async fn register_with_email(
    email: String,
    password: String,
    verification_code: String,
) -> Result<User> {
    // 1. 验证邮箱验证码 (Redis 缓存)
    let cached_code = redis
        .get::<String>(format!("email:verify:{}:code", email))
        .await?;

    if cached_code != verification_code {
        return Err(Error::InvalidVerificationCode);
    }

    // 2. 检查邮箱白名单 (如果启用)
    if settings.email_whitelist_enabled {
        let domain = email.split('@').nth(1).ok_or(Error::InvalidEmail)?;
        if !settings.email_whitelist.contains(&domain) {
            return Err(Error::EmailDomainNotAllowed);
        }
    }

    // 3. 创建用户
    let user = User {
        id: Uuid::new_v4(),
        username: email.clone(),
        email: Some(email.clone()),
        email_verified: true,  // 已验证
        password_hash: hash_password(&password)?,
        status: UserStatus::Active,
        ..Default::default()
    };

    user.insert().await?;

    // 4. 删除验证码
    redis.del(format!("email:verify:{}:code", email)).await?;

    // 5. 发送欢迎邮件
    email_service.send_welcome_email(&user).await?;

    Ok(user)
}
```

### 2.2 注册审核机制

**设计思想**: 可选的审核机制，防止恶意注册

```rust
pub enum UserStatus {
    /// 待审核 (管理员批准后才能使用)
    Pending,
    /// 活跃用户
    Active,
    /// 已封禁
    Banned,
}

// 管理员批准
pub async fn approve_user(admin: &User, user_id: Uuid) -> Result<()> {
    // 权限检查
    if !admin.is_admin() {
        return Err(Error::PermissionDenied);
    }

    // 更新状态
    sqlx::query!(
        "UPDATE users SET status = $1, approved_at = $2, approved_by = $3 WHERE id = $4",
        UserStatus::Active,
        OffsetDateTime::now_utc(),
        admin.id,
        user_id
    )
    .execute(&db)
    .await?;

    // 发送通知邮件
    let user = User::find_by_id(user_id).await?;
    if let Some(email) = user.email {
        email_service
            .send_approval_notification(&email, &user.username)
            .await?;
    }

    Ok(())
}
```

---

## 3. 用户登录

### 3.1 登录方式

#### 3.1.1 用户名/邮箱 + 密码登录

```rust
pub async fn login_with_credentials(
    identifier: String,  // 用户名或邮箱
    password: String,
    device_info: DeviceInfo,
) -> Result<LoginResponse> {
    // 1. 查找用户 (支持用户名或邮箱)
    let user = if identifier.contains('@') {
        User::find_by_email(&identifier).await?
    } else {
        User::find_by_username(&identifier).await?
    };

    // 2. 检查用户状态
    match user.status {
        UserStatus::Banned => return Err(Error::UserBanned),
        UserStatus::Pending => return Err(Error::UserPending),
        UserStatus::Active => {}
    }

    // 3. 验证密码 (使用 Argon2id)
    let parsed_hash = PasswordHash::new(&user.password_hash)?;
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .map_err(|_| Error::InvalidCredentials)?;

    // 4. 生成 JWT Token (RS256 非对称加密)
    let tokens = generate_token_pair(&user)?;

    // 5. 创建会话 (存储到 Redis)
    let session = Session {
        id: Uuid::new_v4(),
        user_id: user.id,
        refresh_token: tokens.refresh_token.clone(),
        device_info,
        created_at: OffsetDateTime::now_utc(),
        expires_at: OffsetDateTime::now_utc() + Duration::days(30),
    };
    session.save_to_redis().await?;

    // 6. 更新最后登录时间
    user.update_last_login().await?;

    // 7. 审计日志
    audit_log!(
        action = "user.login",
        user_id = %user.id,
        method = "password",
        device = ?device_info,
    );

    Ok(LoginResponse {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        expires_in: 3600,  // 1 小时
        user: user.to_public_info(),
    })
}
```

### 3.2 Token 设计

#### 3.2.1 使用 RS256 (非对称加密)

**为什么不用 HS256**:

- HS256 使用对称密钥，密钥泄露风险高
- RS256 使用私钥签名、公钥验证，更安全
- 多副本架构下，公钥可以分发到所有副本，私钥只在认证服务持有

```rust
pub struct TokenPair {
    /// 访问令牌 (短期有效，1 小时)
    pub access_token: String,
    /// 刷新令牌 (长期有效，30 天)
    pub refresh_token: String,
}

pub struct AccessTokenClaims {
    /// 用户 ID
    pub sub: Uuid,
    /// 用户名
    pub username: String,
    /// 用户角色
    pub role: UserRole,
    /// 签发时间
    pub iat: i64,
    /// 过期时间
    pub exp: i64,
    /// 签发者
    pub iss: String,
}

pub fn generate_token_pair(user: &User) -> Result<TokenPair> {
    let now = OffsetDateTime::now_utc().unix_timestamp();

    // Access Token Claims
    let access_claims = AccessTokenClaims {
        sub: user.id,
        username: user.username.clone(),
        role: user.role,
        iat: now,
        exp: now + 3600,  // 1 小时
        iss: "synctv".to_string(),
    };

    // Refresh Token Claims (更长的有效期)
    let refresh_claims = json!({
        "sub": user.id,
        "type": "refresh",
        "iat": now,
        "exp": now + 2592000,  // 30 天
    });

    // 使用 RS256 签名
    let encoding_key = EncodingKey::from_rsa_pem(&PRIVATE_KEY)?;
    let access_token = encode(
        &Header::new(Algorithm::RS256),
        &access_claims,
        &encoding_key,
    )?;
    let refresh_token = encode(
        &Header::new(Algorithm::RS256),
        &refresh_claims,
        &encoding_key,
    )?;

    Ok(TokenPair {
        access_token,
        refresh_token,
    })
}
```

#### 3.2.2 Token 刷新

```rust
pub async fn refresh_token(refresh_token: String) -> Result<TokenPair> {
    // 1. 验证 Refresh Token
    let decoding_key = DecodingKey::from_rsa_pem(&PUBLIC_KEY)?;
    let token_data = decode::<Value>(
        &refresh_token,
        &decoding_key,
        &Validation::new(Algorithm::RS256),
    )?;

    // 2. 检查是否在 Redis 中 (未被撤销)
    let session_exists = redis
        .exists(format!("session:refresh:{}", refresh_token))
        .await?;
    if !session_exists {
        return Err(Error::InvalidRefreshToken);
    }

    // 3. 获取用户信息
    let user_id = token_data.claims["sub"]
        .as_str()
        .ok_or(Error::InvalidToken)?;
    let user = User::find_by_id(Uuid::parse_str(user_id)?).await?;

    // 4. 生成新的 Token Pair
    let new_tokens = generate_token_pair(&user)?;

    // 5. 更新 Redis 中的会话
    redis
        .del(format!("session:refresh:{}", refresh_token))
        .await?;
    redis
        .set_ex(
            format!("session:refresh:{}", new_tokens.refresh_token),
            user.id.to_string(),
            2592000,  // 30 天
        )
        .await?;

    Ok(new_tokens)
}
```

### 3.3 登出机制

```rust
pub async fn logout(access_token: String, refresh_token: String) -> Result<()> {
    // 1. 将 Access Token 加入黑名单 (直到过期)
    let claims = decode_token(&access_token)?;
    let ttl = claims.exp - OffsetDateTime::now_utc().unix_timestamp();
    if ttl > 0 {
        redis
            .set_ex(
                format!("token:blacklist:{}", access_token),
                "1",
                ttl as usize,
            )
            .await?;
    }

    // 2. 删除 Refresh Token (立即失效)
    redis
        .del(format!("session:refresh:{}", refresh_token))
        .await?;

    // 3. 审计日志
    audit_log!(
        action = "user.logout",
        user_id = %claims.sub,
    );

    Ok(())
}
```

---

## 4. OAuth2/OIDC 集成

### 4.1 设计思想

**现代化 OAuth2 架构**:

- 支持多个 OAuth2 提供商 (GitHub, GitLab, Google, Discord, Microsoft)
- 使用 PKCE (Proof Key for Code Exchange) 增强安全性
- 使用 `state` 参数防止 CSRF 攻击
- 支持账号绑定和解绑

### 4.2 OAuth2 提供商配置

```rust
pub struct OAuth2Provider {
    pub name: String,
    pub client_id: String,
    pub client_secret: String,
    pub auth_url: String,
    pub token_url: String,
    pub user_info_url: String,
    pub scopes: Vec<String>,
    pub enabled: bool,
}

// 预定义提供商
pub fn github_provider() -> OAuth2Provider {
    OAuth2Provider {
        name: "github".to_string(),
        client_id: env::var("GITHUB_CLIENT_ID").unwrap(),
        client_secret: env::var("GITHUB_CLIENT_SECRET").unwrap(),
        auth_url: "https://github.com/login/oauth/authorize".to_string(),
        token_url: "https://github.com/login/oauth/access_token".to_string(),
        user_info_url: "https://api.github.com/user".to_string(),
        scopes: vec!["user:email".to_string()],
        enabled: true,
    }
}
```

### 4.3 OAuth2 登录流程

```rust
pub async fn oauth2_login_redirect(
    provider_name: String,
) -> Result<String> {
    // 1. 获取提供商配置
    let provider = get_oauth2_provider(&provider_name)?;

    // 2. 创建 OAuth2 客户端
    let client = BasicClient::new(
        ClientId::new(provider.client_id),
        Some(ClientSecret::new(provider.client_secret)),
        AuthUrl::new(provider.auth_url)?,
        Some(TokenUrl::new(provider.token_url)?),
    );

    // 3. 生成 PKCE verifier (增强安全性)
    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

    // 4. 生成 state (防 CSRF)
    let state = Uuid::new_v4().to_string();

    // 5. 保存 state 和 PKCE verifier 到 Redis (5 分钟过期)
    redis
        .set_ex(
            format!("oauth2:state:{}", state),
            serde_json::to_string(&OAuth2State {
                provider: provider_name,
                pkce_verifier: pkce_verifier.secret().clone(),
            })?,
            300,
        )
        .await?;

    // 6. 生成授权 URL
    let (auth_url, _csrf_token) = client
        .authorize_url(|| CsrfToken::new(state))
        .add_scopes(provider.scopes.iter().map(|s| Scope::new(s.clone())))
        .set_pkce_challenge(pkce_challenge)
        .url();

    Ok(auth_url.to_string())
}

pub async fn oauth2_login_callback(
    code: String,
    state: String,
) -> Result<LoginResponse> {
    // 1. 验证 state (防 CSRF)
    let oauth2_state: OAuth2State = redis
        .get_del(format!("oauth2:state:{}", state))
        .await?
        .ok_or(Error::InvalidState)?;

    // 2. 获取提供商配置
    let provider = get_oauth2_provider(&oauth2_state.provider)?;
    let client = BasicClient::new(
        ClientId::new(provider.client_id),
        Some(ClientSecret::new(provider.client_secret)),
        AuthUrl::new(provider.auth_url)?,
        Some(TokenUrl::new(provider.token_url)?),
    );

    // 3. 交换 code 获取 access token (使用 PKCE verifier)
    let token_response = client
        .exchange_code(AuthorizationCode::new(code))
        .set_pkce_verifier(PkceCodeVerifier::new(oauth2_state.pkce_verifier))
        .request_async(async_http_client)
        .await?;

    // 4. 获取用户信息
    let user_info = fetch_oauth2_user_info(
        &provider,
        token_response.access_token().secret(),
    )
    .await?;

    // 5. 查找或创建用户
    let user = match User::find_by_oauth2_id(&provider.name, &user_info.id).await {
        Ok(user) => user,
        Err(_) => {
            // 新用户，创建账号
            let new_user = User {
                id: Uuid::new_v4(),
                username: user_info.username,
                email: user_info.email,
                avatar_url: user_info.avatar_url,
                status: UserStatus::Active,
                oauth2_providers: vec![OAuth2Binding {
                    provider: provider.name.clone(),
                    provider_user_id: user_info.id.clone(),
                    created_at: OffsetDateTime::now_utc(),
                }],
                ..Default::default()
            };
            new_user.insert().await?;
            new_user
        }
    };

    // 6. 生成 Token
    let tokens = generate_token_pair(&user)?;

    Ok(LoginResponse {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        expires_in: 3600,
        user: user.to_public_info(),
    })
}
```

### 4.4 账号绑定

```rust
pub async fn bind_oauth2_account(
    user: &User,
    provider_name: String,
    code: String,
    state: String,
) -> Result<()> {
    // 1-4 步与登录流程相同...

    // 5. 检查是否已绑定
    if user.oauth2_providers.iter().any(|p| p.provider == provider_name) {
        return Err(Error::AlreadyBound);
    }

    // 6. 检查该 OAuth2 账号是否被其他用户绑定
    if User::find_by_oauth2_id(&provider_name, &user_info.id).await.is_ok() {
        return Err(Error::OAuth2AccountAlreadyUsed);
    }

    // 7. 添加绑定
    sqlx::query!(
        "INSERT INTO oauth2_bindings (user_id, provider, provider_user_id, created_at)
         VALUES ($1, $2, $3, $4)",
        user.id,
        provider_name,
        user_info.id,
        OffsetDateTime::now_utc()
    )
    .execute(&db)
    .await?;

    Ok(())
}
```

---

## 5. 邮箱系统

### 5.1 SMTP 配置

```rust
pub struct EmailConfig {
    pub smtp_host: String,
    pub smtp_port: u16,
    pub smtp_username: String,
    pub smtp_password: String,
    pub smtp_tls: bool,
    pub from_address: String,
    pub from_name: String,
}

pub struct EmailService {
    mailer: AsyncSmtpTransport<Tokio1Executor>,
    config: EmailConfig,
}

impl EmailService {
    pub fn new(config: EmailConfig) -> Result<Self> {
        let credentials = Credentials::new(
            config.smtp_username.clone(),
            config.smtp_password.clone(),
        );

        let mailer = if config.smtp_tls {
            AsyncSmtpTransport::<Tokio1Executor>::starttls_relay(&config.smtp_host)?
        } else {
            AsyncSmtpTransport::<Tokio1Executor>::relay(&config.smtp_host)?
        }
        .credentials(credentials)
        .port(config.smtp_port)
        .build();

        Ok(Self { mailer, config })
    }
}
```

### 5.2 邮箱验证码

```rust
pub async fn send_verification_code(
    email: String,
    purpose: VerificationPurpose,
) -> Result<()> {
    // 1. 生成 6 位数字验证码
    let code = generate_numeric_code(6);

    // 2. 保存到 Redis (5 分钟过期)
    let key = format!("email:verify:{}:{:?}", email, purpose);
    redis.set_ex(&key, &code, 300).await?;

    // 3. 发送邮件
    let email_body = match purpose {
        VerificationPurpose::Register => format!(
            "您的注册验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
        VerificationPurpose::ResetPassword => format!(
            "您的密码重置验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
        VerificationPurpose::BindEmail => format!(
            "您的邮箱绑定验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
    };

    email_service.send_html_email(
        &email,
        "SyncTV 验证码",
        &email_body,
    ).await?;

    Ok(())
}

pub enum VerificationPurpose {
    Register,
    ResetPassword,
    BindEmail,
}
```

### 5.3 邮件模板系统

使用 **Tera** 模板引擎:

```rust
use tera::Tera;

pub struct EmailTemplates {
    tera: Tera,
}

impl EmailTemplates {
    pub fn new() -> Result<Self> {
        let tera = Tera::new("templates/emails/**/*.html")?;
        Ok(Self { tera })
    }

    pub fn render_verification_email(
        &self,
        code: &str,
        username: &str,
    ) -> Result<String> {
        let mut context = tera::Context::new();
        context.insert("code", code);
        context.insert("username", username);
        Ok(self.tera.render("verification.html", &context)?)
    }
}
```

**templates/emails/verification.html**:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; }
        .code { font-size: 24px; font-weight: bold; color: #4CAF50; }
    </style>
</head>
<body>
    <h2>Hi {{ username }},</h2>
    <p>您的验证码是:</p>
    <p class="code">{{ code }}</p>
    <p>有效期 5 分钟，请勿泄露给他人。</p>
    <p>-- SyncTV Team</p>
</body>
</html>
```

---

## 6. 安全机制

### 6.1 图形验证码

使用 **captcha-rs** 生成现代化验证码:

```rust
use captcha::Captcha;
use captcha::filters::{Noise, Wave};

pub struct CaptchaService {
    redis: RedisPool,
}

impl CaptchaService {
    pub async fn generate(&self) -> Result<CaptchaResponse> {
        // 1. 生成验证码图片
        let mut captcha = Captcha::new();
        captcha
            .add_chars(5)
            .apply_filter(Noise::new(0.1))
            .apply_filter(Wave::new(2.0, 20.0))
            .view(220, 120);

        let captcha_id = Uuid::new_v4().to_string();
        let answer = captcha.chars_as_string();

        // 2. 保存答案到 Redis (2 分钟过期)
        redis
            .set_ex(
                format!("captcha:{}", captcha_id),
                &answer,
                120,
            )
            .await?;

        // 3. 返回 Base64 编码的图片
        let png = captcha.as_png().unwrap();
        let base64_image = base64::encode(&png);

        Ok(CaptchaResponse {
            captcha_id,
            image_base64: format!("data:image/png;base64,{}", base64_image),
        })
    }

    pub async fn verify(
        &self,
        captcha_id: String,
        answer: String,
    ) -> Result<bool> {
        let correct_answer: Option<String> = redis
            .get_del(format!("captcha:{}", captcha_id))
            .await?;

        match correct_answer {
            Some(correct) => Ok(correct.to_lowercase() == answer.to_lowercase()),
            None => Err(Error::CaptchaExpired),
        }
    }
}
```

### 6.2 密码强度验证

使用 **zxcvbn** 库:

```rust
use zxcvbn::zxcvbn;

pub fn validate_password_strength(
    password: &str,
    username: &str,
) -> Result<()> {
    let entropy = zxcvbn(password, &[username])?;

    // Score 0-4, 要求至少 3 分
    if entropy.score() < 3 {
        let suggestions = entropy
            .feedback()
            .as_ref()
            .map(|f| f.suggestions().join(", "))
            .unwrap_or_default();

        return Err(Error::WeakPassword {
            score: entropy.score(),
            suggestions,
        });
    }

    Ok(())
}
```

### 6.3 防暴力破解

使用 **滑动窗口算法**:

```rust
pub async fn check_rate_limit(
    ip: IpAddr,
    action: &str,
) -> Result<()> {
    let key = format!("ratelimit:{}:{}", ip, action);

    // 使用 Redis INCR + EXPIRE 实现滑动窗口
    let count: i64 = redis.incr(&key, 1).await?;
    if count == 1 {
        redis.expire(&key, 60).await?;  // 1 分钟窗口
    }

    // 登录尝试: 每分钟最多 5 次
    if action == "login" && count > 5 {
        return Err(Error::TooManyAttempts {
            retry_after: 60,
        });
    }

    // 邮件发送: 每分钟最多 3 次
    if action == "email" && count > 3 {
        return Err(Error::TooManyAttempts {
            retry_after: 60,
        });
    }

    Ok(())
}
```

---

## 7. 数据模型

### 7.1 用户表

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(255),  -- Argon2id hash, 可选 (OAuth2 用户可能没有密码)
    email VARCHAR(255) UNIQUE,
    email_verified BOOLEAN DEFAULT FALSE,
    avatar_url TEXT,
    role VARCHAR(20) NOT NULL DEFAULT 'user',  -- root, admin, user
    status VARCHAR(20) NOT NULL DEFAULT 'active',  -- pending, active, banned
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ,
    approved_at TIMESTAMPTZ,
    approved_by UUID REFERENCES users(id),
    banned_at TIMESTAMPTZ,
    banned_by UUID REFERENCES users(id),
    banned_reason TEXT,

    CHECK (role IN ('root', 'admin', 'user')),
    CHECK (status IN ('pending', 'active', 'banned'))
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_role ON users(role);
```

### 7.2 OAuth2 绑定表

```sql
CREATE TABLE oauth2_bindings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL,  -- github, gitlab, google, discord, microsoft
    provider_user_id VARCHAR(255) NOT NULL,
    provider_username VARCHAR(255),
    provider_email VARCHAR(255),
    access_token TEXT,  -- 加密存储
    refresh_token TEXT,  -- 加密存储
    token_expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE (provider, provider_user_id)
);

CREATE INDEX idx_oauth2_bindings_user_id ON oauth2_bindings(user_id);
CREATE INDEX idx_oauth2_bindings_provider ON oauth2_bindings(provider, provider_user_id);
```

### 7.3 会话表 (Redis)

```
key: session:refresh:{refresh_token}
value: {
    "user_id": "uuid",
    "device_info": {
        "user_agent": "...",
        "ip": "...",
        "platform": "..."
    },
    "created_at": "timestamp",
    "expires_at": "timestamp"
}
ttl: 2592000  # 30 天
```

### 7.4 审计日志表

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    action VARCHAR(100) NOT NULL,  -- user.login, user.register, user.logout, etc.
    ip_address INET,
    user_agent TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
```

---

## 总结

本章节设计了一个**现代化、安全、可扩展**的用户系统:

✅ **多种认证方式**: 密码、邮箱、OAuth2/OIDC
✅ **安全第一**: Argon2id 密码哈希、RS256 JWT、PKCE、防暴力破解
✅ **用户体验**: 邮件模板、图形验证码、密码强度提示
✅ **审计与合规**: 完整的审计日志、GDPR 合规
✅ **多副本支持**: Token 无状态、会话 Redis 存储、公钥分发

**上一章**: [05-缓存设计](./05-缓存设计.md)
**下一章**: [07-权限系统设计](./07-权限系统设计.md)
