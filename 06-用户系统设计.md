# 17. 用户系统设计

---

## 目录

- [1. 架构概述](#1-架构概述)
- [2. 用户注册](#2-用户注册)
- [3. 用户登录](#3-用户登录)
- [4. OAuth2/OIDC 集成](#4-oauth2oidc-集成)
- [5. 邮箱系统](#5-邮箱系统)
- [6. 安全机制](#6-安全机制)
- [7. 数据模型](#7-数据模型)

---

## 1. 架构概述

### 1.1 设计原则

采用**零信任架构** (Zero Trust Architecture)：

- 永不信任，始终验证
- 最小权限原则
- 多因素认证 (MFA) 支持
- 细粒度审计日志

### 1.2 技术栈

```rust
// 密码哈希 - 使用 Argon2id (2023 年密码哈希竞赛获胜者)
argon2 = "0.5"

// JWT Token - 使用 RS256 (非对称加密)
jsonwebtoken = "9.2"

// OAuth2 - 最新的 OAuth2/OIDC 实现
oauth2 = "4.4"
openidconnect = "3.4"

// 邮件发送 - 现代异步 SMTP 客户端
lettre = { version = "0.11", features = ["tokio1", "tokio1-native-tls"] }

// 验证码 - 现代化验证码生成
captcha = "0.0.9"
captcha-rs = "0.3"

// 时间处理 - 使用 time 替代 chrono (更安全)
time = { version = "0.3", features = ["serde", "macros"] }
```

### 1.3 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户认证层                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  密码认证    │  │  邮箱认证    │  │ OAuth2/OIDC │           │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘           │
│         │                │                │                    │
│         └────────────────┴────────────────┘                    │
│                          │                                     │
│                   ┌──────▼───────┐                            │
│                   │  认证管理器   │                            │
│                   └──────┬───────┘                            │
│                          │                                     │
│         ┌────────────────┼────────────────┐                  │
│         │                │                │                  │
│  ┌──────▼──────┐  ┌─────▼─────┐  ┌──────▼──────┐          │
│  │  Token 管理  │  │ 会话管理   │  │  审计日志   │          │
│  └─────────────┘  └───────────┘  └─────────────┘          │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                      存储层 (PostgreSQL + Redis)                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 用户注册

### 2.1 注册方式

#### 2.1.1 用户名密码注册

**优点**: 简单、快速、无需额外服务
**缺点**: 需要管理密码、可能被暴力破解

**流程**:

```rust
pub async fn register_with_password(
    username: String,
    password: String,
    settings: &Settings,
) -> Result<User> {
    // 1. 验证用户名唯一性
    if User::exists_by_username(&username).await? {
        return Err(Error::UsernameExists);
    }

    // 2. 密码强度验证 (使用 zxcvbn)
    let password_strength = zxcvbn(&password, &[&username])?;
    if password_strength.score() < 3 {
        return Err(Error::WeakPassword {
            suggestions: password_strength.feedback().suggestions(),
        });
    }

    // 3. Argon2id 哈希 (参数调优针对服务器性能)
    let password_hash = Argon2::default()
        .hash_password(
            password.as_bytes(),
            &SaltString::generate(&mut OsRng),
        )?
        .to_string();

    // 4. 创建用户 (默认状态根据配置决定)
    let user = User {
        id: nanoid!(12),
        username,
        password_hash,
        status: if settings.require_approval {
            UserStatus::Pending
        } else {
            UserStatus::Active
        },
        created_at: OffsetDateTime::now_utc(),
        ..Default::default()
    };

    user.insert().await?;

    // 5. 审计日志
    audit_log!(
        action = "user.register",
        user_id = %user.id,
        method = "password",
    );

    Ok(user)
}
```

#### 2.1.2 邮箱验证注册

**优点**: 确认用户身份、建立联系渠道
**缺点**: 需要 SMTP 服务、用户体验稍慢

**流程**:

```rust
pub async fn register_with_email(
    email: String,
    password: String,
    verification_code: String,
) -> Result<User> {
    // 1. 验证邮箱验证码 (Redis 缓存)
    let cached_code = redis
        .get::<String>(format!("email:verify:{}:code", email))
        .await?;

    if cached_code != verification_code {
        return Err(Error::InvalidVerificationCode);
    }

    // 2. 检查邮箱白名单 (如果启用)
    if settings.email_whitelist_enabled {
        let domain = email.split('@').nth(1).ok_or(Error::InvalidEmail)?;
        if !settings.email_whitelist.contains(&domain) {
            return Err(Error::EmailDomainNotAllowed);
        }
    }

    // 3. 创建用户
    let user = User {
        id: nanoid!(12),
        username: email.clone(),
        email: Some(email.clone()),
        email_verified: true,  // 已验证
        password_hash: hash_password(&password)?,
        status: UserStatus::Active,
        ..Default::default()
    };

    user.insert().await?;

    // 4. 删除验证码
    redis.del(format!("email:verify:{}:code", email)).await?;

    // 5. 发送欢迎邮件
    email_service.send_welcome_email(&user).await?;

    Ok(user)
}
```

### 2.2 注册审核机制

**设计思想**: 可选的审核机制，防止恶意注册

```rust
pub enum UserStatus {
    /// 待审核 (管理员批准后才能使用)
    Pending,
    /// 活跃用户
    Active,
    /// 已封禁
    Banned,
}

// 管理员批准
pub async fn approve_user(admin: &User, user_id: String) -> Result<()> {
    // 权限检查
    if !admin.is_admin() {
        return Err(Error::PermissionDenied);
    }

    // 更新状态
    sqlx::query!(
        "UPDATE users SET status = $1, approved_at = $2, approved_by = $3 WHERE id = $4",
        UserStatus::Active,
        OffsetDateTime::now_utc(),
        admin.id,
        user_id
    )
    .execute(&db)
    .await?;

    // 发送通知邮件
    let user = User::find_by_id(user_id).await?;
    if let Some(email) = user.email {
        email_service
            .send_approval_notification(&email, &user.username)
            .await?;
    }

    Ok(())
}
```

---

## 3. 用户登录

### 3.1 登录方式

#### 3.1.1 用户名/邮箱 + 密码登录

```rust
pub async fn login_with_credentials(
    identifier: String,  // 用户名或邮箱
    password: String,
    device_info: DeviceInfo,
) -> Result<LoginResponse> {
    // 1. 查找用户 (支持用户名或邮箱)
    let user = if identifier.contains('@') {
        User::find_by_email(&identifier).await?
    } else {
        User::find_by_username(&identifier).await?
    };

    // 2. 检查用户状态
    match user.status {
        UserStatus::Banned => return Err(Error::UserBanned),
        UserStatus::Pending => return Err(Error::UserPending),
        UserStatus::Active => {}
    }

    // 3. 验证密码 (使用 Argon2id)
    let parsed_hash = PasswordHash::new(&user.password_hash)?;
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .map_err(|_| Error::InvalidCredentials)?;

    // 4. 生成 JWT Token (RS256 非对称加密)
    let tokens = generate_token_pair(&user)?;

    // 5. 创建会话 (存储到 Redis)
    let session = Session {
        id: nanoid!(12),
        user_id: user.id.clone(),
        refresh_token: tokens.refresh_token.clone(),
        device_info,
        created_at: OffsetDateTime::now_utc(),
        expires_at: OffsetDateTime::now_utc() + Duration::days(30),
    };
    session.save_to_redis().await?;

    // 6. 更新最后登录时间
    user.update_last_login().await?;

    // 7. 审计日志
    audit_log!(
        action = "user.login",
        user_id = %user.id,
        method = "password",
        device = ?device_info,
    );

    Ok(LoginResponse {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        expires_in: 3600,  // 1 小时
        user: user.to_public_info(),
    })
}
```

### 3.2 Token 设计

#### 3.2.1 使用 RS256 (非对称加密)

**为什么不用 HS256**:

- HS256 使用对称密钥，密钥泄露风险高
- RS256 使用私钥签名、公钥验证，更安全
- 多副本架构下，公钥可以分发到所有副本，私钥只在认证服务持有

```rust
pub struct TokenPair {
    /// 访问令牌 (短期有效，1 小时)
    pub access_token: String,
    /// 刷新令牌 (长期有效，30 天)
    pub refresh_token: String,
}

pub struct AccessTokenClaims {
    /// 用户 ID
    pub sub: String,
    /// 用户名
    pub username: String,
    /// 用户角色
    pub role: UserRole,
    /// 签发时间
    pub iat: i64,
    /// 过期时间
    pub exp: i64,
    /// 签发者
    pub iss: String,
}

pub fn generate_token_pair(user: &User) -> Result<TokenPair> {
    let now = OffsetDateTime::now_utc().unix_timestamp();

    // Access Token Claims
    let access_claims = AccessTokenClaims {
        sub: user.id.clone(),
        username: user.username.clone(),
        role: user.role,
        iat: now,
        exp: now + 3600,  // 1 小时
        iss: "synctv".to_string(),
    };

    // Refresh Token Claims (更长的有效期)
    let refresh_claims = json!({
        "sub": user.id.clone(),
        "type": "refresh",
        "iat": now,
        "exp": now + 2592000,  // 30 天
    });

    // 使用 RS256 签名
    let encoding_key = EncodingKey::from_rsa_pem(&PRIVATE_KEY)?;
    let access_token = encode(
        &Header::new(Algorithm::RS256),
        &access_claims,
        &encoding_key,
    )?;
    let refresh_token = encode(
        &Header::new(Algorithm::RS256),
        &refresh_claims,
        &encoding_key,
    )?;

    Ok(TokenPair {
        access_token,
        refresh_token,
    })
}
```

#### 3.2.2 Token 刷新

```rust
pub async fn refresh_token(refresh_token: String) -> Result<TokenPair> {
    // 1. 验证 Refresh Token
    let decoding_key = DecodingKey::from_rsa_pem(&PUBLIC_KEY)?;
    let token_data = decode::<Value>(
        &refresh_token,
        &decoding_key,
        &Validation::new(Algorithm::RS256),
    )?;

    // 2. 检查是否在 Redis 中 (未被撤销)
    let session_exists = redis
        .exists(format!("session:refresh:{}", refresh_token))
        .await?;
    if !session_exists {
        return Err(Error::InvalidRefreshToken);
    }

    // 3. 获取用户信息
    let user_id = token_data.claims["sub"]
        .as_str()
        .ok_or(Error::InvalidToken)?;
    let user = User::find_by_id(user_id).await?;

    // 4. 生成新的 Token Pair
    let new_tokens = generate_token_pair(&user)?;

    // 5. 更新 Redis 中的会话
    redis
        .del(format!("session:refresh:{}", refresh_token))
        .await?;
    redis
        .set_ex(
            format!("session:refresh:{}", new_tokens.refresh_token),
            &user.id,
            2592000,  // 30 天
        )
        .await?;

    Ok(new_tokens)
}
```

### 3.3 登出机制

```rust
pub async fn logout(access_token: String, refresh_token: String) -> Result<()> {
    // 1. 将 Access Token 加入黑名单 (直到过期)
    let claims = decode_token(&access_token)?;
    let ttl = claims.exp - OffsetDateTime::now_utc().unix_timestamp();
    if ttl > 0 {
        redis
            .set_ex(
                format!("token:blacklist:{}", access_token),
                "1",
                ttl as usize,
            )
            .await?;
    }

    // 2. 删除 Refresh Token (立即失效)
    redis
        .del(format!("session:refresh:{}", refresh_token))
        .await?;

    // 3. 审计日志
    audit_log!(
        action = "user.logout",
        user_id = %claims.sub,
    );

    Ok(())
}
```

---

## 4. OAuth2/OIDC 集成

### 4.1 设计思想

**现代化 OAuth2 架构**:

- 支持多个 OAuth2 提供商 (GitHub, GitLab, Google, Discord, Microsoft)
- 使用 PKCE (Proof Key for Code Exchange) 增强安全性
- 使用 `state` 参数防止 CSRF 攻击
- 支持账号绑定和解绑

### 4.2 OAuth2 提供商配置

```rust
pub struct OAuth2Provider {
    pub name: String,
    pub client_id: String,
    pub client_secret: String,
    pub auth_url: String,
    pub token_url: String,
    pub user_info_url: String,
    pub scopes: Vec<String>,
    pub enabled: bool,
}

// 预定义提供商
pub fn github_provider() -> OAuth2Provider {
    OAuth2Provider {
        name: "github".to_string(),
        client_id: env::var("GITHUB_CLIENT_ID").unwrap(),
        client_secret: env::var("GITHUB_CLIENT_SECRET").unwrap(),
        auth_url: "https://github.com/login/oauth/authorize".to_string(),
        token_url: "https://github.com/login/oauth/access_token".to_string(),
        user_info_url: "https://api.github.com/user".to_string(),
        scopes: vec!["user:email".to_string()],
        enabled: true,
    }
}
```

### 4.3 OAuth2 登录流程

```rust
pub async fn oauth2_login_redirect(
    provider_name: String,
) -> Result<String> {
    // 1. 获取提供商配置
    let provider = get_oauth2_provider(&provider_name)?;

    // 2. 创建 OAuth2 客户端
    let client = BasicClient::new(
        ClientId::new(provider.client_id),
        Some(ClientSecret::new(provider.client_secret)),
        AuthUrl::new(provider.auth_url)?,
        Some(TokenUrl::new(provider.token_url)?),
    );

    // 3. 生成 PKCE verifier (增强安全性)
    let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

    // 4. 生成 state (防 CSRF)
    let state = nanoid!(12);

    // 5. 保存 state 和 PKCE verifier 到 Redis (5 分钟过期)
    redis
        .set_ex(
            format!("oauth2:state:{}", state),
            serde_json::to_string(&OAuth2State {
                provider: provider_name,
                pkce_verifier: pkce_verifier.secret().clone(),
            })?,
            300,
        )
        .await?;

    // 6. 生成授权 URL
    let (auth_url, _csrf_token) = client
        .authorize_url(|| CsrfToken::new(state))
        .add_scopes(provider.scopes.iter().map(|s| Scope::new(s.clone())))
        .set_pkce_challenge(pkce_challenge)
        .url();

    Ok(auth_url.to_string())
}

pub async fn oauth2_login_callback(
    code: String,
    state: String,
) -> Result<LoginResponse> {
    // 1. 验证 state (防 CSRF)
    let oauth2_state: OAuth2State = redis
        .get_del(format!("oauth2:state:{}", state))
        .await?
        .ok_or(Error::InvalidState)?;

    // 2. 获取提供商配置
    let provider = get_oauth2_provider(&oauth2_state.provider)?;
    let client = BasicClient::new(
        ClientId::new(provider.client_id),
        Some(ClientSecret::new(provider.client_secret)),
        AuthUrl::new(provider.auth_url)?,
        Some(TokenUrl::new(provider.token_url)?),
    );

    // 3. 交换 code 获取 access token (使用 PKCE verifier)
    let token_response = client
        .exchange_code(AuthorizationCode::new(code))
        .set_pkce_verifier(PkceCodeVerifier::new(oauth2_state.pkce_verifier))
        .request_async(async_http_client)
        .await?;

    // 4. 获取用户信息
    let user_info = fetch_oauth2_user_info(
        &provider,
        token_response.access_token().secret(),
    )
    .await?;

    // 5. 查找或创建用户
    let user = match User::find_by_oauth2_id(&provider.name, &user_info.id).await {
        Ok(user) => user,
        Err(_) => {
            // 新用户，创建账号
            let new_user = User {
                id: nanoid!(12),
                username: user_info.username,
                email: user_info.email,
                avatar_url: user_info.avatar_url,
                status: UserStatus::Active,
                oauth2_providers: vec![OAuth2Binding {
                    provider: provider.name.clone(),
                    provider_user_id: user_info.id.clone(),
                    created_at: OffsetDateTime::now_utc(),
                }],
                ..Default::default()
            };
            new_user.insert().await?;
            new_user
        }
    };

    // 6. 生成 Token
    let tokens = generate_token_pair(&user)?;

    Ok(LoginResponse {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        expires_in: 3600,
        user: user.to_public_info(),
    })
}
```

### 4.4 账号绑定

```rust
pub async fn bind_oauth2_account(
    user: &User,
    provider_name: String,
    code: String,
    state: String,
) -> Result<()> {
    // 1-4 步与登录流程相同...

    // 5. 检查是否已绑定
    if user.oauth2_providers.iter().any(|p| p.provider == provider_name) {
        return Err(Error::AlreadyBound);
    }

    // 6. 检查该 OAuth2 账号是否被其他用户绑定
    if User::find_by_oauth2_id(&provider_name, &user_info.id).await.is_ok() {
        return Err(Error::OAuth2AccountAlreadyUsed);
    }

    // 7. 添加绑定
    sqlx::query!(
        "INSERT INTO oauth2_bindings (user_id, provider, provider_user_id, created_at)
         VALUES ($1, $2, $3, $4)",
        user.id,
        provider_name,
        user_info.id,
        OffsetDateTime::now_utc()
    )
    .execute(&db)
    .await?;

    Ok(())
}
```

---

## 5. 邮箱系统

### 5.1 SMTP 配置

```rust
pub struct EmailConfig {
    pub smtp_host: String,
    pub smtp_port: u16,
    pub smtp_username: String,
    pub smtp_password: String,
    pub smtp_tls: bool,
    pub from_address: String,
    pub from_name: String,
}

pub struct EmailService {
    mailer: AsyncSmtpTransport<Tokio1Executor>,
    config: EmailConfig,
}

impl EmailService {
    pub fn new(config: EmailConfig) -> Result<Self> {
        let credentials = Credentials::new(
            config.smtp_username.clone(),
            config.smtp_password.clone(),
        );

        let mailer = if config.smtp_tls {
            AsyncSmtpTransport::<Tokio1Executor>::starttls_relay(&config.smtp_host)?
        } else {
            AsyncSmtpTransport::<Tokio1Executor>::relay(&config.smtp_host)?
        }
        .credentials(credentials)
        .port(config.smtp_port)
        .build();

        Ok(Self { mailer, config })
    }
}
```

### 5.2 邮箱验证码

```rust
pub async fn send_verification_code(
    email: String,
    purpose: VerificationPurpose,
) -> Result<()> {
    // 1. 生成 6 位数字验证码
    let code = generate_numeric_code(6);

    // 2. 保存到 Redis (5 分钟过期)
    let key = format!("email:verify:{}:{:?}", email, purpose);
    redis.set_ex(&key, &code, 300).await?;

    // 3. 发送邮件
    let email_body = match purpose {
        VerificationPurpose::Register => format!(
            "您的注册验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
        VerificationPurpose::ResetPassword => format!(
            "您的密码重置验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
        VerificationPurpose::BindEmail => format!(
            "您的邮箱绑定验证码是: <b>{}</b><br>有效期 5 分钟。",
            code
        ),
    };

    email_service.send_html_email(
        &email,
        "SyncTV 验证码",
        &email_body,
    ).await?;

    Ok(())
}

pub enum VerificationPurpose {
    Register,
    ResetPassword,
    BindEmail,
}
```

### 5.3 邮件模板系统

使用 **Tera** 模板引擎:

```rust
use tera::Tera;

pub struct EmailTemplates {
    tera: Tera,
}

impl EmailTemplates {
    pub fn new() -> Result<Self> {
        let tera = Tera::new("templates/emails/**/*.html")?;
        Ok(Self { tera })
    }

    pub fn render_verification_email(
        &self,
        code: &str,
        username: &str,
    ) -> Result<String> {
        let mut context = tera::Context::new();
        context.insert("code", code);
        context.insert("username", username);
        Ok(self.tera.render("verification.html", &context)?)
    }
}
```

**templates/emails/verification.html**:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; }
        .code { font-size: 24px; font-weight: bold; color: #4CAF50; }
    </style>
</head>
<body>
    <h2>Hi {{ username }},</h2>
    <p>您的验证码是:</p>
    <p class="code">{{ code }}</p>
    <p>有效期 5 分钟，请勿泄露给他人。</p>
    <p>-- SyncTV Team</p>
</body>
</html>
```

---

## 6. 安全机制

### 6.1 图形验证码

使用 **captcha-rs** 生成现代化验证码:

```rust
use captcha::Captcha;
use captcha::filters::{Noise, Wave};

pub struct CaptchaService {
    redis: RedisPool,
}

impl CaptchaService {
    pub async fn generate(&self) -> Result<CaptchaResponse> {
        // 1. 生成验证码图片
        let mut captcha = Captcha::new();
        captcha
            .add_chars(5)
            .apply_filter(Noise::new(0.1))
            .apply_filter(Wave::new(2.0, 20.0))
            .view(220, 120);

        let captcha_id = nanoid!(12);
        let answer = captcha.chars_as_string();

        // 2. 保存答案到 Redis (2 分钟过期)
        redis
            .set_ex(
                format!("captcha:{}", captcha_id),
                &answer,
                120,
            )
            .await?;

        // 3. 返回 Base64 编码的图片
        let png = captcha.as_png().unwrap();
        let base64_image = base64::encode(&png);

        Ok(CaptchaResponse {
            captcha_id,
            image_base64: format!("data:image/png;base64,{}", base64_image),
        })
    }

    pub async fn verify(
        &self,
        captcha_id: String,
        answer: String,
    ) -> Result<bool> {
        let correct_answer: Option<String> = redis
            .get_del(format!("captcha:{}", captcha_id))
            .await?;

        match correct_answer {
            Some(correct) => Ok(correct.to_lowercase() == answer.to_lowercase()),
            None => Err(Error::CaptchaExpired),
        }
    }
}
```

### 6.2 密码强度验证

使用 **zxcvbn** 库:

```rust
use zxcvbn::zxcvbn;

pub fn validate_password_strength(
    password: &str,
    username: &str,
) -> Result<()> {
    let entropy = zxcvbn(password, &[username])?;

    // Score 0-4, 要求至少 3 分
    if entropy.score() < 3 {
        let suggestions = entropy
            .feedback()
            .as_ref()
            .map(|f| f.suggestions().join(", "))
            .unwrap_or_default();

        return Err(Error::WeakPassword {
            score: entropy.score(),
            suggestions,
        });
    }

    Ok(())
}
```

### 6.3 防暴力破解

#### 6.3.1 限流操作类型定义

```rust
/// 限流操作类型（使用 enum 保证类型安全）
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum RateLimitAction {
    /// 登录尝试
    Login,
    /// 用户注册
    Register,
    /// 邮件发送（验证码、重置密码等）
    Email,
    /// 密码重置
    PasswordReset,
    /// OAuth2 授权
    OAuth2Auth,
    /// API 调用
    ApiCall,
}

impl RateLimitAction {
    /// 获取 settings 表的 key
    pub fn setting_key(&self, field: &str) -> String {
        format!("rate_limit.{}.{}", self.as_str(), field)
    }

    /// 获取操作的字符串标识
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Login => "login",
            Self::Register => "register",
            Self::Email => "email",
            Self::PasswordReset => "password_reset",
            Self::OAuth2Auth => "oauth2_auth",
            Self::ApiCall => "api_call",
        }
    }
}
```

#### 6.3.2 在代码中定义限流默认配置

```rust
// 使用 setting! 宏定义限流配置（编译时注册，启动时自动同步到数据库）

// 登录限流
setting!(RATE_LIMIT_LOGIN_MAX_REQUESTS: i64 =
    "rate_limit.login.max_requests",
    "5",
    "rate_limit",
    "登录：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_LOGIN_WINDOW_SECONDS: i64 =
    "rate_limit.login.window_seconds",
    "60",
    "rate_limit",
    "登录：时间窗口（秒）"
);

setting!(RATE_LIMIT_LOGIN_ENABLED: bool =
    "rate_limit.login.enabled",
    "true",
    "rate_limit",
    "登录：是否启用限流"
);

// 注册限流
setting!(RATE_LIMIT_REGISTER_MAX_REQUESTS: i64 =
    "rate_limit.register.max_requests",
    "3",
    "rate_limit",
    "注册：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_REGISTER_WINDOW_SECONDS: i64 =
    "rate_limit.register.window_seconds",
    "3600",
    "rate_limit",
    "注册：时间窗口（秒）"
);

setting!(RATE_LIMIT_REGISTER_ENABLED: bool =
    "rate_limit.register.enabled",
    "true",
    "rate_limit",
    "注册：是否启用限流"
);

// 邮件限流
setting!(RATE_LIMIT_EMAIL_MAX_REQUESTS: i64 =
    "rate_limit.email.max_requests",
    "3",
    "rate_limit",
    "邮件：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_EMAIL_WINDOW_SECONDS: i64 =
    "rate_limit.email.window_seconds",
    "60",
    "rate_limit",
    "邮件：时间窗口（秒）"
);

setting!(RATE_LIMIT_EMAIL_ENABLED: bool =
    "rate_limit.email.enabled",
    "true",
    "rate_limit",
    "邮件：是否启用限流"
);

// 密码重置限流
setting!(RATE_LIMIT_PASSWORD_RESET_MAX_REQUESTS: i64 =
    "rate_limit.password_reset.max_requests",
    "3",
    "rate_limit",
    "密码重置：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_PASSWORD_RESET_WINDOW_SECONDS: i64 =
    "rate_limit.password_reset.window_seconds",
    "3600",
    "rate_limit",
    "密码重置：时间窗口（秒）"
);

setting!(RATE_LIMIT_PASSWORD_RESET_ENABLED: bool =
    "rate_limit.password_reset.enabled",
    "true",
    "rate_limit",
    "密码重置：是否启用限流"
);

// OAuth2 限流
setting!(RATE_LIMIT_OAUTH2_AUTH_MAX_REQUESTS: i64 =
    "rate_limit.oauth2_auth.max_requests",
    "10",
    "rate_limit",
    "OAuth2：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_OAUTH2_AUTH_WINDOW_SECONDS: i64 =
    "rate_limit.oauth2_auth.window_seconds",
    "60",
    "rate_limit",
    "OAuth2：时间窗口（秒）"
);

setting!(RATE_LIMIT_OAUTH2_AUTH_ENABLED: bool =
    "rate_limit.oauth2_auth.enabled",
    "true",
    "rate_limit",
    "OAuth2：是否启用限流"
);

// API 调用限流
setting!(RATE_LIMIT_API_CALL_MAX_REQUESTS: i64 =
    "rate_limit.api_call.max_requests",
    "100",
    "rate_limit",
    "API：时间窗口内最大请求数"
);

setting!(RATE_LIMIT_API_CALL_WINDOW_SECONDS: i64 =
    "rate_limit.api_call.window_seconds",
    "60",
    "rate_limit",
    "API：时间窗口（秒）"
);

setting!(RATE_LIMIT_API_CALL_ENABLED: bool =
    "rate_limit.api_call.enabled",
    "true",
    "rate_limit",
    "API：是否启用限流"
);
```

**优势**：
- ✅ 编译时注册：使用 `inventory` crate 自动收集所有配置定义
- ✅ 启动时同步：`init_definitions()` 自动将配置刷到数据库
- ✅ 无需预插入：数据库为空也能工作，使用代码中的默认值
- ✅ 版本升级友好：新配置自动插入默认值，旧配置保留用户自定义值
- ✅ 类型安全：编译时类型检查 + 运行时解析错误检测

#### 6.3.3 限流配置读取（使用统一 get API）

```rust
impl RateLimitService {
    pub async fn check_rate_limit(
        &self,
        ip: IpAddr,
        action: RateLimitAction,
    ) -> Result<()> {
        // 使用 get()，返回 Result 以便处理配置错误
        let (max_requests, window_seconds, enabled) = match action {
            RateLimitAction::Login => (
                self.settings.get(&RATE_LIMIT_LOGIN_MAX_REQUESTS)?,
                self.settings.get(&RATE_LIMIT_LOGIN_WINDOW_SECONDS)?,
                self.settings.get(&RATE_LIMIT_LOGIN_ENABLED)?,
            ),
            RateLimitAction::Register => (
                self.settings.get(&RATE_LIMIT_REGISTER_MAX_REQUESTS)?,
                self.settings.get(&RATE_LIMIT_REGISTER_WINDOW_SECONDS)?,
                self.settings.get(&RATE_LIMIT_REGISTER_ENABLED)?,
            ),
            RateLimitAction::Email => (
                self.settings.get(&RATE_LIMIT_EMAIL_MAX_REQUESTS)?,
                self.settings.get(&RATE_LIMIT_EMAIL_WINDOW_SECONDS)?,
                self.settings.get(&RATE_LIMIT_EMAIL_ENABLED)?,
            ),
            // ... 其他操作
        };

        if !enabled {
            return Ok(());  // 限流已禁用
        }

        // Redis 限流逻辑
        let key = format!("ratelimit:{}:{}", ip, action.as_str());
        let mut conn = self.redis.get().await?;

        let count: i64 = redis::cmd("INCR")
            .arg(&key)
            .query_async(&mut *conn)
            .await?;

        if count == 1 {
            redis::cmd("EXPIRE")
                .arg(&key)
                .arg(window_seconds)
                .query_async::<_, ()>(&mut *conn)
                .await?;
        }

        if count > max_requests {
            return Err(Error::TooManyAttempts {
                action: action.as_str(),
                retry_after: window_seconds as u64,
                max_requests: max_requests as i32,
            });
        }

        Ok(())
    }
}
```

#### 6.3.4 限流服务（集成动态配置系统）

```rust
pub struct RateLimitService {
    redis: deadpool_redis::Pool,
    settings: Arc<DynamicSettings>,  // 使用现有的动态配置系统
}

impl RateLimitService {
    pub fn new(redis: deadpool_redis::Pool, settings: Arc<DynamicSettings>) -> Self {
        Self { redis, settings }
    }

    /// 检查限流（从动态配置读取限制）
    pub async fn check_rate_limit(
        &self,
        ip: IpAddr,
        action: RateLimitAction,
    ) -> Result<()> {
        // 1. 从动态配置系统读取配置（实时生效，无需重启）
        let config = RateLimitConfig::from_settings(&self.settings, action);

        // 2. 如果禁用，直接通过
        if !config.enabled {
            return Ok(());
        }

        // 3. 构建 Redis key
        let key = format!("ratelimit:{}:{}", ip, action.as_str());

        // 4. 使用 Redis INCR + EXPIRE 实现滑动窗口
        let mut conn = self.redis.get().await?;
        let count: i64 = redis::cmd("INCR")
            .arg(&key)
            .query_async(&mut *conn)
            .await?;

        // 首次请求时设置过期时间
        if count == 1 {
            redis::cmd("EXPIRE")
                .arg(&key)
                .arg(config.window_seconds)
                .query_async::<_, ()>(&mut *conn)
                .await?;
        }

        // 5. 检查是否超过限制
        if count > config.max_requests {
            return Err(Error::TooManyAttempts {
                action: action.as_str(),
                retry_after: config.window_seconds as u64,
                max_requests: config.max_requests as i32,
            });
        }

        Ok(())
    }

    /// 重置某个 IP 的限流计数（管理员操作）
    pub async fn reset_rate_limit(
        &self,
        ip: IpAddr,
        action: RateLimitAction,
    ) -> Result<()> {
        let key = format!("ratelimit:{}:{}", ip, action.as_str());
        let mut conn = self.redis.get().await?;

        redis::cmd("DEL")
            .arg(&key)
            .query_async::<_, ()>(&mut *conn)
            .await?;

        Ok(())
    }

    /// 获取当前限流计数（用于监控）
    pub async fn get_rate_limit_count(
        &self,
        ip: IpAddr,
        action: RateLimitAction,
    ) -> Result<i64> {
        let key = format!("ratelimit:{}:{}", ip, action.as_str());
        let mut conn = self.redis.get().await?;

        let count: Option<i64> = redis::cmd("GET")
            .arg(&key)
            .query_async(&mut *conn)
            .await?;

        Ok(count.unwrap_or(0))
    }
}
```

#### 6.3.5 使用示例

```rust
// ============================================
// 示例 1: 在登录接口中使用
// ============================================

pub async fn login(
    State(state): State<AppState>,
    ConnectInfo(addr): ConnectInfo<SocketAddr>,
    Json(req): Json<LoginRequest>,
) -> Result<Json<LoginResponse>> {
    // 1. 检查限流（配置自动从代码默认值或数据库读取）
    state.rate_limit_service
        .check_rate_limit(addr.ip(), RateLimitAction::Login)
        .await?;

    // 2. 执行登录逻辑
    let user = state.user_service.login(&req.username, &req.password).await?;

    // 3. 生成 token
    let access_token = state.jwt_service.generate_access_token(&user.id).await?;

    Ok(Json(LoginResponse { access_token }))
}

// ============================================
// 示例 2: DBA 直接修改数据库配置
// ============================================

-- 首次设置限流配置（数据库可能为空）
INSERT INTO settings (key, value, category, description)
VALUES ('rate_limit.login.max_requests', '10', 'rate_limit', '登录限流');
-- → 触发器自动 NOTIFY 'settings_changed', 'rate_limit.login.max_requests'
-- → 所有副本的 PgListener 收到通知
-- → 自动重新加载配置
-- → 立即生效！

-- 修改配置
UPDATE settings
SET value = '20', updated_at = NOW()
WHERE key = 'rate_limit.login.max_requests';
-- → 同样自动同步到所有副本

-- 删除配置（恢复默认值）
DELETE FROM settings WHERE key = 'rate_limit.login.max_requests';
-- → 触发器通知
-- → 副本删除缓存
-- → 下次读取返回代码中的默认值（5）

// ============================================
// 示例 3: 通过管理 API 修改（可选）
// ============================================

// POST /api/admin/settings
// {
//   "key": "rate_limit.login.max_requests",
//   "value": "15"
// }
//
// API 内部执行 SQL:
// INSERT INTO settings (key, value, category, description)
// VALUES ($1, $2, 'rate_limit', '...')
// ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value;
//
// → 触发器自动同步到所有副本
```

#### 6.3.6 配置管理使用示例

```rust
// 1. 代码中定义（编译时常量，默认值必须是字符串）
setting!(RATE_LIMIT_LOGIN_MAX_REQUESTS: i64 =
    "rate_limit.login.max_requests", "5", "rate_limit", "登录限流");

setting!(RATE_LIMIT_LOGIN_ENABLED: bool =
    "rate_limit.login.enabled", "true", "rate_limit", "启用登录限流");

// 2. 读取配置（返回 Result，显式错误处理）
let max_requests = settings.get(&RATE_LIMIT_LOGIN_MAX_REQUESTS)?;  // Result<i64>
let enabled = settings.get(&RATE_LIMIT_LOGIN_ENABLED)?;  // Result<bool>

// 或使用 get_or_default（自动降级到默认值）
let max_requests = settings.get_or_default(&RATE_LIMIT_LOGIN_MAX_REQUESTS);  // i64
let enabled = settings.get_or_default(&RATE_LIMIT_LOGIN_ENABLED);  // bool

// 3. 修改配置（直接 SQL）
-- UPDATE settings SET value = '10' WHERE key = 'rate_limit.login.max_requests';
-- → 触发器自动通知所有副本
```

**核心特性**：
1. ✅ **零配置启动** - 数据库为空也能工作，启动时自动同步配置定义
2. ✅ **类型安全** - 编译时检查，不会传错类型
3. ✅ **错误处理** - `get()` 返回 `Result`，明确处理配置错误
4. ✅ **灵活策略** - 可选择快速失败或降级到默认值
5. ✅ **自动同步** - PostgreSQL 触发器 + LISTEN/NOTIFY
6. ✅ **零依赖** - 只需 PostgreSQL，无需 Redis

#### 6.3.7 错误类型定义

```rust
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Too many {action} attempts. Retry after {retry_after} seconds. (Max: {max_requests} requests)")]
    TooManyAttempts {
        action: &'static str,
        retry_after: u64,
        max_requests: i32,
    },
}
```

---

## 7. 数据模型

### 7.1 用户表

```sql
CREATE TABLE users (
    id CHAR(12) PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(255),  -- Argon2id hash, 可选 (OAuth2 用户可能没有密码)
    email VARCHAR(255) UNIQUE,
    email_verified BOOLEAN DEFAULT FALSE,
    avatar_url TEXT,
    role VARCHAR(20) NOT NULL DEFAULT 'user',  -- root, admin, user
    status VARCHAR(20) NOT NULL DEFAULT 'active',  -- pending, active, banned
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ,
    approved_at TIMESTAMPTZ,
    approved_by CHAR(12) REFERENCES users(id),
    banned_at TIMESTAMPTZ,
    banned_by CHAR(12) REFERENCES users(id),
    banned_reason TEXT,

    CHECK (role IN ('root', 'admin', 'user')),
    CHECK (status IN ('pending', 'active', 'banned'))
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_role ON users(role);
```

### 7.2 OAuth2 绑定表

```sql
CREATE TABLE oauth2_bindings (
    id CHAR(12) PRIMARY KEY,
    user_id CHAR(12) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL,  -- github, gitlab, google, discord, microsoft
    provider_user_id VARCHAR(255) NOT NULL,
    provider_username VARCHAR(255),
    provider_email VARCHAR(255),
    access_token TEXT,  -- 加密存储
    refresh_token TEXT,  -- 加密存储
    token_expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE (provider, provider_user_id)
);

CREATE INDEX idx_oauth2_bindings_user_id ON oauth2_bindings(user_id);
CREATE INDEX idx_oauth2_bindings_provider ON oauth2_bindings(provider, provider_user_id);
```

### 7.3 会话表 (Redis)

```
key: session:refresh:{refresh_token}
value: {
    "user_id": "nanoid(12)",
    "device_info": {
        "user_agent": "...",
        "ip": "...",
        "platform": "..."
    },
    "created_at": "timestamp",
    "expires_at": "timestamp"
}
ttl: 2592000  # 30 天
```

### 7.4 审计日志表

```sql
CREATE TABLE audit_logs (
    id CHAR(12) PRIMARY KEY,
    user_id CHAR(12) REFERENCES users(id),
    action VARCHAR(100) NOT NULL,  -- user.login, user.register, user.logout, etc.
    ip_address INET,
    user_agent TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
```

---

## 总结

本章节设计了一个**现代化、安全、可扩展**的用户系统:

✅ **多种认证方式**: 密码、邮箱、OAuth2/OIDC
✅ **安全第一**: Argon2id 密码哈希、RS256 JWT、PKCE、防暴力破解
✅ **用户体验**: 邮件模板、图形验证码、密码强度提示
✅ **审计与合规**: 完整的审计日志、GDPR 合规
✅ **多副本支持**: Token 无状态、会话 Redis 存储、公钥分发

**上一章**: [05-缓存设计](./05-缓存设计.md)
**下一章**: [07-权限系统设计](./07-权限系统设计.md)
