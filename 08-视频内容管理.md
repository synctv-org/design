# 06. 视频内容管理

---

## 6.1 视频解析系统

### 6.1.1 架构设计

**Go 版本的问题**:

1. **强耦合**: 每个平台的解析逻辑直接写在 handler 中
2. **无法扩展**: 新增平台需要修改多个文件的 switch-case
3. **难以测试**: HTTP 逻辑和业务逻辑混在一起
4. **代码重复**: 相似的代理、字幕逻辑在多个平台重复

**新架构**: 能力导向的插件化视频解析系统

#### 6.1.1.1 能力导向设计（Capability-Oriented）

基于对 Go 版 SyncTV 的深入分析，发现核心问题：**不是所有 provider 都有相同的能力**

**能力差异**：

| Provider | URL解析 | 文件夹浏览 | 搜索 | 播放 | 流代理 |
|----------|---------|-----------|------|------|--------|
| Bilibili | ✓ | ✗ | ✗ | ✓ | ✓ |
| Alist | ✗ | ✓ | ✓ | ✓ | ✓ |
| Emby | ✗ | ✓ | ✓ | ✓ | ✓ |
| DirectUrl | ✗ | ✗ | ✗ | ✓ | ✗ |

**设计原则**：

1. **HTTP 端点 vs 内部 Trait**：清晰区分用户交互和系统内部调用
   - **用户交互**：通过 HTTP 端点（parse、browse、proxy）
   - **系统内部**：通过 Trait 方法（generate_playback、DynamicFolder）

2. **核心 Trait**：所有 Provider 必须实现

   ```rust
   trait MediaProvider {
       fn generate_playback(...) -> PlaybackResult;  // 必须实现
       fn register_http_routes(...) -> Router;       // 注册 HTTP 端点
       fn register_grpc_service(...) -> TonicRouter; // 可选注册 gRPC
   }
   ```

3. **可选 Trait**：根据能力选择性实现

   ```rust
   trait DynamicFolder: MediaProvider {  // 动态文件夹（内部使用）
       fn list_directory(...) -> DirectoryListing;
   }
   // Alist、Emby 实现 DynamicFolder
   // Bilibili、DirectUrl 不实现
   ```

4. **HTTP 端点注册**：Provider 通过 `register_http_routes()` 注册
   - `POST /api/providers/{id}/parse` - URL 解析（Bilibili）
   - `GET /api/providers/{id}/browse` - 文件浏览（Alist、Emby）
   - `GET /api/providers/{id}/proxy/*path` - 流代理（多数 Provider）

**架构图**：

```
┌─────────────────────────────────────────────────────┐
│              Provider Registry                       │
│  (管理所有 provider 实例和路由注册)                   │
└─────────────────────────────────────────────────────┘
                      │
      ┌───────────────┼───────────────┐
      │               │               │
  ┌───▼────────┐  ┌───▼────────┐  ┌──▼─────────┐
  │MediaProvider│  │DynamicFolder│  │HTTP Routes│
  │  (必须)     │  │  (可选)     │  │ parse     │
  │generate     │  │list_directory│ │ browse    │
  │_playback    │  │            │  │ proxy     │
  └─────────────┘  └─────────────┘  └────────────┘

┌─────────────────────────────────────────────────────┐
│           gRPC + WebgRPC + REST API                  │
│  (Provider 可注册自定义 service 和 routes)            │
├─────────────────────────────────────────────────────┤
│  Core Services (room, user, etc.)                   │
│  + Provider-Registered HTTP Routes:                 │
│    - /api/providers/bilibili_main/parse            │
│    - /api/providers/alist_company/browse           │
│    - /api/providers/*/proxy/*                      │
└─────────────────────────────────────────────────────┘
```

### 6.1.2 核心接口设计

> **说明**：
>
> - 本节定义完整的 `MediaProvider` trait
> - 代理相关的详细实现见：**[10-视频链接过期与代理机制](./10-视频链接过期与代理机制.md)**
> - Provider 注册和管理见：**[03-核心模块 § 3.7](./03-核心模块.md#37-provider-模块-)**
> - 其中 `MediaSource`、`ProxyRequest` 等类型定义在第 22 章

```rust
// providers/traits.rs
use async_trait::async_trait;
use serde_json::Value;
use tonic::transport::server::Router as TonicRouter;
use axum::Router;

/// 媒体源抽象接口
///
/// # 核心设计
/// - 唯一必须实现的方法：`generate_playback`
/// - parse/browse/proxy 通过 `register_http_routes` 注册为 HTTP 端点
/// - 可选实现 `DynamicFolder` trait 支持动态文件夹功能
#[async_trait]
pub trait MediaProvider: Send + Sync {
    // ========== 基础信息 ==========

    /// Provider 类型名称（如 "bilibili", "alist", "emby"）
    fn name(&self) -> &'static str;

    /// Provider 实例 ID（如 "bilibili_main", "alist_company"）
    fn instance_id(&self) -> &str;

    /// Provider 配置
    fn config(&self) -> &ProviderConfig;

    // ========== 播放信息生成（核心方法，必须实现） ==========

    /// 根据 source_config 生成播放信息
    ///
    /// **用于**：用户播放时，动态生成完整的播放信息
    ///
    /// **流程**：
    /// 1. 从数据库读取 media（包含 source_config）
    /// 2. 调用 generate_playback(source_config) 生成播放信息
    /// 3. 返回给客户端
    ///
    /// **缓存**：结果会根据 `cache_key()` 缓存到 Redis
    ///
    /// # 参数
    /// - ctx: Provider 上下文（包含用户、房间、base_url等）
    /// - source_config: 媒体源配置（从数据库 source_config 字段读取）
    ///
    /// # 返回
    /// PlaybackResult {
    ///   playback_infos: HashMap<String, PlaybackInfo>,  // 多模式播放信息
    ///   default_mode: String,                           // 默认模式
    ///   metadata: HashMap,                              // 媒体元数据
    /// }
    ///
    /// # 说明
    /// Provider 应该：
    /// 1. 从 source_config 获取配置（如 bvid、path、prefer_proxy）
    /// 2. 调用第三方API获取播放地址
    /// 3. 生成多个模式（direct、proxied等）
    /// 4. 每个模式包含完整的 URLs、字幕、弹幕
    /// 5. 根据 prefer_proxy 设置 default_mode
    ///
    /// # 示例
    /// ```rust
    /// // Bilibili
    /// source_config: {"bvid": "BV1xx", "cid": 123, "prefer_proxy": false}
    /// // 返回: PlaybackResult {
    /// //   playback_infos: {"direct": {...}, "proxied": {...}},
    /// //   default_mode: "direct"
    /// // }
    ///
    /// // Alist
    /// source_config: {"path": "/movies/video.mp4", "server_id": "abc123"}
    /// // 返回: PlaybackResult {
    /// //   playback_infos: {"proxied": {...}},
    /// //   default_mode: "proxied"
    /// // }
    /// ```
    async fn generate_playback(
        &self,
        ctx: &ProviderContext<'_>,
        source_config: &Value,
    ) -> Result<PlaybackResult>;

    // ========== 服务注册（支持 gRPC + WebgRPC + REST API）==========

    /// 是否需要注册自定义服务
    fn needs_service_registration(&self) -> bool {
        false  // 默认不需要
    }

    /// 注册 gRPC service
    ///
    /// Provider 可以注册自己的 gRPC service，支持：
    /// - 标准 gRPC 协议（服务端间通信）
    /// - gRPC-Web 协议（浏览器直接调用）
    ///
    /// # 使用场景
    /// - Bilibili: 注册 BilibiliService 用于 MPD/Segment 代理
    /// - Alist: 注册 AlistService 用于文件流式传输
    /// - Emby: 注册 EmbyService 用于转码代理
    ///
    /// # Example
    /// ```rust
    /// use tonic::transport::server::Router as TonicRouter;
    ///
    /// async fn register_grpc_service(&self, router: TonicRouter) -> Result<TonicRouter> {
    ///     let service = BilibiliServiceImpl::new(self.clone());
    ///     Ok(router.add_service(BilibiliServiceServer::new(service)))
    /// }
    /// ```
    ///
    /// # 说明
    /// - gRPC service 自动支持 gRPC-Web（通过 tonic-web 中间件）
    /// - 浏览器可通过 @grpc/grpc-web 直接调用
    /// - 适合大数据量、流式传输场景
    async fn register_grpc_service(&self, router: TonicRouter) -> Result<TonicRouter> {
        Ok(router)  // 默认不注册
    }

    /// 注册 HTTP/REST 路由
    ///
    /// Provider 可以注册自己的 HTTP 路由，用于：
    /// - 文件代理
    /// - Webhook 回调
    /// - 轻量级查询接口
    ///
    /// # 路由格式
    /// `/api/providers/{instance_id}/*path`
    ///
    /// # Example
    /// ```rust
    /// async fn register_http_routes(&self, router: Router<AppState>) -> Result<Router<AppState>> {
    ///     let provider = Arc::new(self.clone());
    ///
    ///     Ok(router
    ///         .route(
    ///             &format!("/api/providers/{}/mpd/:variant", self.instance_id()),
    ///             get(Self::handle_mpd)
    ///         )
    ///         .route(
    ///             &format!("/api/providers/{}/segment/:id", self.instance_id()),
    ///             get(Self::handle_segment)
    ///         )
    ///         .with_state(provider))
    /// }
    /// ```
    ///
    /// # 说明
    /// - 适合简单的文件代理、静态资源
    /// - 与 gRPC service 可以共存
    /// - HTTP routes 通过 Axum Router 注册
    async fn register_http_routes(&self, router: Router<AppState>) -> Result<Router<AppState>> {
        Ok(router)  // 默认不注册
    }

    // ========== 缓存策略 ==========

    /// 生成缓存键
    ///
    /// 根据上下文和 source_config 生成缓存键。不同 provider 可根据自身需求实现。
    ///
    /// **说明**：
    /// - `generate_playback()` 的结果会根据此键缓存到 Redis
    /// - 默认实现支持共享缓存（share=true）和用户级缓存
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - source_config: 媒体源配置
    ///
    /// # 返回
    /// 缓存键，格式如：
    /// - "synctv:playback:{provider}:{config_hash}:shared" (共享缓存)
    /// - "synctv:playback:{provider}:{config_hash}:user:{user_id}" (用户级缓存)
    ///
    /// # 示例
    /// ```rust
    /// // Bilibili 共享缓存
    /// source_config: {"bvid": "BV1xx", "share": true}
    /// // 返回: "synctv:playback:bilibili:BV1xx:shared"
    ///
    /// // Alist 用户级缓存
    /// source_config: {"path": "/movies/video.mp4", "server_id": "abc"}
    /// // 返回: "synctv:playback:alist:abc_movies_video_mp4:user:user123"
    /// ```
    fn cache_key(&self, ctx: &ProviderContext<'_>, source_config: &Value) -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        // 默认实现：生成 source_config 的哈希值
        let mut hasher = DefaultHasher::new();
        source_config.to_string().hash(&mut hasher);
        let config_hash = hasher.finish();

        // 检查是否共享缓存
        let is_shared = source_config
            .get("share")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if is_shared {
            format!("{}:playback:{}:{}:shared",
                ctx.key_prefix,
                self.name(),
                config_hash
            )
        } else if let Some(user_id) = ctx.user_id {
            format!("{}:playback:{}:{}:user:{}",
                ctx.key_prefix,
                self.name(),
                config_hash,
                user_id
            )
        } else {
            format!("{}:playback:{}:{}:anonymous",
                ctx.key_prefix,
                self.name(),
                config_hash
            )
        }
    }

    // ========== 服务注册说明 ==========
    //
    // Provider 通过 register_http_routes() 和 register_grpc_service() 注册以下端点：
    //
    // 1. Parse 端点（解析用户输入）
    //    HTTP: POST /api/providers/{instance_id}/parse
    //    gRPC: BilibiliService.Parse / AlistService.Parse
    //    用于：用户添加视频时，解析 URL/请求体，返回可选项供用户选择
    //    注意：
    //    - 解析的不一定是 URL（可能是特殊请求体，取决于 provider）
    //    - 返回的是 ParseResult（包含多种选项、元数据）
    //    - 客户端选择后构建 source_config，再调用 add_media API
    //
    // 2. Validate 端点（校验 source_config）
    //    HTTP: POST /api/providers/{instance_id}/validate
    //    gRPC: BilibiliService.Validate / AlistService.Validate
    //    用于：添加媒体前校验 source_config 是否符合规范
    //
    // 3. Browse 端点（浏览文件夹）
    //    HTTP: GET /api/providers/{instance_id}/browse?path=...
    //    gRPC: AlistService.Browse / EmbyService.Browse
    //    用于：用户浏览文件夹选择视频
    //
    // 4. Proxy 端点（代理流）
    //    HTTP: GET /api/providers/{instance_id}/proxy/*path
    //    用于：服务器代理模式，转发流量到第三方
    //
    // 参见实现示例：6.1.7 Bilibili Provider 实现示例

    // ========== source_config 校验（添加媒体时必需） ==========

    /// 校验 source_config 是否有效
    ///
    /// **调用时机**：用户添加媒体时，在存入数据库前调用
    ///
    /// **用途**：
    /// - 校验客户端构建的 source_config 是否符合 provider 规范
    /// - 检查必需字段是否存在
    /// - 验证字段值是否合法（如 bvid 格式、路径格式等）
    ///
    /// **流程**：
    /// 1. 用户调用 parse 端点 → 获取 ParseResult（多种选项）
    /// 2. 客户端选择选项 + 添加配置 → 构建 source_config
    /// 3. 客户端调用 add_media API，传入 source_config
    /// 4. 服务端调用 validate_source_config() 校验
    /// 5. 校验通过后存入数据库
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - source_config: 客户端构建的 source_config
    ///
    /// # 返回
    /// - Ok(()) 表示校验通过
    /// - Err(...) 表示校验失败，返回错误信息
    ///
    /// # 示例
    /// ```rust
    /// // Bilibili: 校验 bvid 和 cid
    /// async fn validate_source_config(
    ///     &self,
    ///     ctx: &ProviderContext<'_>,
    ///     source_config: &Value,
    /// ) -> Result<()> {
    ///     let bvid = source_config.get("bvid")
    ///         .and_then(|v| v.as_str())
    ///         .ok_or(Error::MissingField("bvid"))?;
    ///
    ///     if !BVID_REGEX.is_match(bvid) {
    ///         return Err(Error::InvalidBvid(bvid.to_string()));
    ///     }
    ///
    ///     Ok(())
    /// }
    /// ```
    async fn validate_source_config(
        &self,
        ctx: &ProviderContext<'_>,
        source_config: &Value,
    ) -> Result<()> {
        Ok(())  // 默认不校验
    }

    // ========== 生命周期钩子（可选） ==========

    /// 播放开始时调用
    ///
    /// 用于：
    /// - Emby: 通知服务器开始播放，启动转码任务
    /// - 统计：记录播放开始事件
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - media: 媒体对象
    /// - session_id: 播放会话 ID
    async fn on_playback_start(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }

    /// 播放停止时调用
    ///
    /// 用于：
    /// - Emby: 通知服务器停止播放
    /// - 统计：记录播放时长
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - media: 媒体对象
    /// - session_id: 播放会话 ID
    /// - position: 停止时的播放位置（秒）
    async fn on_playback_stop(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }

    /// 播放进度更新时调用
    ///
    /// 用于：
    /// - Emby: 同步播放进度到服务器
    /// - 统计：记录观看进度
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - media: 媒体对象
    /// - session_id: 播放会话 ID
    /// - position: 当前播放位置（秒）
    async fn on_playback_progress(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        Ok(())  // 默认空实现
    }
}
```

#### 6.1.2.1 HTTP 端点与内部 Trait 的区别

**关键设计**：区分用户交互（HTTP 端点）和内部系统调用（Trait 方法）

**HTTP 端点（用户使用）**：

Provider 通过 `register_http_routes()` 注册以下 HTTP 端点供用户使用：

1. **Parse 端点**（URL 解析）
   - 路径：`POST /api/providers/{instance_id}/parse`
   - 用途：用户添加视频时，从 URL 提取 source_config
   - 支持：Bilibili（视频URL解析）
   - 不支持：Alist、Emby、DirectUrl

2. **Browse 端点**（文件夹浏览）
   - 路径：`GET /api/providers/{instance_id}/browse?path=...`
   - 用途：用户浏览 provider 文件夹选择视频
   - 支持：Alist、Emby（文件系统浏览）
   - 不支持：Bilibili、DirectUrl

3. **Proxy 端点**（流代理）
   - 路径：`GET /api/providers/{instance_id}/proxy/*path`
   - 用途：服务器代理模式，转发流量到第三方
   - 支持：大部分 Provider

**内部 Trait（系统使用）**：

系统内部使用的 trait 方法，不直接暴露给用户：

```rust
// providers/traits_extended.rs

/// DynamicFolder trait - 动态文件夹能力（可选，内部使用）
///
/// 用于系统内部获取动态播放列表内容
/// 适用于：Alist, Emby
/// 不适用于：Bilibili, DirectUrl
///
/// 注意：这是内部 trait，不是 HTTP 端点
/// 用户浏览文件夹使用 browse HTTP 端点，不是这个 trait
#[async_trait]
pub trait DynamicFolder: MediaProvider {
    /// 列出目录内容（内部调用）
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing>;
}


// ==================== 统一数据结构 ====================

/// 项目（视频、文件夹、直播等）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Item {
    /// 项目 ID（全局唯一）
    pub id: ItemId,
    /// 项目名称
    pub name: String,
    /// 项目类型
    pub item_type: ItemType,
    /// 元数据
    pub metadata: Metadata,
    /// Provider 特定数据（不透明）
    #[serde(skip_serializing)]
    pub provider_data: Value,
}

/// 项目类型
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ItemType {
    Video,    // 视频文件
    Audio,    // 音频文件
    Folder,   // 文件夹
    Live,     // 直播流
    File,     // 其他文件
}

/// 项目 ID（全局唯一）
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ItemId {
    provider: String,      // Provider 名称
    internal_id: String,   // Provider 内部 ID
}

impl ItemId {
    pub fn new(provider: &str, internal_id: &str) -> Self {
        Self {
            provider: provider.to_string(),
            internal_id: internal_id.to_string(),
        }
    }

    pub fn to_string(&self) -> String {
        format!("{}:{}", self.provider, self.internal_id)
    }

    pub fn from_string(s: &str) -> Result<Self> {
        let parts: Vec<&str> = s.splitn(2, ':').collect();
        if parts.len() != 2 {
            return Err(Error::InvalidItemId(s.to_string()));
        }
        Ok(Self {
            provider: parts[0].to_string(),
            internal_id: parts[1].to_string(),
        })
    }
}

/// 项目路径（用于浏览和导航）
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ItemPath {
    pub provider: String,      // Provider 名称
    pub server_id: String,     // 服务器 ID
    pub segments: Vec<String>, // 路径段
}

/// 浏览结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowseResult {
    pub items: Vec<Item>,
    pub breadcrumbs: Vec<Breadcrumb>,
    pub total: usize,
    pub has_more: bool,
}

/// 面包屑
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Breadcrumb {
    pub name: String,
    pub path: ItemPath,
}

/// 搜索结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchResult {
    pub items: Vec<Item>,
    pub total: usize,
    pub has_more: bool,
}

/// 分页参数
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pagination {
    pub offset: usize,
    pub limit: usize,
}
```

**使用示例**：

```rust
// 检查 provider 是否支持动态文件夹能力（内部trait）
if let Some(dynamic_folder) = provider.as_any().downcast_ref::<dyn DynamicFolder>() {
    let result = dynamic_folder.list_directory(&ctx, &playlist, None, None, 0, 20).await?;
    // 处理目录列表
}

// 用户添加视频时，调用 HTTP parse 端点（不是 trait 方法）
// POST /api/providers/{instance_id}/parse
// 注意：每个 provider 返回的响应结构都是特定的
```

### 6.1.3 统一的视频信息结构

```rust
/// 统一的视频信息结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoInfo {
    pub id: String,
    pub source_type: String,
    pub title: String,
    pub r#type: VideoType,  // Video, Live, Folder

    pub url: Option<String>,
    pub thumbnail: Option<String>,
    pub duration: Option<u64>,  // 秒
    pub description: Option<String>,

    pub qualities: Vec<Quality>,
    pub subtitles: Vec<SubtitleInfo>,
    pub has_danmaku: bool,

    // 平台特定信息
    pub provider_data: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VideoType {
    Video,        // 点播视频
    Live,         // 直播
    Folder,       // 文件夹/目录
    Playlist,     // 播放列表
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlayUrl {
    pub quality: Quality,
    pub url: String,
    pub format: String,  // "mp4", "m3u8", "flv"
    pub codec: Option<String>,
    pub headers: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Quality {
    Auto,
    P360,
    P480,
    P720,
    P1080,
    P1440,
    P2160,  // 4K
}
```

### 6.1.3 Provider 注册表

> **完整实现见**：**[03-核心模块 § 3.7.2 Provider 注册表](./03-核心模块.md#372-provider-注册表)**

Provider 注册表采用 **Factory 模式**，支持动态注册和创建 Provider 实例：

```rust
// providers/registry.rs

/// Provider 工厂函数类型
pub type ProviderFactory = Arc<dyn Fn(ProviderConfig) -> Result<Arc<dyn MediaProvider>> + Send + Sync>;

/// Provider 注册表（全局单例）
pub struct ProviderRegistry {
    /// 工厂函数映射：provider_name -> factory
    factories: Arc<RwLock<HashMap<String, ProviderFactory>>>,

    /// 已实例化的 provider：instance_id -> provider
    instances: Arc<RwLock<HashMap<String, Arc<dyn MediaProvider>>>>,

    /// HTTP 路由构建器
    router_builder: Arc<RwLock<Router>>,
}

// 使用示例
let registry = Arc::new(ProviderRegistry::new());

// 注册 provider 工厂
registry.register_factory("bilibili", Arc::new(|config| {
    Ok(Arc::new(BilibiliProvider::new(config)?))
})).await;

registry.register_factory("alist", Arc::new(|config| {
    Ok(Arc::new(AlistProvider::new(config)?))
})).await;

// 创建实例
registry.create_instance("bilibili", "bilibili_main", config).await?;

// 获取实例
let provider = registry.get_instance("bilibili_main").await;

// 构建所有 Provider 的 HTTP 路由
let provider_routes = registry.build_routes().await;
```

**核心优势**：

- ✅ **插件化**：通过 Factory 函数动态注册
- ✅ **独立路由**：每个 Provider 可注册自己的 HTTP 端点
- ✅ **实例管理**：支持同一 Provider 类型创建多个实例
- ✅ **类型安全**：编译时检查，避免运行时错误

### 6.1.4 Provider 上下文

Provider 上下文包含了执行解析所需的所有信息：

```rust
// providers/context.rs

/// Provider 执行上下文
#[derive(Debug, Clone)]
pub struct ProviderContext<'a> {
    /// 请求者用户（播放时）
    pub requester: Option<&'a User>,

    /// 创建者用户（用于获取凭证）
    pub creator: Option<&'a User>,

    /// 房间信息
    pub room: Option<&'a Room>,

    /// Base URL（用于生成代理URL）
    pub base_url: Option<&'a str>,

    /// 用户token（用于代理URL）
    pub token: Option<&'a str>,

    /// 数据库连接池
    pub db: &'a PgPool,

    /// Redis连接池
    pub redis: &'a deadpool_redis::Pool,

    /// Provider注册表（用于获取其他provider）
    pub registry: &'a Arc<ProviderRegistry>,
}

impl<'a> ProviderContext<'a> {
    /// 创建新的上下文
    pub fn new(db: &'a PgPool, redis: &'a deadpool_redis::Pool, registry: &'a Arc<ProviderRegistry>) -> Self {
        Self {
            requester: None,
            creator: None,
            room: None,
            base_url: None,
            token: None,
            db,
            redis,
            registry,
        }
    }

    /// 设置请求者
    pub fn with_requester(mut self, requester: &'a User) -> Self {
        self.requester = Some(requester);
        self
    }

    /// 设置创建者
    pub fn with_creator(mut self, creator: &'a User) -> Self {
        self.creator = Some(creator);
        self
    }

    /// 设置房间
    pub fn with_room(mut self, room: &'a Room) -> Self {
        self.room = Some(room);
        self
    }

    /// 设置Base URL
    pub fn with_base_url(mut self, base_url: &'a str) -> Self {
        self.base_url = Some(base_url);
        self
    }

    /// 设置Token
    pub fn with_token(mut self, token: &'a str) -> Self {
        self.token = Some(token);
        self
    }

    /// 获取用户凭证（从数据库查询）
    pub async fn get_user_credential(
        &self,
        user_id: String,  // nanoid(12)
        provider_type: &str,
        server_id: &str,
    ) -> Result<Option<UserProviderCredential>> {
        let credential = sqlx::query_as!(
            UserProviderCredential,
            r#"
            SELECT id, user_id, provider, server_id, provider_instance_name,
                   credential_data, expires_at, created_at, updated_at
            FROM user_provider_credentials
            WHERE user_id = $1 AND provider = $2 AND server_id = $3
            "#,
            user_id,
            provider_type,
            server_id
        )
        .fetch_optional(self.db)
        .await?;

        Ok(credential)
    }

    /// 获取请求者凭证
    pub async fn get_requester_credential(
        &self,
        provider_type: &str,
        server_id: &str,
    ) -> Result<Option<UserProviderCredential>> {
        if let Some(requester) = self.requester {
            self.get_user_credential(requester.id, provider_type, server_id).await
        } else {
            Ok(None)
        }
    }

    /// 获取创建者凭证
    pub async fn get_creator_credential(
        &self,
        provider_type: &str,
        server_id: &str,
    ) -> Result<Option<UserProviderCredential>> {
        if let Some(creator) = self.creator {
            self.get_user_credential(creator.id, provider_type, server_id).await
        } else {
            Ok(None)
        }
    }
}
```

### 6.1.5 Provider 配置

Provider配置存储在数据库的 `source_config` JSONB字段中，不同Provider有不同的配置结构：

```rust
// providers/config.rs

/// Bilibili Provider 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BilibiliSourceConfig {
    /// 是否优先使用代理模式（影响default_mode的选择）
    /// Bilibili同时提供"direct"和"proxied"两种模式
    #[serde(default)]
    pub prefer_proxy: bool,

    /// 视频BV号
    pub bvid: String,

    /// 分P编号
    #[serde(default)]
    pub cid: u64,

    /// 番剧EPID（可选）
    #[serde(skip_serializing_if = "Option::is_none")]
    pub epid: Option<u64>,

    /// 清晰度（0=自动，80=1080P+，64=720P60，32=480P）
    #[serde(default)]
    pub quality: u32,

    /// 是否共享缓存（true=房间共享，false=用户独立）
    #[serde(default)]
    pub shared: bool,
}

/// Alist Provider 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlistSourceConfig {
    /// 是否优先使用代理模式
    /// Alist默认true，因为阿里云盘等存储通常需要代理
    #[serde(default = "default_true")]
    pub prefer_proxy: bool,

    /// 文件路径（格式："{server_id}/{path}"）
    pub path: String,

    /// 文件夹密码（可选）
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
}

fn default_true() -> bool { true }

/// Emby Provider 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbySourceConfig {
    /// 是否优先使用代理模式
    #[serde(default)]
    pub prefer_proxy: bool,

    /// 媒体项ID
    pub item_id: String,

    /// 是否启用转码
    #[serde(default)]
    pub transcode: bool,

    /// 最大比特率（kbps，0=无限制）
    #[serde(default)]
    pub max_bitrate: u32,
}

/// Direct URL Provider 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectUrlSourceConfig {
    /// 是否使用代理
    #[serde(default)]
    pub proxy: bool,

    /// 视频URL
    pub url: String,

    /// 自定义请求头（可选）
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: HashMap<String, String>,
}
```

**配置说明**：

- `prefer_proxy` 参数影响Provider设置的 `default_mode`，但不限制Provider提供哪些模式
- Provider可以在 `playback_infos` 中自主决定：
  - 只提供 "direct" 模式（如本地文件）
  - 只提供 "proxied" 模式（如必须代理的源）
  - 同时提供 "direct" 和 "proxied"（如Bilibili）
  - 提供其他自定义模式（如 "cdn1", "cdn2", "high", "low" 等）

### 6.1.6 解析结果与数据结构

#### 6.1.6.1 Parse 解析结果（添加媒体时）

**用途**：用户通过 parse 端点解析输入时的返回结果

**HTTP 端点**：`POST /api/providers/{instance_id}/parse`
**gRPC 端点**：`BilibiliService.Parse` / `AlistService.Parse`

**重要设计原则**：

> **⚠️ 不定义通用的 Parse 返回结构**
>
> 每个 provider 的 parse 返回结果差异很大，没有必要强制统一：
>
> - Bilibili: 多个分P列表 + 视频信息
> - Alist: 文件夹下的文件列表
> - Emby: 媒体库的剧集列表
> - DirectUrl: URL 验证结果
>
> **parse 是 HTTP/gRPC 端点，系统内部不会调用此接口**。
> 前端/客户端根据各 provider 的具体响应结构来处理。

**工作流**：

1. 用户调用 parse 端点（HTTP/gRPC），传入 input
2. Provider 返回**自定义的响应结构**（每个 provider 不同）
3. 客户端展示结果给用户，用户选择 + 添加配置
4. 客户端构建最终的 source_config
5. 客户端调用 add_media API，传入 source_config
6. 服务端调用 validate_source_config() 校验
7. 校验通过后存入数据库

**示例：各 Provider 的 Parse 响应**

---

**Bilibili Provider Parse 响应**：

```rust
// providers/bilibili/types.rs

/// Bilibili parse 响应（特定于 Bilibili）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BilibiliParseResponse {
    /// 视频基本信息
    pub video_info: VideoInfo,

    /// 分P列表
    pub pages: Vec<VideoPage>,

    /// 默认选中的分P索引
    pub default_page: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoInfo {
    pub bvid: String,
    pub title: String,
    pub author: String,
    pub thumbnail: String,
    pub description: String,
    pub views: i64,
    pub likes: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoPage {
    pub page: i32,
    pub cid: i64,
    pub part: String,      // 分P标题
    pub duration: i32,     // 秒
}
```

**请求示例**：

```json
POST /api/providers/bilibili_main/parse
{
  "input": "https://www.bilibili.com/video/BV1xx"
}
```

**响应示例**：

```json
{
  "video_info": {
    "bvid": "BV1xx",
    "title": "视频总标题",
    "author": "UP主名称",
    "thumbnail": "https://...",
    "views": 1000000,
    "likes": 50000
  },
  "pages": [
    {"page": 1, "cid": 123, "part": "第一集", "duration": 1234},
    {"page": 2, "cid": 456, "part": "第二集", "duration": 2345}
  ],
  "default_page": 0
}
```

---

**Alist Provider Parse 响应**：

```rust
// providers/alist/types.rs

/// Alist parse 响应（特定于 Alist）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlistParseResponse {
    /// 当前路径
    pub path: String,

    /// 文件/文件夹列表
    pub items: Vec<AlistItem>,

    /// 是否还有更多
    pub has_more: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlistItem {
    pub name: String,
    pub path: String,
    pub is_dir: bool,
    pub size: i64,
    pub modified: String,
    pub thumbnail: Option<String>,
}
```

**响应示例**：

```json
{
  "path": "/movies",
  "items": [
    {
      "name": "movie1.mp4",
      "path": "/movies/movie1.mp4",
      "is_dir": false,
      "size": 1073741824,
      "modified": "2024-01-01T12:00:00Z"
    },
    {
      "name": "series",
      "path": "/movies/series",
      "is_dir": true,
      "size": 0,
      "modified": "2024-01-01T12:00:00Z"
    }
  ],
  "has_more": false
}
```

---

**DirectUrl Provider Parse 响应**：

```rust
// providers/direct_url/types.rs

/// DirectUrl parse 响应（特定于 DirectUrl）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectUrlParseResponse {
    /// URL 地址
    pub url: String,

    /// 是否有效
    pub valid: bool,

    /// Content-Type
    pub content_type: Option<String>,

    /// 文件大小
    pub content_length: Option<i64>,

    /// 错误信息（如果无效）
    pub error: Option<String>,
}
```

**响应示例**：

```json
{
  "url": "https://example.com/video.mp4",
  "valid": true,
  "content_type": "video/mp4",
  "content_length": 1073741824,
  "error": null
}
```

---

**总结**：

✅ **每个 provider 自己定义 parse 响应结构**
✅ **不强制统一数据结构**
✅ **前端根据 provider 类型处理不同的响应**
✅ **系统内部不调用 parse 接口**

#### 6.1.6.2 播放信息生成结果（播放时）

Provider 动态生成的数据结构（不存储在数据库中）：

```rust
/// 播放信息生成结果（generate_playback方法的返回）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackResult {
    /// 播放模式HashMap（多个PlaybackInfo）
    /// Provider可自定义任意模式名称，如：
    /// - "direct" 和 "proxied"（常见）
    /// - "cdn1"、"cdn2"、"cdn3"（多CDN）
    /// - "high"、"medium"、"low"（不同质量）
    pub playback_infos: HashMap<String, PlaybackInfo>,

    /// 默认模式名称（必须是playback_infos中的key）
    /// Provider根据 source_config.prefer_proxy 等参数决定
    pub default_mode: String,

    /// 媒体级别元数据（duration、thumbnail、title等）
    pub metadata: HashMap<String, Value>,
}

/// 播放信息（每个模式的完整信息）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackInfo {
    /// 播放URL列表（不同清晰度、编码）
    pub urls: Vec<PlaybackUrl>,

    /// 默认URL索引
    #[serde(default)]
    pub default_url_index: usize,

    /// 字幕列表
    #[serde(default)]
    pub subtitles: Vec<Subtitle>,

    /// 默认字幕索引
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_subtitle_index: Option<usize>,

    /// 弹幕列表（每个模式可以有不同的弹幕源）
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub danmakus: Vec<Danmaku>,
}

/// 播放URL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackUrl {
    /// 显示名称（如 "1080P", "HEVC 4K", "720P"）
    pub name: String,

    /// 完整URL
    pub url: String,

    /// 请求头（如果需要）
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: HashMap<String, String>,

    /// 过期时间（可选）
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expire_at: Option<DateTime<Utc>>,

    /// URL级别元数据（分辨率、编码、比特率、FPS等）
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub metadata: HashMap<String, Value>,
}

/// 字幕
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subtitle {
    /// 显示名称（如 "简体中文", "English"）
    pub name: String,

    /// 语言代码（ISO 639-1，如 "zh", "en", "ja"）
    pub language: String,

    /// 字幕URL列表
    pub urls: Vec<SubtitleUrl>,

    /// 默认URL索引
    #[serde(default)]
    pub default_url_index: usize,
}

/// 字幕URL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleUrl {
    /// 显示名称（如 "原始", "代理"）
    pub name: String,

    /// 完整URL
    pub url: String,

    /// 请求头
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: HashMap<String, String>,
}

/// 弹幕
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Danmaku {
    /// 显示名称（如 "Bilibili弹幕", "本地弹幕", "弹幕1"）
    pub name: String,

    /// 弹幕URL
    pub url: String,

    /// 弹幕类型（可选，如 "bilibili", "ass", "xml"）
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,

    /// 请求头
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: HashMap<String, String>,
}
```

**设计说明**：

1. **三阶段设计**：
   - **阶段1（解析）**：用户调用 parse 端点（HTTP/gRPC）→ Provider 返回 ParseResult（多种选项）
   - **阶段2（添加）**：客户端构建 source_config → 调用 add_media API → validate_source_config() 校验 → 存数据库
   - **阶段3（播放）**：系统调用 `generate_playback(source_config)` trait 方法 → Provider 返回 PlaybackResult → 返回客户端
2. **动态生成**：播放信息由Provider根据source_config实时生成，不存储在数据库
3. **灵活模式系统**：Provider可自定义任意数量和类型的播放模式
4. **双层metadata**：
   - `PlaybackUrl.metadata`：URL级别信息（分辨率、编码、比特率等）
   - `PlaybackResult.metadata`：媒体级别信息（duration、thumbnail、title等）
5. **模式独立**：每个PlaybackInfo包含完整的urls、subtitles、danmakus
6. **弹幕对象化**：danmakus是对象数组，每个包含name、url、format等，支持多弹幕源

### 6.1.7 Bilibili Provider 实现示例

```rust
// media/providers/bilibili.rs
pub struct BilibiliProvider {
    http_client: reqwest::Client,
    credential_store: Arc<CredentialStore>,
}

#[async_trait]
impl MediaProvider for BilibiliProvider {
    fn name(&self) -> &'static str {
        "bilibili"
    }

    fn instance_id(&self) -> &str {
        &self.config.instance_id
    }

    // ========== gRPC 服务注册 ==========

    async fn register_grpc_service(&self, router: TonicRouter) -> Result<TonicRouter> {
        let service = BilibiliServiceImpl::new(self.clone());
        Ok(router.add_service(BilibiliServiceServer::new(service)))
    }

    // ========== HTTP 路由注册 ==========

    async fn register_http_routes(&self, router: Router<AppState>) -> Result<Router<AppState>> {
        let provider = Arc::new(self.clone());

        Ok(router
            // Parse 端点：解析用户输入
            .route(
                &format!("/api/providers/{}/parse", self.instance_id()),
                post(Self::handle_parse)
            )
            // Validate 端点：校验 source_config
            .route(
                &format!("/api/providers/{}/validate", self.instance_id()),
                post(Self::handle_validate)
            )
            // Proxy 端点：代理模式下的视频流
            .route(
                &format!("/api/providers/{}/proxy/*path", self.instance_id()),
                get(Self::handle_proxy)
            )
            .with_state(provider))
    }

    // ========== source_config 校验 ==========

    async fn validate_source_config(
        &self,
        ctx: &ProviderContext<'_>,
        source_config: &Value,
    ) -> Result<()> {
        // 1. 校验必需字段
        let bvid = source_config.get("bvid")
            .and_then(|v| v.as_str())
            .ok_or(Error::MissingField("bvid"))?;

        let cid = source_config.get("cid")
            .and_then(|v| v.as_i64())
            .ok_or(Error::MissingField("cid"))?;

        // 2. 校验 bvid 格式
        if !BVID_REGEX.is_match(bvid) {
            return Err(Error::InvalidBvid(bvid.to_string()));
        }

        // 3. 校验 cid 有效性
        if cid <= 0 {
            return Err(Error::InvalidCid(cid));
        }

        // 4. 校验可选字段
        if let Some(quality) = source_config.get("quality").and_then(|v| v.as_i64()) {
            if ![0, 16, 32, 64, 80, 112, 116, 120].contains(&quality) {
                return Err(Error::InvalidQuality(quality));
            }
        }

        Ok(())
    }

    // ========== 核心 Trait 方法（系统内部调用） ==========

    async fn generate_playback(
        &self,
        ctx: &ProviderContext<'_>,
        source_config: &Value,
    ) -> Result<PlaybackResult> {
        // 1. 从 source_config 解析配置
        let config: BilibiliSourceConfig = serde_json::from_value(source_config.clone())?;

        // 2. 获取用户凭证
        let credential = ctx.get_requester_credential("bilibili", None)
            .await?
            .ok_or(Error::MissingCredentials)?;

        // 3. 调用 Bilibili API 获取视频信息
        let video_info = self.fetch_video_info(&config.bvid, &credential).await?;

        // 4. 构建不同模式的URL列表
        let base_url = ctx.base_url.ok_or(Error::MissingBaseUrl)?;
        let token = ctx.token.ok_or(Error::MissingToken)?;

        let mut direct_urls = Vec::new();
        let mut proxied_urls = Vec::new();

        // 构建各个清晰度的URL（带metadata）
        for quality in &video_info.dash.video {
            let mut url_metadata = HashMap::new();
            url_metadata.insert("resolution".to_string(), json!(quality.width.to_string() + "x" + &quality.height.to_string()));
            url_metadata.insert("bitrate".to_string(), json!(quality.bandwidth));
            url_metadata.insert("codec".to_string(), json!(quality.codec));
            url_metadata.insert("fps".to_string(), json!(quality.frame_rate));

            // 直连URL
            direct_urls.push(PlaybackUrl {
                name: format!("{}P", quality.height),
                url: quality.base_url.clone(),
                headers: self.build_bili_headers(),
                expire_at: Some(Utc::now() + Duration::hours(2)),
                metadata: url_metadata.clone(),
            });

            // 代理URL
            proxied_urls.push(PlaybackUrl {
                name: format!("{}P", quality.height),
                url: format!(
                    "{}/api/providers/{}/proxy/{}?quality={}&codec={}&token={}",
                    base_url,
                    self.instance_id(),
                    config.bvid,
                    quality.height,
                    quality.codec,
                    token
                ),
                headers: HashMap::new(),
                expire_at: None,  // 代理URL不过期
                metadata: url_metadata,
            });
        }

        // 5. 构建字幕列表
        let subtitles: Vec<Subtitle> = video_info.subtitles.iter().map(|sub| {
            Subtitle {
                name: sub.lan_doc.clone(),
                language: sub.lan.clone(),
                urls: vec![
                    SubtitleUrl {
                        name: "原始".to_string(),
                        url: sub.subtitle_url.clone(),
                        headers: HashMap::new(),
                    },
                ],
                default_url_index: 0,
            }
        }).collect();

        let default_subtitle_index = subtitles.iter()
            .position(|s| s.language == "zh-CN");

        // 6. 构建两种模式的PlaybackInfo
        let mut playback_infos = HashMap::new();

        // 7. 构建弹幕列表
        let danmakus = vec![
            Danmaku {
                name: "Bilibili弹幕".to_string(),
                url: format!("/api/danmaku/{}/{}", &config.bvid, video_info.cid),
                format: Some("bilibili".to_string()),
                headers: HashMap::new(),
            },
        ];

        playback_infos.insert("direct".to_string(), PlaybackInfo {
            urls: direct_urls,
            default_url_index: 0,
            subtitles: subtitles.clone(),
            default_subtitle_index,
            danmakus: danmakus.clone(),
        });

        playback_infos.insert("proxied".to_string(), PlaybackInfo {
            urls: proxied_urls,
            default_url_index: 0,
            subtitles,
            default_subtitle_index,
            danmakus,
        });

        // 7. 根据配置决定默认模式
        let default_mode = if config.prefer_proxy {
            "proxied".to_string()
        } else {
            "direct".to_string()
        };

        // 8. 构建媒体级metadata
        let mut metadata = HashMap::new();
        metadata.insert("duration".to_string(), json!(video_info.duration));
        metadata.insert("thumbnail".to_string(), json!(video_info.pic));
        metadata.insert("title".to_string(), json!(video_info.title));
        metadata.insert("author".to_string(), json!(video_info.author));

        Ok(PlaybackResult {
            playback_infos,
            default_mode,
            metadata,
        })
    }
}

// ========== HTTP 端点处理器（用户调用） ==========

impl BilibiliProvider {
    /// Parse 端点处理器：解析用户输入，返回 Bilibili 特定的可选项
    ///
    /// POST /api/providers/{instance_id}/parse
    /// Body: {"input": "https://www.bilibili.com/video/BV1xx", "options": {...}}
    async fn handle_parse(
        State(provider): State<Arc<BilibiliProvider>>,
        Json(req): Json<ParseRequest>,
    ) -> Result<Json<BilibiliParseResponse>> {
        // 1. 从输入提取BV号
        let bvid = provider.extract_bvid(&req.input)?;

        // 2. 调用Bilibili API获取视频信息（包括分P列表）
        let video_info = provider.fetch_video_info(&bvid).await?;

        // 3. 构建视频基本信息
        let video_info_dto = VideoInfo {
            bvid: video_info.bvid.clone(),
            title: video_info.title.clone(),
            author: video_info.author.clone(),
            thumbnail: video_info.pic.clone(),
            description: video_info.desc.clone(),
            views: video_info.stat.view,
            likes: video_info.stat.like,
        };

        // 4. 构建分P列表
        let pages: Vec<VideoPage> = video_info.pages.iter().map(|page| {
            VideoPage {
                page: page.page,
                cid: page.cid,
                part: page.part.clone(),
                duration: page.duration,
            }
        }).collect();

        // 5. 返回 Bilibili 特定的响应结构
        Ok(Json(BilibiliParseResponse {
            video_info: video_info_dto,
            pages,
            default_page: 0,  // 默认选择第一个分P
        }))
    }

    /// Validate 端点处理器：校验 source_config
    ///
    /// POST /api/providers/{instance_id}/validate
    /// Body: {"source_config": {...}}
    async fn handle_validate(
        State(provider): State<Arc<BilibiliProvider>>,
        Json(req): Json<ValidateRequest>,
    ) -> Result<Json<ValidateResponse>> {
        let ctx = ProviderContext::new();  // 校验不需要复杂上下文

        match provider.validate_source_config(&ctx, &req.source_config).await {
            Ok(()) => Ok(Json(ValidateResponse {
                valid: true,
                errors: vec![],
            })),
            Err(e) => Ok(Json(ValidateResponse {
                valid: false,
                errors: vec![e.to_string()],
            })),
        }
    }

    /// Proxy 端点处理器：代理模式下的视频流
    ///
    /// GET /api/providers/{instance_id}/proxy/{bvid}?quality=1080&codec=...&token=...
    async fn handle_proxy(
        State(provider): State<Arc<BilibiliProvider>>,
        Path(path): Path<String>,
        Query(params): Query<HashMap<String, String>>,
    ) -> Result<impl IntoResponse> {
        // 实现代理逻辑...
        // 见 10-视频链接过期与代理机制.md
        todo!()
    }

    // ========== 辅助方法 ==========

    /// 从URL提取BV号
    fn extract_bvid(&self, url: &str) -> Result<String> {
        // 支持多种格式：
        // - https://www.bilibili.com/video/BV1xx
        // - https://b23.tv/BV1xx
        // - BV1xx
        if let Some(cap) = BVID_REGEX.captures(url) {
            Ok(cap[1].to_string())
        } else {
            Err(Error::InvalidUrl)
        }
    }

    /// 获取视频基本信息（用于 parse HTTP 端点）
    async fn fetch_basic_info(&self, bvid: &str) -> Result<BasicVideoInfo> {
        let api_url = format!("https://api.bilibili.com/x/web-interface/view?bvid={}", bvid);
        let response: BilibiliVideoResponse = self.http_client
            .get(&api_url)
            .send()
            .await?
            .json()
            .await?;

        Ok(BasicVideoInfo {
            title: response.data.title,
            pic: response.data.pic,
        })
    }

    /// 获取完整视频信息（用于generate_playback）
    async fn fetch_video_info(&self, bvid: &str, credential: &Credential) -> Result<VideoInfo> {
        // 调用API获取完整信息（包括DASH URL等）
        // ...
    }
}
    }
}
```

### 6.1.8 三阶段设计流程

#### 阶段1：解析输入

```
用户输入 → parse 端点（HTTP/gRPC）→ Provider 特定响应（多种选项）→ 展示给用户
```

#### 阶段2：构建并添加媒体

```
用户选择选项 + 添加配置 → 构建 source_config → add_media API → validate → 存入数据库
```

#### 阶段3：播放媒体

```
读取Media（含source_config） → Provider.generate_playback() → PlaybackResult
                                                                      ↓
                                                              返回给客户端
```

**示例**：

```rust
// 读取媒体
let media = db.get_media(media_id).await?;

// 生成播放信息
let result = provider.generate_playback(&ctx, &media).await?;

// 返回给客户端
Response {
    playback_infos: result.playback_infos,  // {"direct": {...}, "proxied": {...}}
    default_mode: result.default_mode,       // "direct" 或 "proxied"
    metadata: result.metadata,               // {duration, thumbnail, title, ...}
}
```

#### API 返回示例（播放时）

```json
{
  "id": "uuid-...",
  "name": "视频标题",
  "playback_infos": {
    "direct": {
      "urls": [
        {
          "name": "1080P",
          "url": "https://upos-xxx.bilivideo.com/...",
          "headers": {
            "Referer": "https://www.bilibili.com"
          },
          "expire_at": "2026-02-01T12:00:00Z",
          "metadata": {
            "resolution": "1920x1080",
            "bitrate": 2000000,
            "codec": "avc",
            "fps": 30
          }
        },
        {
          "name": "720P",
          "url": "https://upos-xxx.bilivideo.com/...",
          "headers": {
            "Referer": "https://www.bilibili.com"
          },
          "expire_at": "2026-02-01T12:00:00Z",
          "metadata": {
            "resolution": "1280x720",
            "bitrate": 1000000,
            "codec": "avc",
            "fps": 30
          }
        }
      ],
      "default_url_index": 0,
      "subtitles": [
        {
          "name": "简体中文",
          "language": "zh-CN",
          "urls": [
            {
              "name": "原始",
              "url": "https://i0.hdslb.com/..."
            }
          ],
          "default_url_index": 0
        }
      ],
      "default_subtitle_index": 0,
      "danmakus": [
        {
          "name": "Bilibili弹幕",
          "url": "/api/danmaku/BV1xx/12345",
          "format": "bilibili"
        }
      ]
    },
    "proxied": {
      "urls": [
        {
          "name": "1080P",
          "url": "https://synctv.example.com/api/provider/bilibili_main/proxy/BV1xx?quality=1080p&token=...",
          "headers": {},
          "metadata": {
            "resolution": "1920x1080",
            "bitrate": 2000000,
            "codec": "avc",
            "fps": 30
          }
        },
        {
          "name": "720P",
          "url": "https://synctv.example.com/api/provider/bilibili_main/proxy/BV1xx?quality=720p&token=...",
          "headers": {},
          "metadata": {
            "resolution": "1280x720",
            "bitrate": 1000000,
            "codec": "avc",
            "fps": 30
          }
        }
      ],
      "default_url_index": 0,
      "subtitles": [
        {
          "name": "简体中文",
          "language": "zh-CN",
          "urls": [
            {
              "name": "原始",
              "url": "https://i0.hdslb.com/..."
            }
          ],
          "default_url_index": 0
        }
      ],
      "default_subtitle_index": 0,
      "danmakus": [
        {
          "name": "Bilibili弹幕",
          "url": "/api/danmaku/BV1xx/12345",
          "format": "bilibili"
        }
      ]
    }
  },
  "default_mode": "proxied",
  "metadata": {
    "duration": 600.5,
    "thumbnail": "https://i0.hdslb.com/bfs/...",
    "title": "视频标题",
    "author": "UP主名称"
  }
}
```

**说明**：

- 这是播放时动态生成的数据（不存储在数据库）
- `playback_infos` 包含多个播放模式（direct和proxied）
- 每个模式有独立的URLs、字幕和弹幕列表
- `danmakus` 是对象数组，每个弹幕源包含name、url、format等信息
- `default_mode` 由Provider根据source_config.prefer_proxy决定
- `metadata` 包含媒体级别信息（duration、thumbnail等）
- URL的metadata包含质量信息（分辨率、编码、比特率等）

### 6.1.9 动态文件夹与浏览能力

**设计目标**：支持 Alist/Emby 等 Provider 的文件夹浏览和动态内容加载

#### 6.1.9.1 使用场景

| 场景 | 说明 | 涉及 Provider |
|------|------|--------------|
| **静态添加** | 用户手动添加单个视频 | 所有 Provider |
| **浏览选择** | 用户浏览文件夹，选择视频添加 | Alist, Emby |
| **动态文件夹** | 添加整个文件夹，播放时动态加载内容 | Alist, Emby |
| **搜索添加** | 用户搜索视频，从结果中添加 | Alist, Emby |

#### 6.1.9.2 DynamicFolder Trait（可选能力）

**设计理念**：动态文件夹功能作为**可选 trait**，不是所有 Provider 都需要实现。

```rust
/// 动态文件夹能力（可选）
///
/// 支持文件系统浏览和动态内容列表的 Provider 可以实现此 trait
/// 例如：Alist（文件服务器）、Emby（媒体库）
///
/// 不支持的 Provider（如 Bilibili、直接URL）无需实现
#[async_trait]
pub trait DynamicFolder: MediaProvider {
    /// 列出目录内容
    ///
    /// # 使用场景
    /// 1. **用户浏览**：通过 HTTP browse 端点，用户浏览 provider 文件夹选择内容
    /// 2. **动态播放列表**：添加动态文件夹后，公共 API 调用此方法获取内容
    ///
    /// # 参数
    /// - `ctx`: Provider 上下文
    /// - `playlist`: 动态目录对象（包含 source_config 中的基础路径）
    /// - `relative_path`: 相对路径（可选，用于子目录导航）
    /// - `keyword`: 搜索关键词（可选）
    /// - `page`: 页码
    /// - `page_size`: 每页数量
    ///
    /// # 返回
    /// DirectoryListing {
    ///   items: Vec<DirectoryItem>,   // 文件和文件夹列表
    ///   total: usize,                // 总数
    ///   has_more: bool,              // 是否有更多
    /// }
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing>;
}

/// 目录列表项
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectoryItem {
    /// 项目名称
    pub name: String,
    /// 项目类型
    pub item_type: ItemType,  // Folder | Video | Live
    /// 相对路径（用于继续导航）
    pub relative_path: String,  // 相对于动态目录基础路径
    /// 完整配置（用于播放）
    pub source_config: SourceConfig,
    /// 元数据（可选，如文件大小、修改时间）
    pub metadata: HashMap<String, Value>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ItemType {
    Folder,   // 可继续导航的文件夹
    Video,    // 可播放的视频文件
    Live,     // 可播放的直播流
}

/// 目录列表结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectoryListing {
    pub items: Vec<DirectoryItem>,
    pub total: usize,
    pub has_more: bool,
}
```

**关键设计点**：

1. **可选实现**：

   ```rust
   // Provider 注册时检查是否支持动态文件夹
   fn supports_dynamic_folder(&self) -> bool {
       // 默认实现返回 false
       false
   }

   // Alist Provider 实现
   impl DynamicFolder for AlistProvider {
       async fn list_directory(...) -> Result<DirectoryListing> {
           // 实现文件夹列表逻辑
       }
   }
   ```

2. **两种调用场景**：

   **场景 A：用户浏览（HTTP browse 端点）**

   ```rust
   // 用户通过 Provider 专用端点浏览文件夹
   // GET /api/providers/{instance_id}/browse?path=/movies&page=1
   //
   // 这是管理员/用户在配置时使用的功能
   // 调用路径：HTTP 端点 → Provider.list_directory()
   async fn handle_provider_browse(
       Path((instance_id, path)): Path<(String, String)>,
       State(registry): State<Arc<ProviderRegistry>>,
   ) -> Result<Json<DirectoryListing>> {
       let provider = registry.get_instance(&instance_id)?;

       // 检查是否支持动态文件夹
       let dynamic_provider = provider.as_any()
           .downcast_ref::<dyn DynamicFolder>()
           .ok_or(Error::NotSupported)?;

       // 创建临时 playlist 对象用于浏览
       let temp_playlist = Playlist {
           source_config: json!({"path": path}),
           ...
       };

       let listing = dynamic_provider.list_directory(
           &ctx,
           &temp_playlist,
           None,  // 根目录
           None,  // 无搜索
           params.page,
           params.page_size,
       ).await?;

       Ok(Json(listing))
   }
   ```

   **场景 B：动态播放列表（公共 API）**

   ```rust
   // 用户添加动态文件夹后，播放列表 API 调用
   // GET /api/rooms/{room_id}/playlists/{playlist_id}/items?relative_path=/action
   //
   // 这是添加动态文件夹后，用户播放时使用的功能
   // 调用路径：公共 API → Service → Provider.list_directory()
   async fn list_playlist_items(
       playlist_id: String,
       params: ListItemsParams,
   ) -> Result<Json<DirectoryListing>> {
       let playlist = db.get_playlist(&playlist_id).await?;

       // 检查是否为动态播放列表
       if let Some(provider_name) = playlist.source_provider {
           let provider = registry.get(&provider_name)?;

           // 检查是否支持动态文件夹
           let dynamic_provider = provider.as_any()
               .downcast_ref::<dyn DynamicFolder>()
               .ok_or(Error::NotSupported)?;

           let listing = dynamic_provider.list_directory(
               &ctx,
               &playlist,  // 使用实际的 playlist 对象
               params.relative_path.as_deref(),
               params.keyword.as_deref(),
               params.page,
               params.page_size,
           ).await?;

           Ok(Json(listing))
       } else {
           // 静态播放列表，从 medias 表查询
           list_static_medias(playlist_id, params).await
       }
   }
   ```

3. **区别与联系**：

   | 维度 | 场景 A（浏览） | 场景 B（播放列表） |
   |------|---------------|-------------------|
   | **URL** | `/api/providers/{id}/browse` | `/api/rooms/{room_id}/playlists/{id}/items` |
   | **权限** | 管理员/配置者 | 房间成员 |
   | **数据持久化** | ❌ 临时浏览 | ✅ playlist 记录已存储 |
   | **配置来源** | 临时传递 | 从数据库读取 |
   | **用途** | 选择内容添加 | 播放/浏览已添加的内容 |
   | **调用方法** | 相同（`list_directory`） | 相同（`list_directory`） |

**实现示例**：

```rust
// Bilibili Provider - 不支持动态文件夹
impl MediaProvider for BilibiliProvider {
    fn supports_dynamic_folder(&self) -> bool {
        false  // Bilibili 只支持单个视频，不支持文件夹浏览
    }

    // 不实现 DynamicFolder trait
}

// Alist Provider - 支持动态文件夹
impl MediaProvider for AlistProvider {
    fn supports_dynamic_folder(&self) -> bool {
        true
    }
}

impl DynamicFolder for AlistProvider {
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing> {
        // 实现 Alist 文件夹列表逻辑
        // ...
    }
}
```

#### 6.1.9.4 数据库设计

> **参考**：详细设计见 [04-数据库设计 § 2.4.1](./04-数据库设计.md#241-播放列表目录表-playlists)

**核心概念**：动态文件夹是通过 **playlists 表**实现的，而不是 medias 表。

```sql
-- playlists 表（播放列表/目录）
CREATE TABLE playlists (
    id CHAR(12) PRIMARY KEY,
    room_id CHAR(12) NOT NULL,
    creator_id CHAR(12) NOT NULL,

    -- 目录名称
    name VARCHAR(255) NOT NULL DEFAULT '',

    -- 树形结构
    parent_id CHAR(12) REFERENCES playlists(id),
    position INT NOT NULL DEFAULT 0,

    -- ========== 动态目录支持 ==========
    -- 如果 source_provider 不为 NULL，则为动态目录（内容由供应商动态提供）
    -- 如果 source_provider 为 NULL，则为静态目录（可手动添加 medias）
    source_provider source_provider,        -- 'alist', 'emby', NULL
    source_config JSONB,                   -- 供应商配置
                                           -- Alist: {"path": "/{server_id}/movies", "password": ""}
                                           -- Emby: {"path": "/{server_id}/{item_id}"}
    provider_instance_name VARCHAR(64),    -- 推荐的后端实例（可选）

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束：动态目录验证
    CONSTRAINT valid_dynamic_folder CHECK (
        (source_provider IS NOT NULL AND source_config IS NOT NULL)
        OR
        (source_provider IS NULL AND source_config IS NULL)
    )
);

-- medias 表（媒体文件）
CREATE TABLE medias (
    id CHAR(12) PRIMARY KEY,
    playlist_id CHAR(12) NOT NULL REFERENCES playlists(id),
    room_id CHAR(12) NOT NULL,

    name VARCHAR(255) NOT NULL,
    position INT NOT NULL DEFAULT 0,

    -- Provider 信息（用于播放）
    source_provider source_provider NOT NULL,
    source_config JSONB NOT NULL,        -- 媒体特定配置（如 Bilibili 的 bvid/cid）
    provider_instance_name VARCHAR(64),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**关键区别**：

| 表 | 用途 | 动态支持 |
|----|------|---------|
| **playlists** | 目录/文件夹 | ✓ 支持动态目录（source_provider 不为 NULL） |
| **medias** | 具体的媒体文件 | ✗ 不支持，只存储可播放的媒体项 |

**动态目录判断**：

```rust
fn is_dynamic_playlist(playlist: &Playlist) -> bool {
    playlist.source_provider.is_some()
}
```

#### 6.1.9.5 工作流程

##### 浏览并选择视频

```
1. 用户点击"浏览 Alist"
   ↓
2. 调用 GET /api/providers/{instance_id}/browse
   - 返回根目录（或列出所有服务器）
   ↓
3. 用户点击文件夹，继续浏览
   ↓
4. 用户选择视频文件，点击"添加"
   ↓
5. 调用 POST /api/rooms/{room_id}/medias
   - 传入 item_id
   - 创建 media 记录（is_dynamic_folder=false）
   ↓
6. 视频添加到播放列表
```

##### 添加动态文件夹

```
1. 用户点击"添加动态文件夹"
   ↓
2. 浏览选择目标文件夹（使用 browse API）
   ↓
3. 调用 POST /api/rooms/{room_id}/playlists
   - parent_id: 父目录ID
   - name: 文件夹名称
   - source_provider: "alist" / "emby"
   - source_config: {"path": "/{server_id}/movies"}
   - provider_instance_name: "alist_main" (可选)
   ↓
4. 创建 playlist 记录（source_provider 不为 NULL）
   ↓
5. 文件夹图标显示在播放列表中
```

##### 打开动态文件夹

```
1. 用户点击动态文件夹图标
   ↓
2. 调用 GET /api/rooms/{room_id}/playlists/{playlist_id}/items?relative_path=...
   ↓
3. 服务器：
   - 读取 playlist 记录
   - 检查 source_provider 是否为 NULL
   - 如果不为 NULL（动态目录）：
     - 从 source_config 获取配置
     - 拼接 relative_path（如果有）
     - 调用 provider.list_items()
   - 如果为 NULL（静态目录）：
     - 从 medias 表查询子项
   ↓
4. 返回 BrowseResult（items + breadcrumbs）
   ↓
5. 前端显示文件列表和面包屑导航
   ↓
6. 用户可以：
   - 点击子文件夹 → 递归打开（继续调用带 relative_path 的 API）
   - 点击视频 → 直接播放（临时播放，不存储）
   - 点击"添加到播放列表" → 创建 media 记录到当前 playlist
```

**关键点**：

1. **动态文件夹 = playlist 记录**（source_provider 不为 NULL）
2. **静态文件夹 = playlist 记录**（source_provider 为 NULL，包含 medias 子项）
3. **媒体文件 = media 记录**（属于某个 playlist）
4. **relative_path 参数**：
   - 用于在动态文件夹内部导航，不创建新的 playlist
   - 相对于动态目录基础路径（`source_config.path`）的相对路径
   - **重要约定**：`relative_path` 总是以 `/` 开头
   - **拼接逻辑**：`full_path = base_path.trim_end_matches('/') + relative_path`
   - 详细设计见 [04-数据库设计 § 2.4.9](./04-数据库设计.md#249-relative_path-导航机制)
   - 命名理由：准确描述其性质（相对路径），符合 Rust 命名习惯（蛇形命名）

#### 6.1.9.6 API 设计

```rust
// ==================== Provider 级别 API ====================

// 浏览 Provider 内容（用于选择文件夹/文件）
GET /api/providers/{instance_id}/browse?path={path}&offset={offset}&limit={limit}
// 返回：BrowseResult { items, breadcrumbs, total, has_more }

// 搜索 Provider 内容
GET /api/providers/{instance_id}/search?query={query}&scope={scope}&offset={offset}&limit={limit}
// 返回：SearchResult { items, total, has_more }

// ==================== Playlist 级别 API ====================

// 创建播放列表（静态或动态）
POST /api/rooms/{room_id}/playlists
// 请求：
// {
//   "parent_id": "uuid",            // 父目录ID
//   "name": "我的收藏",
//   "source_provider": null,        // NULL = 静态目录
//   "source_config": null
// }
// 或者：
// {
//   "parent_id": "uuid",
//   "name": "Alist电影",
//   "source_provider": "alist",     // 动态目录
//   "source_config": {"path": "/{server_id}/movies"},
//   "provider_instance_name": "alist_main"
// }
// 返回：Playlist { id, source_provider, ... }

// 获取播放列表内容（统一接口，自动区分静态/动态）
GET /api/rooms/{room_id}/playlists/{playlist_id}/items?relative_path={relative_path}&offset={offset}&limit={limit}
// 行为：
// - 如果 playlist.source_provider IS NULL：
//     从 medias 表查询子项
// - 如果 playlist.source_provider IS NOT NULL：
//     调用 provider.list_items(source_config + relative_path)
// 返回：BrowseResult { items, breadcrumbs, total, has_more }

// ==================== Media 级别 API ====================

// 添加媒体到播放列表（从动态文件夹中选择）
POST /api/rooms/{room_id}/playlists/{playlist_id}/medias
// 请求：
// {
//   "name": "电影名称",
//   "source_provider": "alist",
//   "source_config": {"path": "/{server_id}/movies/example.mp4"}
// }
// 返回：Media { id, ... }
```

#### 6.1.9.7 实现示例

```rust
// handlers/playlists.rs

/// 创建播放列表（静态或动态）
async fn create_playlist(
    State(state): State<AppState>,
    Path(room_id): Path<String>,
    Json(req): Json<CreatePlaylistRequest>,
) -> Result<Json<Playlist>> {
    // 1. 如果是动态目录，验证 provider
    if let Some(provider_name) = req.source_provider.as_ref() {
        let provider = state.registry.get(&req.provider_instance_name.as_ref().unwrap_or(provider_name))
            .await
            .ok_or(Error::ProviderNotFound)?;

        // TODO: 验证 source_config 格式
    }

    // 2. 创建 playlist 记录
    let playlist = Playlist {
        id: nanoid!(12),
        room_id,
        creator_id: req.creator_id,
        name: req.name,
        parent_id: req.parent_id,
        position: 0,
        source_provider: req.source_provider,
        source_config: req.source_config,
        provider_instance_name: req.provider_instance_name,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    // 3. 存入数据库
    state.db.save_playlist(&playlist).await?;

    Ok(Json(playlist))
}

/// 获取播放列表内容（统一接口，自动区分静态/动态）
async fn list_playlist_items(
    State(state): State<AppState>,
    Path((room_id, playlist_id)): Path<(String, String)>,
    Query(params): Query<ListParams>,
) -> Result<Json<BrowseResult>> {
    // 1. 获取 playlist 记录
    let playlist = state.db.get_playlist(playlist_id).await?;

    // 2. 检查是否为动态目录
    if let Some(provider_name) = playlist.source_provider.as_ref() {
        // ========== 动态目录 ==========

        // 3. 获取 provider
        let provider_instance = playlist.provider_instance_name
            .as_ref()
            .unwrap_or(provider_name);
        let provider = state.registry.get(provider_instance)
            .await
            .ok_or(Error::ProviderNotFound)?;

        // 4. 解析 source_config 获取基础路径
        let base_path = playlist.source_config
            .get("path")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidSourceConfig)?;

        // 5. 构建完整路径（基础路径 + relative_path）
        let mut path = ItemPath::from_string(
            &format!("{}:{}", provider_name, base_path)
        )?;

        if let Some(rel_path) = params.relative_path.as_ref() {
            for segment in rel_path.split('/').filter(|s| !s.is_empty()) {
                path.segments.push(segment.to_string());
            }
        }

        // 6. 调用 provider.list_items()
        let ctx = ProviderContext::from_request(&state, &params.user_id).await?;
        let result = provider.list_items(&ctx, Some(&path), &params.pagination).await?;

        Ok(Json(result))

    } else {
        // ========== 静态目录 ==========

        // 3. 从 medias 表查询子项
        let medias = state.db
            .list_medias_by_playlist(playlist_id, &params.pagination)
            .await?;

        // 4. 转换为 BrowseResult
        let items = medias.into_iter().map(|media| Item {
            id: ItemId::new(&media.source_provider, &media.id.to_string()),
            name: media.name,
            item_type: ItemType::Video, // 根据 source_provider 确定类型
            metadata: Metadata::default(),
            provider_data: json!({}),
        }).collect();

        Ok(Json(BrowseResult {
            items,
            breadcrumbs: vec![],  // 静态目录没有面包屑
            total: items.len(),
            has_more: false,
        }))
    }
}

/// 添加媒体到播放列表
async fn add_media_to_playlist(
    State(state): State<AppState>,
    Path((room_id, playlist_id)): Path<(String, String)>,
    Json(req): Json<AddMediaRequest>,
) -> Result<Json<Media>> {
    // 1. 验证 playlist 存在且为静态目录
    let playlist = state.db.get_playlist(playlist_id).await?;

    if playlist.source_provider.is_some() {
        return Err(Error::CannotAddToynamicPlaylist);
    }

    // 2. 创建 media 记录
    let media = Media {
        id: nanoid!(12),
        playlist_id,
        room_id,
        name: req.name,
        position: 0,
        source_provider: req.source_provider,
        source_config: req.source_config,
        provider_instance_name: req.provider_instance_name,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    // 3. 存入数据库
    state.db.save_media(&media).await?;

    Ok(Json(media))
}
```

**关键点**：

1. **动态目录 = playlist.source_provider 不为 NULL**
2. **静态目录 = playlist.source_provider 为 NULL**，从 medias 表查询子项
3. **source_config** 存储基础配置（如 Alist 的 `path: "/movies"`）
4. **relative_path** 参数：
   - 相对于 `source_config.path` 的相对路径（总是以 `/` 开头）
   - 拼接逻辑：`base_path.trim_end_matches('/') + relative_path`
   - 例如：`base_path="/movies"` + `relative_path="/action"` → `"/movies/action"`
   - 用于在动态目录内部导航，不创建新的 playlist
   - 支持无限层级导航和路径穿越安全检查
5. **惰性加载**：只在用户打开文件夹时才调用 provider
6. **统一 API**：`list_playlist_items` 自动区分静态/动态
7. **Provider 无关**：API 层不关心具体是 Alist 还是 Emby

### 6.1.10 Alist 平台实现

```rust
// media/providers/alist.rs
pub struct AlistProvider {
    http_client: reqwest::Client,
    base_url: String,
    credential_store: Arc<CredentialStore>,
}

#[async_trait]
impl MediaProvider for AlistProvider {
    fn name(&self) -> &'static str {
        "alist"
    }

    fn can_handle(&self, url: &str) -> bool {
        url.starts_with(&self.base_url)
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 从 URL 提取路径
        let path = self.extract_path(&media.url)?;

        // 获取凭证
        let credential = ctx.get_credentials("alist", media.source_provider_backend.as_deref());

        // 调用 Alist API
        let api_url = format!("{}/api/fs/get", self.base_url);

        let response: AlistFileResponse = self.http_client
            .post(&api_url)
            .header("Authorization", format!("Bearer {}", credential.token))
            .json(&json!({
                "path": path,
                "password": "",
            }))
            .send()
            .await?
            .json()
            .await?;

        let data = response.data;

        // 构建 ParseResult
        Ok(ParseResult {
            parsed_data: ParsedData {
                playback_url: data.raw_url.clone(),
                headers: HashMap::new(),
                proxy: false,
                expire_at: None,
            },
            metadata: MediaMetadata {
                title: data.name.clone(),
                thumbnail: Some(data.thumb),
                duration: None,
                description: None,
                qualities: vec![Quality::Auto],
                subtitles: vec![],
            },
            provider_data: serde_json::to_value(&data)?,
        })
    }

    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing> {
        // 从 playlist.source_config 获取基础路径
        let base_path = playlist.source_config.get("base_path")
            .and_then(|v| v.as_str())
            .unwrap_or("/");

        // 构建完整路径
        // 注意：relative_path 以 '/' 开头，直接拼接即可
        let full_path = if let Some(rel) = relative_path {
            format!("{}{}", base_path.trim_end_matches('/'), rel)
        } else {
            base_path.to_string()
        };

        // 获取凭证
        let credential = ctx.get_credentials("alist", playlist.source_provider_backend.as_deref())
            .ok_or(Error::MissingCredentials)?;

        let api_url = format!("{}/api/fs/list", self.base_url);

        let response: AlistListResponse = self.http_client
            .post(&api_url)
            .header("Authorization", format!("Bearer {}", credential.token))
            .json(&json!({
                "path": full_path,
                "password": "",
                "page": page,
                "per_page": page_size,
            }))
            .send()
            .await?
            .json()
            .await?;

        // 转换为 DirectoryItem
        let items = response.data.content.into_iter()
            .map(|item| self.item_to_directory_item(item))
            .collect();

        Ok(DirectoryListing {
            items,
            total: response.data.total.unwrap_or(items.len()),
            page,
            page_size,
        })
    }
}

impl AlistProvider {
    /// 查找字幕文件
    async fn find_subtitles(&self, video_path: &str, credential: &Credential) -> Result<Vec<SubtitleInfo>> {
        let dir = std::path::Path::new(video_path)
            .parent()
            .and_then(|p| p.to_str())
            .unwrap_or("/");

        // 列出同目录下的所有文件
        let files = self.list_directory(dir).await?;

        // 过滤字幕文件
        let video_name = std::path::Path::new(video_path)
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("");

        let subtitle_exts = vec!["srt", "vtt", "ass", "ssa"];

        let subtitles = files.into_iter()
            .filter(|f| {
                if let Some(url) = &f.url {
                    let file_name = std::path::Path::new(url)
                        .file_name()
                        .and_then(|s| s.to_str())
                        .unwrap_or("");

                    // 文件名匹配 + 扩展名匹配
                    file_name.contains(video_name) &&
                        subtitle_exts.iter().any(|ext| file_name.ends_with(ext))
                } else {
                    false
                }
            })
            .map(|f| SubtitleInfo {
                id: f.id,
                name: f.title,
                language: self.detect_subtitle_language(&f.title),
                format: self.detect_subtitle_format(f.url.as_ref().unwrap()),
                url: f.url.unwrap(),
            })
            .collect();

        Ok(subtitles)
    }

    fn detect_subtitle_language(&self, filename: &str) -> String {
        if filename.contains("中文") || filename.contains("chs") || filename.contains("zh") {
            "zh-CN".to_string()
        } else if filename.contains("eng") || filename.contains("en") {
            "en".to_string()
        } else {
            "unknown".to_string()
        }
    }
}
```

### 6.1.6 MediaProvider 实现详解

本节包含所有 Provider 的完整实现代码，从 04-数据库设计 中移至此处，提供更清晰的职责划分。

> **说明**：本节内容从 [04-数据库设计.md](./04-数据库设计.md) § 2.4.5 迁移而来，
> 数据库设计文档仅保留接口定义和数据结构，所有实现细节集中在本章。

#### 6.1.6.1 AlistProvider 完整实现

**支持特性**：

- ✅ 用户级凭证（每个用户独立 token）
- ✅ 目录列表（支持动态目录）
- ✅ 文件搜索
- ✅ 临时URL（24小时过期）

```rust
pub struct AlistProvider;

#[async_trait]
impl MediaProvider for AlistProvider {
    fn name(&self) -> &'static str {
        "alist"
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 从 ctx.instance 获取实例配置
        let instance = ctx.instance.ok_or(Error::MissingInstance)?;
        let instance_config: AlistInstanceConfig = serde_json::from_value(instance.config.clone())?;

        // 2. 从 media.source_config 获取路径
        let path = media.source_config.get("path")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 3. 获取用户凭证
        let credential = ctx.get_credential().await?
            .ok_or(Error::CredentialRequired)?;

        let token = match credential {
            CredentialData::Token { token, .. } => token,
            _ => return Err(Error::InvalidCredentialType),
        };

        // 4. 调用 Alist API 获取文件信息
        let response = self.get_file_info(&instance_config.host, path, &token).await?;

        // 4. 生成临时下载URL（带签名，24小时有效）
        let playback_url = response.raw_url;

        // 5. 构建 parsed_data
        let mut fields = HashMap::new();
        fields.insert("thumbnail_url".to_string(), json!(response.thumb));
        fields.insert("is_live".to_string(), json!(false));

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            "Parsed Alist video: user={:?}, path={}",
            user_id,
            path
        );

        Ok(ParseResult {
            parsed_data: ParsedVideoData {
                playback_url,
                fields,
            },
            proxy: false,
            expires_at: Some(Utc::now() + Duration::hours(20)),
        })
    }

    fn supports_directory_listing(&self) -> bool {
        true  // Alist 支持目录列表
    }

    fn supports_search(&self) -> bool {
        true  // Alist 支持搜索
    }

    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // Alist 不支持 share，始终使用用户级缓存
        // 因为每个用户有不同的 token 和权限

        // 优先使用请求者的缓存
        if let Some(requester) = ctx.requester {
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供请求者时，使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            // 都没有时，使用特殊的无用户缓存键
            format!("media:parsed:{}:no-user", media.id)
        }
    }

    /// 列出 Alist 目录内容
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing> {
        // 1. 从 playlist.source_config 获取基础路径
        let base_path = playlist.source_config.as_ref()
            .and_then(|c| c.get("path"))
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let server = playlist.source_config.as_ref()
            .and_then(|c| c.get("server"))
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 2. 拼接完整路径
        let full_path = match relative_path {
            Some(rel) => format!("{}/{}", base_path.trim_end_matches('/'), rel.trim_start_matches('/')),
            None => base_path.to_string(),
        };

        // 3. 安全检查：防止路径穿越
        if !full_path.starts_with(base_path) {
            return Err(Error::PathTraversal);
        }

        // 4. 获取凭证
        let credentials = ctx.get_credentials("alist", playlist.source_provider_backend.as_deref())
            .ok_or(Error::CredentialRequired)?;

        let token = credentials.get("token")
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 5. 调用 Alist API 列出目录
        let response = self.list_dir(server, &full_path, token, page, page_size).await?;

        // 6. 转换为 DirectoryItem
        let items = response.content.into_iter().map(|item| {
            let item_type = if item.is_dir {
                ItemType::Folder
            } else {
                ItemType::Video
            };

            // 构建子项的 source_config
            let child_path = format!("{}/{}", full_path.trim_end_matches('/'), item.name);
            let mut source_config_fields = HashMap::new();
            source_config_fields.insert("path".to_string(), json!(child_path));
            source_config_fields.insert("server".to_string(), json!(server));

            DirectoryItem {
                id: item.name.clone(),
                title: item.name,
                item_type,
                source_config: SourceConfig {
                    fields: source_config_fields,
                },
                thumbnail: item.thumb,
                duration: None,  // Alist 不提供时长信息
                description: None,
                children_count: if item.is_dir { Some(0) } else { None },  // 需要再次查询
                metadata: HashMap::from([
                    ("size".to_string(), json!(item.size)),
                    ("modified".to_string(), json!(item.modified)),
                ]),
            }
        }).collect();

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            "Listed Alist directory: user={:?}, path={}, items={}",
            user_id,
            full_path,
            items.len()
        );

        Ok(DirectoryListing {
            items,
            total: response.total,
            page,
            page_size,
        })
    }
}
```

#### 6.1.6.2 DirectUrlProvider 完整实现

**支持特性**：

- ✅ 无需凭证
- ✅ 共享缓存
- ✅ 永久URL（不过期）

```rust
pub struct DirectUrlProvider;

#[async_trait]
impl MediaProvider for DirectUrlProvider {
    fn name(&self) -> &'static str {
        "direct_url"
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 从 source_config 获取 URL
        let url = media.source_config.get("url")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 2. 直接返回，无需额外处理
        let mut fields = HashMap::new();
        fields.insert("is_live".to_string(), json!(false));

        Ok(ParseResult {
            parsed_data: ParsedVideoData {
                playback_url: url.to_string(),
                fields,
            },
            proxy: false,
            expires_at: None,  // 直接URL不会过期
        })
    }

    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // 直接URL通常不需要凭证，可以共享缓存
        format!("media:parsed:{}:shared", media.id)
    }
}
```

#### 6.1.6.3 BilibiliProvider 完整实现

**支持特性**：

- ✅ 支持 share 字段（共享/非共享缓存）
- ✅ 用户级会员（不同画质）
- ✅ 需要代理（防盗链）
- ✅ 字幕支持

```rust
pub struct BilibiliProvider;

#[async_trait]
impl MediaProvider for BilibiliProvider {
    fn name(&self) -> &'static str {
        "bilibili"
    }

    fn can_handle(&self, url: &str) -> bool {
        url.contains("bilibili.com") || url.contains("b23.tv")
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 从 media.source_config 获取 BV号
        let bvid = media.source_config.get("bvid")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let quality = media.source_config.get("quality")
            .and_then(|v| v.as_str())
            .unwrap_or("1080p");

        // 2. 获取用户凭证（可选）
        let credential = ctx.get_credential().await?;
        let cookie = credential.as_ref()
            .and_then(|c| match c {
                CredentialData::Cookie { cookies } => Some(cookies),
                _ => None,
            });

        // 3. 调用 B站 API 获取视频流地址
        let response = self.get_video_url(bvid, quality, cookie).await?;

        // 4. 构建 parsed_data
        let mut fields = HashMap::new();
        fields.insert("duration".to_string(), json!(response.duration));
        fields.insert("thumbnail_url".to_string(), json!(response.pic));
        fields.insert("description".to_string(), json!(response.desc));
        fields.insert("is_live".to_string(), json!(false));
        fields.insert("headers".to_string(), json!({
            "Referer": "https://www.bilibili.com",
        }));

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            "Parsed Bilibili video: user={:?}, bvid={}, has_cookie={}",
            user_id,
            bvid,
            cookie.is_some()
        );

        Ok(ParseResult {
            parsed_data: ParsedVideoData {
                playback_url: response.durl[0].url.clone(),
                fields,
            },
            proxy: true,  // B站需要代理
            expires_at: Some(Utc::now() + Duration::hours(2)),
        })
    }

    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // 读取 source_config 中的 share 字段
        let is_shared = media.source_config
            .get("share")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if is_shared {
            // 共享模式：所有用户共享缓存（使用创建者的凭证）
            format!("media:parsed:{}:shared", media.id)
        } else if let Some(requester) = ctx.requester {
            // 非共享模式：每个用户使用自己的凭证，独立缓存
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供 requester 时使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            // 都没有时，使用共享缓存
            format!("media:parsed:{}:shared", media.id)
        }
    }
}
```

#### 6.1.6.4 RtmpProvider 完整实现

**支持特性**：

- ✅ 直播流
- ✅ 无需凭证
- ✅ 共享缓存
- ✅ 永久URL（不过期）

```rust
pub struct RtmpProvider;

#[async_trait]
impl MediaProvider for RtmpProvider {
    fn name(&self) -> &'static str {
        "rtmp"
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 从 source_config 获取 RTMP URL
        let url = media.source_config.get("url")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 2. RTMP 直播流，直接使用原URL
        let mut fields = HashMap::new();
        fields.insert("is_live".to_string(), json!(true));

        Ok(ParseResult {
            parsed_data: ParsedVideoData {
                playback_url: url.to_string(),
                fields,
            },
            proxy: false,
            expires_at: None,  // 直播URL不会过期
        })
    }

    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // RTMP 直播流通常不需要用户凭证，可以共享缓存
        format!("media:parsed:{}:shared", media.id)
    }
}
```

#### 6.1.6.5 EmbyProvider 完整实现（含生命周期钩子）

**支持特性**：

- ✅ 用户级 API Key
- ✅ 目录列表（媒体库浏览）
- ✅ 搜索支持
- ✅ 生命周期钩子（转码控制）
- ✅ 播放进度同步

```rust
pub struct EmbyProvider {
    client: reqwest::Client,
    base_url: String,
}

#[async_trait]
impl MediaProvider for EmbyProvider {
    fn name(&self) -> &'static str {
        "emby"
    }

    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 从 ctx.instance 获取实例配置
        let instance = ctx.instance.ok_or(Error::MissingInstance)?;
        let instance_config: EmbyInstanceConfig = serde_json::from_value(instance.config.clone())?;

        // 2. 从 media.source_config 获取 Emby item ID
        let item_id = media.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 3. 获取用户凭证
        let credential = ctx.get_credential().await?
            .ok_or(Error::CredentialRequired)?;

        let api_key = match credential {
            CredentialData::ApiKey { api_key, .. } => api_key,
            _ => return Err(Error::InvalidCredentialType),
        };

        // 3. 获取媒体信息
        let response = self.client
            .get(&format!("{}/Items/{}", self.base_url, item_id))
            .header("X-Emby-Token", api_key)
            .send()
            .await?
            .json::<EmbyMediaInfo>()
            .await?;

        // 4. 构建播放URL
        let playback_url = format!(
            "{}/Videos/{}/stream?static=true&api_key={}",
            self.base_url, item_id, api_key
        );

        // 5. 构建 parsed_data
        let mut fields = HashMap::new();
        fields.insert("duration".to_string(), json!(response.runtime_ticks / 10_000_000));
        fields.insert("thumbnail_url".to_string(), json!(response.image_tags));
        fields.insert("is_live".to_string(), json!(false));

        Ok(ParseResult {
            parsed_data: ParsedVideoData {
                playback_url,
                fields,
            },
            proxy: false,
            expires_at: None,
        })
    }

    fn supports_directory_listing(&self) -> bool {
        true  // Emby 支持媒体库浏览
    }

    fn supports_search(&self) -> bool {
        true  // Emby 支持搜索
    }

    fn cache_key(&self, ctx: &ProviderContext<'_>, media: &Media) -> String {
        // Emby 同样不支持 share，始终使用用户级缓存

        // 优先使用请求者的缓存
        if let Some(requester) = ctx.requester {
            format!("media:parsed:{}:user:{}", media.id, requester.id())
        } else if let Some(creator) = ctx.creator {
            // 未提供请求者时，使用创建者的缓存
            format!("media:parsed:{}:user:{}", media.id, creator.id())
        } else {
            format!("media:parsed:{}:no-user", media.id)
        }
    }

    // ==================== 生命周期钩子实现 ====================

    /// 播放开始：通知 Emby 服务器，启动转码任务
    async fn on_playback_start(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
    ) -> Result<()> {
        let item_id = media.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let credentials = ctx.get_credentials("emby", media.source_provider_backend.as_deref());
        let api_key = credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 通知 Emby 播放开始
        self.client
            .post(&format!("{}/Sessions/Playing", self.base_url))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "ItemId": item_id,
                "SessionId": session_id,
                "PositionTicks": 0,  // 播放开始位置为 0
                "IsPaused": false,
                "IsMuted": false,
            }))
            .send()
            .await?;

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            item_id = item_id,
            user_id = ?user_id,
            session_id = %session_id,
            "Emby playback started"
        );

        Ok(())
    }

    /// 播放停止：通知 Emby 停止播放，释放转码资源
    async fn on_playback_stop(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        let item_id = media.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let credentials = ctx.get_credentials("emby", media.source_provider_backend.as_deref());
        let api_key = credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 通知 Emby 播放停止
        self.client
            .post(&format!("{}/Sessions/Playing/Stopped", self.base_url))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "ItemId": item_id,
                "SessionId": session_id,
                "PositionTicks": (position * 10_000_000.0) as i64,
            }))
            .send()
            .await?;

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            item_id = item_id,
            user_id = ?user_id,
            session_id = %session_id,
            position = position,
            "Emby playback stopped, transcoding released"
        );

        Ok(())
    }

    /// 播放暂停
    async fn on_playback_pause(&self, ctx: &PlaybackContext) -> Result<()> {
        let item_id = ctx.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let api_key = ctx.credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 通知 Emby 暂停
        self.client
            .post(&format!("{}/Sessions/Playing/Progress", self.base_url))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "ItemId": item_id,
                "SessionId": ctx.session_id,
                "PositionTicks": (ctx.position * 10_000_000.0) as i64,
                "IsPaused": true,
            }))
            .send()
            .await?;

        Ok(())
    }

    /// 播放恢复
    async fn on_playback_resume(&self, ctx: &PlaybackContext) -> Result<()> {
        let item_id = ctx.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let api_key = ctx.credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 通知 Emby 恢复播放
        self.client
            .post(&format!("{}/Sessions/Playing/Progress", self.base_url))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "ItemId": item_id,
                "SessionId": ctx.session_id,
                "PositionTicks": (ctx.position * 10_000_000.0) as i64,
                "IsPaused": false,
            }))
            .send()
            .await?;

        Ok(())
    }

    /// 播放完毕：标记为已观看
    async fn on_playback_ended(&self, ctx: &PlaybackContext) -> Result<()> {
        let item_id = ctx.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let api_key = ctx.credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 标记为已观看
        self.client
            .post(&format!("{}/Items/{}/PlaybackStatus/Stopped", self.base_url, item_id))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "PositionTicks": (ctx.position * 10_000_000.0) as i64,
            }))
            .send()
            .await?;

        tracing::info!(
            item_id = item_id,
            user_id = %ctx.user_id,
            "Emby video marked as watched"
        );

        Ok(())
    }

    /// 定期更新进度（每10秒调用一次）
    async fn on_playback_progress(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        session_id: &str,
        position: f64,
    ) -> Result<()> {
        let item_id = media.source_config.get("item_id")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let credentials = ctx.get_credentials("emby", media.source_provider_backend.as_deref());
        let api_key = credentials.as_ref()
            .and_then(|c| c.get("api_key"))
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        // 更新播放进度
        self.client
            .post(&format!("{}/Sessions/Playing/Progress", self.base_url))
            .header("X-Emby-Token", api_key)
            .json(&json!({
                "ItemId": item_id,
                "SessionId": session_id,
                "PositionTicks": (position * 10_000_000.0) as i64,
                "IsPaused": false,
            }))
            .send()
            .await?;

        Ok(())
    }

    /// 列出 Emby 媒体库目录
    async fn list_directory(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        relative_path: Option<&str>,
        keyword: Option<&str>,
        page: usize,
        page_size: usize,
    ) -> Result<DirectoryListing> {
        // 1. 从 playlist.source_config 获取 parent_id（可选，NULL 表示根目录）
        let parent_id = playlist.source_config.as_ref()
            .and_then(|c| c.get("parent_id"))
            .and_then(|v| v.as_str());

        // 2. 获取凭证
        let credentials = ctx.get_credentials("emby", playlist.source_provider_backend.as_deref())
            .ok_or(Error::MissingCredentials)?;

        let api_key = credentials.get("api_key")
            .and_then(|v| v.as_str())
            .ok_or(Error::CredentialRequired)?;

        let user_id_str = credentials.get("user_id")
            .and_then(|v| v.as_str())
            .unwrap_or("default");

        // 3. 调用 Emby API 列出目录
        let url = if let Some(pid) = parent_id {
            format!("{}/Users/{}/Items?ParentId={}", self.base_url, user_id_str, pid)
        } else {
            format!("{}/Users/{}/Items", self.base_url, user_id_str)
        };

        let response = self.client
            .get(&url)
            .header("X-Emby-Token", api_key)
            .send()
            .await?
            .json::<EmbyItemsResponse>()
            .await?;

        // 4. 转换为 DirectoryItem
        let items = response.items.into_iter().map(|item| {
            let item_type = match item.item_type.as_str() {
                "Folder" | "CollectionFolder" => ItemType::Folder,
                "Episode" | "Movie" | "Video" => ItemType::Video,
                _ => ItemType::Video,
            };

            // 构建子项的 source_config
            let mut source_config_fields = HashMap::new();
            source_config_fields.insert("item_id".to_string(), json!(item.id));
            if item_type == ItemType::Folder {
                source_config_fields.insert("parent_id".to_string(), json!(item.id));
            }

            DirectoryItem {
                id: item.id.clone(),
                title: item.name,
                item_type,
                source_config: SourceConfig {
                    fields: source_config_fields,
                },
                thumbnail: item.image_tags.get("Primary").map(|_| {
                    format!("{}/Items/{}/Images/Primary", self.base_url, item.id)
                }),
                duration: item.runtime_ticks.map(|t| (t / 10_000_000) as i32),
                description: item.overview,
                children_count: item.child_count,
                metadata: HashMap::from([
                    ("production_year".to_string(), json!(item.production_year)),
                    ("community_rating".to_string(), json!(item.community_rating)),
                ]),
            }
        }).collect();

        let user_id = ctx.requester.map(|u| u.id()).or_else(|| ctx.creator.map(|u| u.id()));
        tracing::info!(
            "Listed Emby directory: user={:?}, parent_id={:?}, items={}",
            user_id,
            parent_id,
            items.len()
        );

        Ok(DirectoryListing {
            items,
            total: response.total_record_count.unwrap_or(items.len()),
            page,
            page_size,
        })
    }
}
```

#### 6.1.6.6 Provider 缓存策略总结

| Provider | 支持 share | 默认策略 | 备注 |
|----------|-----------|---------|------|
| **bilibili** | ✅ 是 | 根据 `source_config.share` 决定 | 灵活配置 |
| **alist** | ❌ 否 | 用户级缓存 | 每个用户有独立 token |
| **emby** | ❌ 否 | 用户级缓存 | 每个用户有独立 api_key |
| **direct_url** | ❌ 否（但默认共享） | 共享缓存 | 公共URL，无需凭证 |
| **rtmp** | ❌ 否（但默认共享） | 共享缓存 | 直播流，无需凭证 |

#### 6.1.6.7 生命周期钩子使用指南

**钩子执行流程**：

```rust
// service/playback_service.rs
pub async fn handle_playback_start(
    &self,
    media_id: String,  // nanoid(12)
    user_id: String,   // nanoid(12)
    session_id: String,
) -> Result<()> {
    // 1. 获取 media
    let media = self.media_repo.get(media_id).await?;
    
    // 2. 获取 provider
    let provider = self.provider_registry.get(&media.source_provider)?;
    
    // 3. 构建上下文
    let user = self.user_repo.get(user_id).await?;
    let ctx = ProviderContext::new()
        .with_requester(&user)
        .with_room_id(media.room_id);
    
    // 4. 异步调用钩子（不阻塞主流程）
    let provider_clone = provider.clone();
    let ctx_clone = ctx.clone();
    let media_clone = media.clone();
    let session_id_clone = session_id.clone();
    
    tokio::spawn(async move {
        if let Err(e) = provider_clone.on_playback_start(
            &ctx_clone,
            &media_clone,
            &session_id_clone,
        ).await {
            tracing::warn!(
                "Playback start hook failed: provider={}, error={:?}",
                provider_clone.name(),
                e
            );
        }
    });
    
    Ok(())
}
```

**核心优势**：

- ✅ **数据库只存配置**：`source_config` 存储持久化配置，解析结果存 Redis
- ✅ **简化设计**：从 `source_config.share` 字段自动推导缓存策略（仅部分 provider 支持）
- ✅ **动态 TTL**：缓存过期时间由提供者返回（`expires_at`），而非手动配置
- ✅ **灵活缓存**：bilibili 支持 share 字段（共享/非共享），alist/emby 默认非共享
- ✅ **凭证安全**：敏感凭证（token、cookie）加密存储，与配置分离
- ✅ **用户级解析**：每个用户可以使用自己的账号（如自己的 B站会员、Alist 账号）
- ✅ **缓存优化**：解析结果缓存在 Redis，提升性能
- ✅ **灵活扩展**：不同视频源可以自定义字段，无需修改数据库
- ✅ **统一接口**：所有视频源类型都走完全相同的解析流程
- ✅ **生命周期钩子**：支持播放开始/停止/暂停/恢复/完毕等事件，Emby 可控制转码，统计可记录播放行为
- ✅ **可选实现**：钩子默认空实现，只有需要的 provider实现，零开销
- ✅ **错误隔离**：钩子失败不影响主流程，保证播放稳定性
- ✅ **能力查询**：通过 `supports_*()` 方法查询提供者能力，UI 可据此显示功能

---

### 6.1.7 凭证管理

Provider 实例和用户凭证的管理是新架构的核心改进之一。详细设计参见：[09-媒体源提供商配置管理.md](./09-媒体源提供商配置管理.md)

#### 6.1.7.1 创建 Provider 实例

管理员或用户可以创建 Provider 实例（如某个 Alist 服务器）：

```rust
// 创建全局可用的 Alist 实例
let instance = ProviderInstance::create(CreateInstanceRequest {
    name: "公司Alist".to_string(),
    provider: "alist".to_string(),
    backend: None,  // 不使用 gRPC 后端
    config: json!({
        "host": "https://alist.example.com",
        "api_version": "v3"
    }),
    owner_id: None,  // NULL = 全局可用
    visibility: Visibility::Public,
    description: Some("公司内部文件服务器".to_string()),
}).await?;
```

#### 6.1.7.2 绑定用户凭证

用户可以在 Provider 实例上绑定自己的登录凭证：

```rust
// 用户登录到 Alist 实例
let credential = UserCredential::new(
    user.id,
    instance.id,
    CredentialData::Token {
        token: "eyJhbGc...".to_string(),
        refresh_token: Some("refresh...".to_string()),
    },
)?;

credential.save().await?;
```

#### 6.1.7.3 凭证加密和过期

- **加密存储**：使用统一的 KDF（密钥派生函数）自动加密凭证
- **过期管理**：支持设置凭证过期时间，自动清理过期凭证
- **审计日志**：记录凭证的创建、使用、更新等操作

详细实现参见：[09-媒体源提供商配置管理.md § 3. 加密方案统一](./09-媒体源提供商配置管理.md#3-加密方案统一)

### 6.1.8 三阶段工作流（parse → add → play）

⚠️ **重要**：MediaProvider 使用三阶段工作流，而非两阶段。

**三个阶段**：

1. **阶段1：Parse（用户交互）** - 用户调用 HTTP/gRPC parse 端点，获取可选项
2. **阶段2：Add（客户端构建）** - 客户端根据用户选择构建 source_config，调用 add_media API
3. **阶段3：Play（系统生成）** - 系统调用 generate_playback() trait 方法生成播放信息

详见：[§ 6.1.6.2 三阶段工作流示例](#6162-三阶段工作流示例)

**接口职责**：

| 功能 | 类型 | 调用者 | 用途 |
|------|------|--------|------|
| `parse` | HTTP + gRPC 端点 | 前端/用户 | 解析用户输入，返回可选项 |
| `validate_source_config()` | Trait 方法 | 系统内部 | 校验 source_config |
| `generate_playback()` | Trait 方法 | 系统内部 | 生成播放信息 |

## 6.1.11 播放切换：支持静态与动态媒体

### 设计说明

采用 `playlist_id` + `media_id/relative_path` 的设计：

**共同点**：

- 始终记录 `playlist_id`（播放上下文）
- 支持自动连播、播放历史等功能

**区分点**：

- **静态媒体**：`media_id` 有值，`relative_path` 为空
- **动态媒体**：`media_id` 为空，`relative_path` 有值

### API 定义

```rust
// POST /api/v1/rooms/{room_id}/play
#[derive(Deserialize)]
pub struct PlayRequest {
    // 播放列表上下文（必填）
    playlist_id: String,  // nanoid

    #[serde(flatten)]
    pub source: PlaySource,
}

#[derive(Deserialize)]
#[serde(untagged)]
pub enum PlaySource {
    // 方式1：播放已添加的媒体
    StaticMedia {
        media_id: String,  // nanoid
    },
    // 方式2：播放动态播放列表中的视频
    DynamicMedia {
        relative_path: String,  // 相对于播放列表 source_config.path
    },
}

// 示例1：播放静态媒体
// POST /api/v1/rooms/abc123/play
// {
//   "playlist_id": "playlist_xyz",
//   "media_id": "media_123"
// }

// 示例2：播放动态媒体（Alist）
// POST /api/v1/rooms/abc123/play
// {
//   "playlist_id": "alist_playlist_xyz",
//   "relative_path": "/action/movie.mp4"
// }
```

### 服务实现

```rust
// service/playback_service.rs
pub struct PlaybackService {
    room_repo: Arc<RoomRepository>,
    playlist_repo: Arc<PlaylistRepository>,
    media_repo: Arc<MediaRepository>,
    provider_registry: Arc<ProviderRegistry>,
    cluster_sync: Arc<ClusterSync>,
}

impl PlaybackService {
    /// 切换播放
    pub async fn play(
        &self,
        room_id: &str,      // nanoid
        user_id: String,    // nanoid(12)
        playlist_id: String, // nanoid
        source: PlaySource,
    ) -> Result<()> {
        // 1. 权限检查
        self.room_repo.check_permission(
            room_id,
            user_id,
            Permission::PLAY_CONTROL,
        ).await?;

        // 2. 验证 playlist 属于该房间
        let playlist = self.playlist_repo.get(&playlist_id).await?;

        if playlist.room_id != room_id {
            return Err(Error::PlaylistNotInRoom);
        }

        // 3. 根据播放源类型更新状态
        match source {
            PlaySource::StaticMedia { media_id } => {

                // 验证 media 属于该播放列表
                let media = self.media_repo.get(media_uuid).await?;
                if media.playlist_id != playlist_uuid {
                    return Err(Error::MediaNotInPlaylist);
                }

                // 更新房间状态（静态媒体）
                self.room_repo.update_playback_session(room_id, PlaybackSession {
                    playlist_id: Some(playlist_uuid),
                    media_id: Some(media_uuid),
                    relative_path: None,
                    status: PlayStatus::Playing,
                    position: 0.0,
                }).await?;
            }
            PlaySource::DynamicMedia { relative_path } => {
                // 验证是动态播放列表
                if playlist.source_provider.is_none() {
                    return Err(Error::NotDynamicPlaylist);
                }

                // 路径安全检查
                if relative_path.contains("..") {
                    return Err(Error::InvalidPath);
                }

                // 更新房间状态（动态媒体）
                self.room_repo.update_playback_session(room_id, PlaybackSession {
                    playlist_id: Some(playlist_uuid),
                    media_id: None,
                    relative_path: Some(relative_path),
                    status: PlayStatus::Playing,
                    position: 0.0,
                }).await?;
            }
        }

        // 4. 广播播放切换事件
        self.cluster_sync.publish(ClusterEvent::PlaybackChanged {
            room_id: room_id.to_string(),
            triggered_by: user_id,
            timestamp: Utc::now().timestamp_millis(),
        }).await?;

        Ok(())
    }

    /// 获取当前播放信息（复用 04 章的实现）
    pub async fn get_current_playback(
        &self,
        room_id: &str,
    ) -> Result<PlaybackInfo> {
        // 实现见 04-数据库设计.md § 2.5 "业务逻辑"
        let state = self.room_repo.get_playback_session(room_id).await?;

        let playback = if let Some(media_id) = state.media_id {
            // 静态媒体
            let media = self.media_repo.get(media_id).await?;
            let provider = self.provider_registry.get(&media.source_provider)?;

            provider.generate_playback(
                &ProviderContext::new(room_id),
                &media.source_config,
            ).await?

        } else if let (Some(playlist_id), Some(relative_path)) =
            (state.playlist_id, state.relative_path) {
            // 动态媒体
            let playlist = self.playlist_repo.get(playlist_id).await?;
            let (provider_name, base_config) = playlist.source_provider
                .ok_or(Error::NotDynamicPlaylist)?;

            let provider = self.provider_registry.get(&provider_name)?;
            let full_config = Self::merge_config(&base_config, &relative_path)?;

            provider.generate_playback(
                &ProviderContext::new(room_id),
                &full_config,
            ).await?
        } else {
            return Err(Error::NoCurrentMedia);
        };

        Ok(PlaybackInfo {
            urls: playback.urls,
            subtitles: playback.subtitles,
            danmaku_urls: playback.danmaku_urls,
            position: state.position,
            status: state.status,
            rate: state.rate,
        })
    }

    /// 合并基础配置和相对路径
    ///
    /// # 约定
    /// - `relative_path` 总是以 `/` 开头
    /// - 拼接逻辑：`base_path.trim_end_matches('/') + relative_path`
    ///
    /// # 示例
    /// ```
    /// base_path = "/movies", relative_path = "/action/movie.mp4"
    /// → full_path = "/movies/action/movie.mp4"
    /// ```
    fn merge_config(base_config: &Value, relative_path: &str) -> Result<Value> {
        let mut config = base_config.clone();

        if let Some(base_path) = config.get("path").and_then(|v| v.as_str()) {
            // 直接拼接（relative_path 已经以 '/' 开头）
            let full_path = format!("{}{}", base_path.trim_end_matches('/'), relative_path);
            config["path"] = json!(full_path);
        } else {
            // 如果没有 base_path，直接使用 relative_path
            config["path"] = json!(relative_path);
        }

        Ok(config)
    }
}
```

### 关键设计点

**1. playlist_id 提供上下文**

- 始终记录当前在哪个播放列表中播放
- 支持后续功能：自动连播、播放历史、推荐

**2. media_id 和 relative_path 互斥**

```sql
CONSTRAINT current_source_check CHECK (
    (media_id IS NOT NULL AND relative_path IS NULL) OR
    (media_id IS NULL AND relative_path IS NOT NULL)
)
```

**3. 配置合并逻辑**

```rust
// playlist.source_config.path = "/movies"
// relative_path = "/action/movie.mp4"
// → full_config.path = "/movies/action/movie.mp4"
```

**4. 播放信息生成统一**

- 无论静态还是动态，最终都调用 `provider.generate_playback(source_config)`
- 静态：`source_config` 来自 `media` 表
- 动态：`source_config` = 播放列表配置 + 相对路径

**5. 典型使用流程**

```
场景1：播放静态媒体
    ↓
用户从播放列表选择已添加的视频
    ↓
POST /api/v1/rooms/abc123/play
{
  "playlist_id": "playlist_xyz",
  "media_id": "media_123"
}
    ↓
更新 room_playback_session
    playlist_id = playlist_xyz (nanoid)
    media_id = media_123 (nanoid)
    relative_path = NULL

---

场景2：播放动态媒体
    ↓
用户浏览 Alist 动态播放列表
GET /api/v1/rooms/abc123/playlists/alist_playlist/items?relative_path=/action
    ↓
返回文件列表 { items: [ {name: "movie.mp4", relative_path: "/action/movie.mp4"} ] }
    ↓
用户点击播放
POST /api/v1/rooms/abc123/play
{
  "playlist_id": "alist_playlist",
  "relative_path": "/action/movie.mp4"
}
    ↓
更新 room_playback_session
    playlist_id = alist_playlist (nanoid)
    media_id = NULL
    relative_path = "/action/movie.mp4"
    ↓
获取播放信息时合并配置
    playlist.source_config = {"path": "/movies"}
    + relative_path = "/action/movie.mp4"
    → full_config = {"path": "/movies/action/movie.mp4"}
    ↓
调用 provider.generate_playback(full_config)
```

### 设计优势

采用 `playlist_id + relative_path` 方案的优势：

1. 更符合业务语义（播放总是在某个列表的上下文中）
2. 支持自动连播等高级功能
3. 配置复用，减少数据冗余
4. 始终保持播放列表上下文

---

## 6.2 代理系统

### 6.2.1 架构目标

**解决的问题**:

1. ✅ 缓存穿透防护（布隆过滤器）
2. ✅ 并发请求合并（同一资源只下载一次）
3. ✅ 智能缓存键生成
4. ✅ 灵活的代理策略
5. ✅ 分层缓存（内存 + 本地文件 + 分布式）

### 6.2.2 代理服务实现

```rust
// proxy/mod.rs
pub struct ProxyService {
    http_client: reqwest::Client,
    cache_manager: Arc<CacheManager>,
    request_deduplicator: Arc<RequestDeduplicator>,
    bloom_filter: Arc<RwLock<BloomFilter>>,
}

/// 代理请求
#[derive(Debug, Clone)]
pub struct ProxyRequest {
    pub url: String,
    pub headers: HashMap<String, String>,
    pub cache_strategy: CacheStrategy,
}

/// 缓存策略
#[derive(Debug, Clone)]
pub enum CacheStrategy {
    NoCache,                           // 不缓存
    Memory { ttl: Duration },          // 仅内存
    File { ttl: Duration },            // 持久化到文件
    Distributed { ttl: Duration },     // 分布式缓存
}

impl ProxyService {
    /// 代理HTTP请求
    pub async fn proxy(&self, request: ProxyRequest) -> Result<ProxyResponse> {
        // Step 1: 生成缓存键
        let cache_key = self.generate_cache_key(&request);

        // Step 2: 布隆过滤器检查（防止缓存穿透）
        if !self.bloom_contains(&cache_key).await {
            // 不在布隆过滤器中，直接查询
            return self.fetch_and_cache(request, cache_key).await;
        }

        // Step 3: 检查缓存
        if let Some(cached) = self.cache_manager.get(&cache_key).await? {
            tracing::debug!(cache_key = %cache_key, "Cache hit");
            return Ok(cached);
        }

        // Step 4: 请求去重（多个请求同时访问同一资源，只发起一次请求）
        let response = self.request_deduplicator
            .execute(&cache_key, || async {
                self.fetch_and_cache(request.clone(), cache_key.clone()).await
            })
            .await?;

        Ok(response)
    }

    /// 代理 M3U8 文件（特殊处理）
    pub async fn proxy_m3u8(&self, request: ProxyRequest) -> Result<String> {
        // 获取原始 M3U8
        let response = self.proxy(request.clone()).await?;
        let m3u8_content = String::from_utf8(response.body)?;

        // 解析 M3U8
        let playlist = m3u8_rs::parse_playlist_res(m3u8_content.as_bytes())
            .map_err(|e| Error::M3u8ParseError(e.to_string()))?;

        // 重写 URL
        let rewritten = self.rewrite_m3u8_urls(playlist, &request.url).await?;

        Ok(rewritten)
    }

    /// 获取并缓存
    async fn fetch_and_cache(
        &self,
        request: ProxyRequest,
        cache_key: String,
    ) -> Result<ProxyResponse> {
        tracing::debug!(url = %request.url, "Fetching from origin");

        // 发起 HTTP 请求
        let mut req = self.http_client.get(&request.url);

        for (k, v) in request.headers {
            req = req.header(k, v);
        }

        let response = req.send().await?;

        // 检查状态码
        if !response.status().is_success() {
            return Err(Error::ProxyError(response.status().as_u16()));
        }

        // 读取响应体
        let headers = response.headers().clone();
        let body = response.bytes().await?.to_vec();

        let proxy_response = ProxyResponse {
            status: 200,
            headers: headers.iter()
                .map(|(k, v)| (k.to_string(), v.to_str().unwrap_or("").to_string()))
                .collect(),
            body,
        };

        // 缓存
        match request.cache_strategy {
            CacheStrategy::NoCache => {}
            _ => {
                self.cache_manager.set(
                    cache_key.clone(),
                    proxy_response.clone(),
                    request.cache_strategy,
                ).await?;

                // 添加到布隆过滤器
                self.bloom_add(&cache_key).await;
            }
        }

        Ok(proxy_response)
    }

    /// 生成缓存键
    fn generate_cache_key(&self, request: &ProxyRequest) -> String {
        use sha2::{Sha256, Digest};

        let mut hasher = Sha256::new();

        // URL
        hasher.update(request.url.as_bytes());

        // 关键 headers（如 Range）
        if let Some(range) = request.headers.get("Range") {
            hasher.update(range.as_bytes());
        }

        format!("proxy:{:x}", hasher.finalize())
    }
}
```

## 6.3 字幕系统

> **说明**：
>
> - 字幕信息通过 `MediaProvider::generate_url()` 返回的 `MediaSource.subtitles` 字段获取
> - 不再需要单独的 `SubtitleProvider` trait
> - 本节主要介绍字幕格式转换和处理

### 6.3.1 统一字幕模型

```rust
// subtitle/mod.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subtitle {
    pub id: String,
    pub name: String,
    pub language: String,
    pub format: SubtitleFormat,

    // 来源
    pub source: SubtitleSource,

    // 内容（可选，用于内联字幕）
    pub content: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SubtitleSource {
    Url(String),                    // 外部URL
    Embedded,                       // 视频内嵌
    Generated,                      // 自动生成（AI）
    UserUploaded { user_id: String },  // nanoid(12) - 用户上传
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleInfo {
    pub id: String,
    pub name: String,
    pub language: String,
    pub format: SubtitleFormat,
    pub url: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SubtitleFormat {
    Srt,
    Vtt,
    Ass,
    Ssa,
}
```

### 6.3.2 字幕转换器

```rust
// subtitle/converter.rs
pub struct SubtitleConverter;

impl SubtitleConverter {
    /// 转换字幕格式
    pub fn convert(
        content: &str,
        from: SubtitleFormat,
        to: SubtitleFormat,
    ) -> Result<String> {
        // 先解析为中间格式
        let entries = Self::parse(content, from)?;

        // 再序列化为目标格式
        Self::serialize(&entries, to)
    }

    /// 解析 SRT
    fn parse_srt(content: &str) -> Result<Vec<SubtitleEntry>> {
        let mut entries = Vec::new();
        let blocks: Vec<&str> = content.split("\n\n").collect();

        for block in blocks {
            let lines: Vec<&str> = block.trim().lines().collect();
            if lines.len() < 3 {
                continue;
            }

            // 第1行：序号
            // 第2行：时间轴
            // 第3行及以后：文本

            let timing = lines[1];
            let parts: Vec<&str> = timing.split(" --> ").collect();
            if parts.len() != 2 {
                continue;
            }

            let start_time = Self::parse_srt_time(parts[0])?;
            let end_time = Self::parse_srt_time(parts[1])?;

            let text = lines[2..].join("\n");

            entries.push(SubtitleEntry {
                start_time,
                end_time,
                text,
                style: None,
            });
        }

        Ok(entries)
    }

    /// 序列化为 VTT
    fn serialize_vtt(entries: &[SubtitleEntry]) -> Result<String> {
        let mut output = String::from("WEBVTT\n\n");

        for entry in entries {
            output.push_str(&format!(
                "{} --> {}\n",
                Self::format_vtt_time(entry.start_time),
                Self::format_vtt_time(entry.end_time)
            ));
            output.push_str(&entry.text);
            output.push_str("\n\n");
        }

        Ok(output)
    }

    /// 格式化 VTT 时间
    fn format_vtt_time(duration: Duration) -> String {
        let total_millis = duration.as_millis();
        let hours = total_millis / (3600 * 1000);
        let minutes = (total_millis % (3600 * 1000)) / (60 * 1000);
        let seconds = (total_millis % (60 * 1000)) / 1000;
        let millis = total_millis % 1000;

        format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, seconds, millis)
    }
}

#[derive(Debug, Clone)]
struct SubtitleEntry {
    start_time: Duration,
    end_time: Duration,
    text: String,
    style: Option<String>,
}
```

### 6.3.3 字幕服务

```rust
// service/subtitle_service.rs
pub struct SubtitleService {
    proxy_service: Arc<ProxyService>,
    converter: SubtitleConverter,
    cache: Arc<DistributedCache<String, String>>,
}

impl SubtitleService {
    /// 获取字幕（自动转换格式）
    pub async fn get_subtitle(
        &self,
        subtitle_info: &SubtitleInfo,
        target_format: SubtitleFormat,
    ) -> Result<String> {
        // Step 1: 生成缓存键
        let cache_key = format!(
            "subtitle:{}:{}",
            Self::hash_url(&subtitle_info.url),
            target_format.as_str()
        );

        // Step 2: 检查缓存
        if let Some(cached) = self.cache.get(&cache_key).await? {
            return Ok(cached);
        }

        // Step 3: 下载原始字幕
        let original_content = self.download_subtitle(&subtitle_info.url).await?;

        // Step 4: 转换格式（如果需要）
        let converted_content = if subtitle_info.format == target_format {
            original_content
        } else {
            self.converter.convert(
                &original_content,
                subtitle_info.format.clone(),
                target_format,
            )?
        };

        // Step 5: 缓存（30分钟）
        self.cache.set(cache_key, converted_content.clone()).await?;

        Ok(converted_content)
    }

    /// 下载字幕
    async fn download_subtitle(&self, url: &str) -> Result<String> {
        let response = self.proxy_service.proxy(ProxyRequest {
            url: url.to_string(),
            headers: HashMap::new(),
            cache_strategy: CacheStrategy::Memory {
                ttl: Duration::from_secs(1800),  // 30分钟
            },
        }).await?;

        let content = String::from_utf8(response.body)?;
        Ok(content)
    }
}
```

## 6.4 凭证管理

```rust
// media/credential.rs
pub struct CredentialStore {
    db: PgPool,
    redis: deadpool_redis::Pool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Credential {
    pub user_id: String,  // nanoid(12)
    pub source_type: String,
    pub token: String,
    pub cookie: String,
    pub expires_at: Option<DateTime<Utc>>,
}

impl CredentialStore {
    /// 获取用户在某平台的凭证
    pub async fn get(&self, source_type: &str, user_id: String) -> Result<Credential> {
        // 查询数据库
        let cred = sqlx::query_as!(
            Credential,
            r#"
            SELECT user_id, source_type, token, cookie, expires_at
            FROM user_video_credentials
            WHERE user_id = $1 AND source_type = $2
            "#,
            user_id,
            source_type
        )
        .fetch_optional(&self.db)
        .await?;

        cred.ok_or(Error::CredentialNotFound)
    }

    /// 保存凭证
    pub async fn save(&self, credential: Credential) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO user_video_credentials (user_id, source_type, token, cookie, expires_at)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (user_id, source_type)
            DO UPDATE SET
                token = EXCLUDED.token,
                cookie = EXCLUDED.cookie,
                expires_at = EXCLUDED.expires_at,
                updated_at = NOW()
            "#,
            credential.user_id,
            credential.source_type,
            credential.token,
            credential.cookie,
            credential.expires_at
        )
        .execute(&self.db)
        .await?;

        Ok(())
    }
}

// 数据库表
CREATE TABLE user_video_credentials (
    user_id CHAR(12) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    source_type video_source_type NOT NULL,

    token TEXT NOT NULL,
    cookie TEXT NOT NULL,
    expires_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    PRIMARY KEY (user_id, source_type)
);
```

## 6.5 总结

### 视频解析系统

- **插件化架构**: 易扩展、易测试
- **统一接口**: MediaProvider trait
- **平台支持**: Bilibili、Alist、Emby、自定义
- **字幕支持**: 自动检测、格式转换

### 代理系统

- **缓存策略**: 多级缓存、布隆过滤器
- **请求去重**: 并发控制
- **M3U8 支持**: URL 重写

### 字幕系统

- **格式支持**: SRT、VTT、ASS、SSA
- **自动转换**: 统一输出格式
- **智能缓存**: 30分钟 TTL

---

**上一章**: [07-权限系统设计](./05-缓存设计.md)
**下一章**: [09-媒体源提供商配置管理](./11-实时互动.md)
