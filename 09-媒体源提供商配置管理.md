# 25. 媒体源提供商实例配置管理

## 概述

本文档描述 SyncTV Rust 版本的 Provider Instance（提供商实例）配置管理系统，用于跨地域视频解析和负载均衡。

**设计目标**：

- ✅ 简化的实例配置管理（相比 Go 版本移除服务发现）
- ✅ 统一的凭证存储（单表 JSONB 设计）
- ✅ 类型安全的 Rust 实现
- ✅ 灵活的实例选择策略
- ✅ 完整的生命周期管理

**关键概念**：

- **Provider Instance**：gRPC 服务实例（用于跨地域解析）
- **User Credential**：用户的媒体源凭证（存储在数据库）
- **Provider Instance Client**：连接到提供商实例的 gRPC 客户端
- **Provider**：媒体源提供商的实现（如 BilibiliProvider）

---

## 1. 数据库设计

### 1.1 Provider Instances 表

存储 gRPC 后端服务实例的配置。

**设计理念**：

- Instance 仅用于跨地域解析，不存储媒体实例配置
- 简化的实例配置（不包含服务发现机制）
- 敏感字段（jwt_secret, custom_ca）使用加密存储
- 参考 Go 版本的 VendorBackend，但移除 Consul/Etcd 服务发现

```sql
CREATE TABLE provider_instances (
    -- 主键
    name VARCHAR(64) PRIMARY KEY,

    -- 基本信息
    endpoint VARCHAR(512) NOT NULL,
    comment TEXT,

    -- gRPC 配置
    jwt_secret VARCHAR(256),        -- JWT密钥（加密存储）
    custom_ca TEXT,                 -- 自定义CA证书（加密存储）
    timeout VARCHAR(32) DEFAULT '10s',
    tls BOOLEAN NOT NULL DEFAULT false,
    insecure_tls BOOLEAN NOT NULL DEFAULT false,  -- 跳过TLS证书验证（不安全，仅开发/测试环境使用）

    -- Provider 支持（哪些提供商可以使用此后端）
    providers TEXT[] NOT NULL DEFAULT '{}',  -- 支持的提供商列表，如 {'bilibili', 'alist', 'emby'}

    -- 状态
    enabled BOOLEAN NOT NULL DEFAULT true,

    -- 审计
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT valid_name CHECK (length(trim(name)) > 0 AND length(name) <= 64),
    CONSTRAINT valid_endpoint CHECK (length(trim(endpoint)) > 0)
);

CREATE INDEX idx_provider_instances_enabled ON provider_instances(enabled);
CREATE INDEX idx_provider_instances_providers ON provider_instances USING gin(providers);
CREATE INDEX idx_provider_instances_endpoint ON provider_instances(endpoint);

CREATE TRIGGER update_provider_instances_updated_at
    BEFORE UPDATE ON provider_instances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE provider_instances IS 'gRPC 提供商实例配置表（用于跨地域解析）';
COMMENT ON COLUMN provider_instances.name IS '实例名称（唯一标识符，用于引用）';
COMMENT ON COLUMN provider_instances.endpoint IS 'gRPC 服务地址（如 grpc://beijing.example.com:50051）';
COMMENT ON COLUMN provider_instances.jwt_secret IS 'JWT 密钥（加密存储）';
COMMENT ON COLUMN provider_instances.custom_ca IS '自定义 CA 证书（加密存储）';
COMMENT ON COLUMN provider_instances.timeout IS '请求超时时间（如 10s, 30s）';
COMMENT ON COLUMN provider_instances.tls IS '是否启用 TLS';
COMMENT ON COLUMN provider_instances.insecure_tls IS '是否跳过 TLS 证书验证（不安全，仅开发/测试环境使用）';
COMMENT ON COLUMN provider_instances.providers IS '支持的提供商列表（数组），如 {bilibili, alist, emby}';
COMMENT ON CONSTRAINT valid_name ON provider_instances IS '名称不能为空或纯空格';
COMMENT ON CONSTRAINT valid_endpoint ON provider_instances IS '端点地址不能为空或纯空格';
```

**配置示例**：

```sql
-- 添加北京节点（支持所有提供商，启用TLS，验证证书）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('beijing-node', 'grpc://beijing.example.com:50051', '北京节点', '10s', true, false, '{bilibili,alist,emby}', true);

-- 添加上海节点（仅支持 Bilibili）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('shanghai-node', 'grpc://shanghai.example.com:50051', '上海节点', '10s', true, false, '{bilibili}', true);

-- 添加开发环境节点（跳过证书验证，仅用于测试）
INSERT INTO provider_instances (name, endpoint, comment, timeout, tls, insecure_tls, providers, enabled)
VALUES ('dev-node', 'grpc://dev.example.com:50051', '开发节点', '10s', true, true, '{bilibili,alist,emby}', true);

-- 查询支持 Alist 的实例
SELECT * FROM provider_instances WHERE 'alist' = ANY(providers) AND enabled = true;

-- 通过名称查询实例
SELECT * FROM provider_instances WHERE name = 'beijing-node';
```

### 1.2 User Provider Credentials 表

存储用户的媒体源提供商凭证（如 Bilibili Cookie、Alist 账户、Emby API Key）。

**设计理念**：

- **单表存储所有凭证**：使用 JSONB 灵活适配不同 Provider
- **ServerID 必需**：用于区分不同的服务器/账号
  - Bilibili: `server_id = "bilibili"`（固定常量，确保每个用户只能绑定一个账号）
  - Alist/Emby: `server_id = MD5(host)`（支持绑定多个服务器）
- **无需加密**：简化实现（Rust 版本不需要加密）
- **实例关联**：可选关联 provider_instances，用于指定解析实例

```sql
CREATE TABLE user_provider_credentials (
    -- 主键
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- 用户和提供商
    user_id UUID NOT NULL,
    provider VARCHAR(32) NOT NULL,  -- bilibili, alist, emby

    -- 服务器标识（必需，用于区分不同服务器/账号）
    server_id VARCHAR(64) NOT NULL,  -- Alist/Emby: MD5(host), Bilibili: "bilibili" 或账号标识

    -- 关联的提供商实例（可选）
    provider_instance_name VARCHAR(64),

    -- 凭证数据（JSONB，明文存储）
    credential_data JSONB NOT NULL,

    -- 过期时间（可选）
    expires_at TIMESTAMPTZ,

    -- 审计
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 约束
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_provider_instance FOREIGN KEY (provider_instance_name) REFERENCES provider_instances(name) ON DELETE SET NULL,
    CONSTRAINT unique_user_provider_server UNIQUE(user_id, provider, server_id),
    CONSTRAINT valid_server_id CHECK (length(trim(server_id)) > 0 AND length(server_id) <= 64)
);

CREATE INDEX idx_user_credentials_user ON user_provider_credentials(user_id);
CREATE INDEX idx_user_credentials_provider ON user_provider_credentials(provider);
CREATE INDEX idx_user_credentials_instance ON user_provider_credentials(provider_instance_name);
CREATE INDEX idx_user_credentials_expires ON user_provider_credentials(expires_at) WHERE expires_at IS NOT NULL;

CREATE TRIGGER update_user_credentials_updated_at
    BEFORE UPDATE ON user_provider_credentials
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE user_provider_credentials IS '用户媒体源凭证表';
COMMENT ON COLUMN user_provider_credentials.provider IS '提供商类型（bilibili, alist, emby）';
COMMENT ON COLUMN user_provider_credentials.server_id IS '服务器标识（必需），Bilibili 使用固定值 "bilibili"（每个用户只能绑定一个账号），Alist/Emby 使用 MD5(host)';
COMMENT ON COLUMN user_provider_credentials.provider_instance_name IS '关联的提供商实例名称（可选，用于指定解析实例）';
COMMENT ON COLUMN user_provider_credentials.credential_data IS '凭证数据（JSONB，明文存储）';
COMMENT ON COLUMN user_provider_credentials.expires_at IS '凭证过期时间（可选，用于 token/cookie 等会过期的凭证）';
COMMENT ON CONSTRAINT valid_server_id ON user_provider_credentials IS 'server_id 不能为空或纯空格';
COMMENT ON CONSTRAINT unique_user_provider_server ON user_provider_credentials IS '用户在同一提供商的同一服务器上只能有一个凭证（Bilibili 每用户唯一，Alist/Emby 可多个）';
```

**credential_data 结构示例**：

```json
// Bilibili 凭证
{
  "cookies": {
    "SESSDATA": "xxx",
    "bili_jct": "yyy",
    "DedeUserID": "123"
  }
}

// Alist 凭证
{
  "host": "https://alist.example.com",
  "username": "alice",
  "password": "hashed_password"  // 已经哈希过
}

// Emby 凭证
{
  "host": "https://emby.example.com",
  "api_key": "abc123456",
  "emby_user_id": "user-uuid"
}
```

---

## 2. Rust 数据模型

### 2.1 核心数据结构

```rust
// models/provider_instance.rs

use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

/// Provider Instance (gRPC 提供商实例配置)
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct ProviderInstance {
    pub name: String,                // 实例名称（主键）
    pub endpoint: String,
    pub comment: Option<String>,
    pub jwt_secret: Option<String>,  // 加密存储
    pub custom_ca: Option<String>,   // 加密存储
    pub timeout: String,
    pub tls: bool,
    pub insecure_tls: bool,          // 跳过TLS证书验证（不安全）
    pub providers: Vec<String>,      // 支持的提供商列表
    pub enabled: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// 用户 Provider 凭证
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct UserProviderCredential {
    pub id: Uuid,
    pub user_id: Uuid,
    pub provider: String,
    pub server_id: String,                       // 服务器标识（必需）
    pub provider_instance_name: Option<String>,  // 关联的提供商实例名称
    pub credential_data: serde_json::Value,      // JSONB，明文存储
    pub expires_at: Option<DateTime<Utc>>,       // 凭证过期时间（可选）
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Provider 凭证数据（枚举）
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ProviderCredential {
    Bilibili {
        cookies: HashMap<String, String>,
    },
    Alist {
        host: String,
        username: String,
        password: String,  // 已哈希
    },
    Emby {
        host: String,
        api_key: String,
        emby_user_id: String,
    },
}

impl UserProviderCredential {
    /// Bilibili 的固定 server_id（确保每个用户只能绑定一个账号）
    pub const BILIBILI_SERVER_ID: &'static str = "bilibili";

    /// 获取凭证数据
    pub fn get_credential(&self) -> Result<ProviderCredential> {
        serde_json::from_value(self.credential_data.clone())
            .map_err(|e| Error::InvalidCredential(e.to_string()))
    }

    /// 生成 ServerID（用于 Alist/Emby）
    pub fn generate_server_id(host: &str) -> String {
        use md5::{Md5, Digest};
        let mut hasher = Md5::new();
        hasher.update(host.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// 检查凭证是否已过期
    pub fn is_expired(&self) -> bool {
        if let Some(expires_at) = self.expires_at {
            expires_at <= Utc::now()
        } else {
            false  // 没有设置过期时间，视为永不过期
        }
    }

    /// 检查凭证是否有效（未过期）
    pub fn is_valid(&self) -> bool {
        !self.is_expired()
    }
}
```

---

## 3. Provider Instance Manager 设计

### 3.1 架构概述

```
┌─────────────────────────────────────────────────┐
│  ProviderInstanceManager (全局单例)             │
│  ┌───────────────────────────────────────────┐  │
│  │   instances: RwLock<HashMap>              │  │
│  │   name -> ConnectedProviderInstance       │  │
│  │   (仅存储远程实例)                         │  │
│  │                                           │  │
│  │   local_instance: ConnectedProviderInstance│ │
│  │   (本地实例，单独存储)                      │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
             │
             ├── init()          从数据库加载所有远程实例
             ├── get()           获取指定实例（找不到返回本地实例）
             ├── list()          列出所有远程实例
             ├── add()           添加新远程实例
             ├── update()        更新实例配置
             ├── delete()        删除实例
             ├── enable()        启用实例
             └── disable()       禁用实例
```

**设计理念**：

- 本地实现和远程实例统一为相同的接口
- 本地实例单独存储在 `local_instance` 字段，不占用 HashMap
- `get()` 方法自动降级：找不到指定实例时返回 `local_instance`
- Provider 层无需判断是本地还是远程，统一调用即可

### 3.2 核心实现

```rust
// services/provider_instance_manager.rs

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tonic::transport::{Channel, ClientTlsConfig, Endpoint};
use tower::ServiceBuilder;
use tower::timeout::TimeoutLayer;
use std::time::Duration;

/// 已连接的提供商实例
pub struct ConnectedProviderInstance {
    pub config: ProviderInstance,
    pub channel: Option<Channel>,  // None 表示本地实例
}

impl ConnectedProviderInstance {
    /// 检查是否为本地实例
    pub fn is_local(&self) -> bool {
        self.channel.is_none()
    }
}

/// Provider Instance Manager (全局单例)
pub struct ProviderInstanceManager {
    /// 远程实例（仅存储远程实例）
    instances: Arc<RwLock<HashMap<String, Arc<ConnectedProviderInstance>>>>,
    /// 本地实例（单独存储，作为降级实例）
    local_instance: Arc<ConnectedProviderInstance>,
    /// 数据库连接池
    db: PgPool,
}

impl ProviderInstanceManager {
    /// 创建新的 ProviderInstanceManager
    pub fn new(db: PgPool) -> Self {
        // 创建本地实例（无需 gRPC 连接）
        let local_instance = Arc::new(ConnectedProviderInstance {
            config: ProviderInstance {
                name: "local".to_string(),
                endpoint: "local://".to_string(),
                comment: Some("本地实现".to_string()),
                jwt_secret: None,
                custom_ca: None,
                timeout: "10s".to_string(),
                tls: false,
                insecure_tls: false,
                providers: vec!["bilibili".to_string(), "alist".to_string(), "emby".to_string()],
                enabled: true,
                created_at: Utc::now(),
                updated_at: Utc::now(),
            },
            channel: None,  // 本地实例无需 gRPC Channel
        });

        Self {
            instances: Arc::new(RwLock::new(HashMap::new())),
            local_instance,
            db,
        }
    }

    /// 从数据库初始化所有远程实例
    pub async fn init(&self) -> Result<()> {
        tracing::info!("Initializing provider instance manager with local instance");

        // 从数据库加载远程实例
        let configs = sqlx::query_as::<_, ProviderInstance>(
            "SELECT * FROM provider_instances WHERE enabled = true"
        )
        .fetch_all(&self.db)
        .await?;

        let mut instances = self.instances.write().await;

        for config in configs {
            match Self::create_connected_instance(config.clone()).await {
                Ok(instance) => {
                    instances.insert(config.name.clone(), Arc::new(instance));
                    tracing::info!("Loaded remote provider instance: {}", config.name);
                }
                Err(e) => {
                    tracing::error!("Failed to load provider instance {}: {}", config.name, e);
                }
            }
        }

        tracing::info!(
            "Provider instance manager initialized with {} remote instances",
            instances.len()
        );

        Ok(())
    }

    /// 创建已连接的提供商实例（建立 gRPC 连接）
    async fn create_connected_instance(config: ProviderInstance) -> Result<ConnectedProviderInstance> {
        let timeout = config.timeout.parse::<humantime::Duration>()
            .map(Duration::from)
            .unwrap_or(Duration::from_secs(10));

        let mut endpoint = Endpoint::from_shared(config.endpoint.clone())?
            .timeout(timeout);

        // 配置 TLS
        if config.tls {
            let mut tls_config = ClientTlsConfig::new();

            if config.insecure_tls {
                // 跳过证书验证（仅用于开发/测试）
                tls_config = tls_config.with_native_roots();
            } else {
                // 正常证书验证
                if let Some(ref ca) = config.custom_ca {
                    let cert = tonic::transport::Certificate::from_pem(ca);
                    tls_config = tls_config.ca_certificate(cert);
                }
            }

            endpoint = endpoint.tls_config(tls_config)?;
        }

        // 建立连接
        let channel = endpoint.connect().await?;

        // 应用中间件（超时、重试等）
        let channel = ServiceBuilder::new()
            .layer(TimeoutLayer::new(timeout))
            .service(channel);

        Ok(ConnectedProviderInstance {
            config,
            channel: Some(channel),  // 远程实例有 gRPC Channel
        })
    }

    /// 获取提供商实例（找不到时自动返回本地实例）
    ///
    /// 这是最常用的方法，总是返回一个可用的实例。
    /// 如果指定名称的远程实例不存在或不可用，自动降级到本地实例。
    pub async fn get(&self, name: &str) -> Arc<ConnectedProviderInstance> {
        // 1. 尝试从远程实例 HashMap 中获取
        if let Some(instance) = self.instances.read().await.get(name).cloned() {
            return instance;
        }

        // 2. 找不到远程实例，返回本地实例（保证总是有返回值）
        self.local_instance.clone()
    }

    /// 尝试获取远程实例（找不到返回 None，不自动降级）
    ///
    /// 仅当需要明确区分远程实例和本地实例时使用。
    /// 大多数情况下应该使用 `get()` 方法。
    pub async fn try_get(&self, name: &str) -> Option<Arc<ConnectedProviderInstance>> {
        self.instances.read().await.get(name).cloned()
    }

    /// 列出所有远程实例
    pub async fn list(&self) -> Vec<Arc<ConnectedProviderInstance>> {
        self.instances.read().await.values().cloned().collect()
    }

    /// 根据 Provider 查找支持的远程实例
    pub async fn find_by_provider(&self, provider: &str) -> Vec<Arc<ConnectedProviderInstance>> {
        self.instances
            .read()
            .await
            .values()
            .filter(|instance| {
                instance.config.enabled &&
                instance.config.providers.contains(&provider.to_string())
            })
            .cloned()
            .collect()
    }

    /// 获取本地实例
    pub fn get_local(&self) -> Arc<ConnectedProviderInstance> {
        self.local_instance.clone()
    }

    /// 添加新的提供商实例
    pub async fn add(&self, config: ProviderInstance) -> Result<()> {
        // 1. 创建 gRPC 连接
        let instance = Self::create_connected_instance(config.clone()).await?;

        // 2. 保存到数据库
        sqlx::query(
            r#"
            INSERT INTO provider_instances
            (name, endpoint, comment, jwt_secret, custom_ca, timeout, tls, insecure_tls, providers, enabled)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            "#
        )
        .bind(&config.name)
        .bind(&config.endpoint)
        .bind(&config.comment)
        .bind(&config.jwt_secret)
        .bind(&config.custom_ca)
        .bind(&config.timeout)
        .bind(config.tls)
        .bind(config.insecure_tls)
        .bind(&config.providers)
        .bind(config.enabled)
        .execute(&self.db)
        .await?;

        // 3. 添加到内存
        self.instances.write().await.insert(
            config.name.clone(),
            Arc::new(instance),
        );

        tracing::info!("Added provider instance: {}", config.name);
        Ok(())
    }

    /// 更新提供商实例
    pub async fn update(&self, config: ProviderInstance) -> Result<()> {
        // 1. 创建新的 gRPC 连接
        let instance = Self::create_connected_instance(config.clone()).await?;

        // 2. 更新数据库
        sqlx::query(
            r#"
            UPDATE provider_instances
            SET endpoint = $2, comment = $3, jwt_secret = $4, custom_ca = $5,
                timeout = $6, tls = $7, insecure_tls = $8, providers = $9, enabled = $10,
                updated_at = NOW()
            WHERE name = $1
            "#
        )
        .bind(&config.name)
        .bind(&config.endpoint)
        .bind(&config.comment)
        .bind(&config.jwt_secret)
        .bind(&config.custom_ca)
        .bind(&config.timeout)
        .bind(config.tls)
        .bind(config.insecure_tls)
        .bind(&config.providers)
        .bind(config.enabled)
        .execute(&self.db)
        .await?;

        // 3. 更新内存（关闭旧连接）
        let old_instance = self.instances.write().await.insert(
            config.name.clone(),
            Arc::new(instance),
        );

        // 旧连接会在 Arc 引用计数归零时自动关闭

        tracing::info!("Updated provider instance: {}", config.name);
        Ok(())
    }

    /// 删除提供商实例
    pub async fn delete(&self, name: &str) -> Result<()> {
        // 1. 从数据库删除
        sqlx::query("DELETE FROM provider_instances WHERE name = $1")
            .bind(name)
            .execute(&self.db)
            .await?;

        // 2. 从内存移除
        self.instances.write().await.remove(name);

        tracing::info!("Deleted provider instance: {}", name);
        Ok(())
    }

    /// 启用提供商实例
    pub async fn enable(&self, name: &str) -> Result<()> {
        sqlx::query("UPDATE provider_instances SET enabled = true WHERE name = $1")
            .bind(name)
            .execute(&self.db)
            .await?;

        // 重新加载实例
        let config = sqlx::query_as::<_, ProviderInstance>(
            "SELECT * FROM provider_instances WHERE name = $1"
        )
        .bind(name)
        .fetch_one(&self.db)
        .await?;

        let instance = Self::create_connected_instance(config.clone()).await?;
        self.instances.write().await.insert(
            config.name.clone(),
            Arc::new(instance),
        );

        tracing::info!("Enabled provider instance: {}", name);
        Ok(())
    }

    /// 禁用提供商实例
    pub async fn disable(&self, name: &str) -> Result<()> {
        sqlx::query("UPDATE provider_instances SET enabled = false WHERE name = $1")
            .bind(name)
            .execute(&self.db)
            .await?;

        // 从内存移除
        self.instances.write().await.remove(name);

        tracing::info!("Disabled provider instance: {}", name);
        Ok(())
    }

    /// 健康检查（检查所有实例的连接状态）
    pub async fn health_check(&self) -> HashMap<String, bool> {
        let instances = self.instances.read().await;
        let mut results = HashMap::new();

        for (name, _instance) in instances.iter() {
            // 这里可以实现实际的健康检查逻辑
            // 例如调用 gRPC 的 health check endpoint
            results.insert(name.clone(), true);
        }

        results
    }
}
```

---

## 4. Provider 使用 Provider Instance

### 4.1 统一的 Provider 接口

本地实现和远程实例都实现相同的接口，Provider 层无需区分：

```rust
// services/providers/bilibili_service.rs

/// Bilibili 服务接口（本地和远程统一）
#[async_trait]
pub trait BilibiliService: Send + Sync {
    async fn parse(&self, req: &ParseRequest) -> Result<ParseResponse>;
    async fn generate_url(&self, req: &GenerateUrlRequest) -> Result<GenerateUrlResponse>;
}

/// 本地 Bilibili 服务实现
pub struct LocalBilibiliService {
    http_client: reqwest::Client,
}

impl LocalBilibiliService {
    pub fn new() -> Self {
        Self {
            http_client: reqwest::Client::new(),
        }
    }
}

#[async_trait]
impl BilibiliService for LocalBilibiliService {
    async fn parse(&self, req: &ParseRequest) -> Result<ParseResponse> {
        // 直接调用 Bilibili API 实现
        // ...
    }

    async fn generate_url(&self, req: &GenerateUrlRequest) -> Result<GenerateUrlResponse> {
        // 直接调用 Bilibili API 实现
        // ...
    }
}

/// 远程 Bilibili 服务实现（gRPC）
pub struct RemoteBilibiliService {
    channel: Channel,
}

#[async_trait]
impl BilibiliService for RemoteBilibiliService {
    async fn parse(&self, req: &ParseRequest) -> Result<ParseResponse> {
        use crate::proto::bilibili::bilibili_service_client::BilibiliServiceClient;

        let mut client = BilibiliServiceClient::new(self.channel.clone());
        let response = client.parse(tonic::Request::new(req.clone())).await?;
        Ok(response.into_inner())
    }

    async fn generate_url(&self, req: &GenerateUrlRequest) -> Result<GenerateUrlResponse> {
        use crate::proto::bilibili::bilibili_service_client::BilibiliServiceClient;

        let mut client = BilibiliServiceClient::new(self.channel.clone());
        let response = client.generate_url(tonic::Request::new(req.clone())).await?;
        Ok(response.into_inner())
    }
}
```

### 4.2 在 Provider 中使用实例（简化版）

```rust
// providers/bilibili.rs

use crate::services::provider_instance_manager::ProviderInstanceManager;
use crate::services::providers::bilibili_service::{BilibiliService, LocalBilibiliService, RemoteBilibiliService};

pub struct BilibiliProvider {
    provider_instance_manager: Arc<ProviderInstanceManager>,
    local_service: Arc<LocalBilibiliService>,
}

impl BilibiliProvider {
    pub fn new(provider_instance_manager: Arc<ProviderInstanceManager>) -> Self {
        Self {
            provider_instance_manager,
            local_service: Arc::new(LocalBilibiliService::new()),
        }
    }

    /// 获取 Bilibili 服务（自动选择本地或远程）
    async fn get_service(&self, ctx: &ProviderContext<'_>) -> Arc<dyn BilibiliService> {
        // 1. 选择实例（自动降级到本地）
        let instance = self.select_provider_instance(ctx).await;

        // 2. 根据实例类型返回对应的服务
        if instance.is_local() {
            // 本地实例：返回本地服务
            self.local_service.clone() as Arc<dyn BilibiliService>
        } else {
            // 远程实例：返回远程服务
            Arc::new(RemoteBilibiliService {
                channel: instance.channel.as_ref().unwrap().clone(),
            }) as Arc<dyn BilibiliService>
        }
    }

    /// 选择提供商实例（总是返回实例，自动降级到本地）
    async fn select_provider_instance(&self, ctx: &ProviderContext<'_>) -> Arc<ConnectedProviderInstance> {
        // 1. 优先使用 ctx 中指定的实例
        if let Some(ref name) = ctx.provider_instance_name {
            let instance = self.provider_instance_manager.get(name).await;
            if instance.config.providers.contains(&"bilibili".to_string()) {
                return instance;
            }
        }

        // 2. 检查凭证中关联的实例
        if let Some(requester) = ctx.requester {
            if let Ok(Some(cred)) = UserProviderCredential::get_bilibili(requester.id).await {
                if let Some(ref name) = cred.provider_instance_name {
                    return self.provider_instance_manager.get(name).await;
                }
            }
        }

        // 3. 自动选择一个支持 Bilibili 的远程实例（负载均衡）
        let remote_instances = self.provider_instance_manager.find_by_provider("bilibili").await;
        if !remote_instances.is_empty() {
            // 简单的轮询策略（可以实现更复杂的策略）
            return remote_instances[0].clone();
        }

        // 4. 没有可用的远程实例，返回本地实例
        self.provider_instance_manager.get_local()
    }
}

impl MediaProvider for BilibiliProvider {
    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 解析 source_config
        let bvid = media.source_config.get("bvid")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let share = media.source_config.get("share")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        // 2. 根据 share 标志获取凭证
        let credential = if share {
            // 共享模式：仅使用创建者凭证（允许其他用户使用创建者的会员权限）
            ctx.get_creator_credential("bilibili", UserProviderCredential::BILIBILI_SERVER_ID)
                .await?
                .ok_or(Error::CredentialRequired)?
        } else {
            // 非共享模式：优先请求者凭证，降级到创建者凭证
            if let Some(cred) = ctx.get_requester_credential("bilibili", UserProviderCredential::BILIBILI_SERVER_ID).await? {
                cred
            } else if let Some(cred) = ctx.get_creator_credential("bilibili", UserProviderCredential::BILIBILI_SERVER_ID).await? {
                cred
            } else {
                return Err(Error::CredentialRequired);
            }
        };

        // 3. 获取服务（自动选择本地或远程）
        let service = self.get_service(ctx).await;

        // 4. 调用服务（无需判断本地还是远程）
        let request = ParseRequest {
            bvid: bvid.to_string(),
            credential: serde_json::to_string(&credential.credential_data)?,
        };

        let response = service.parse(&request).await?;

        // 5. 转换为 ParseResult
        Ok(ParseResult {
            // ... 转换逻辑
        })
    }
}
```

### 4.3 不同 Provider 的凭证策略

不同的 Provider 有不同的凭证需求，以下是典型场景：

#### Alist Provider（私有访问模式）

```rust
impl MediaProvider for AlistProvider {
    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 解析路径，提取 server_id
        let path = media.source_config.get("path")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let server_id = path.trim_start_matches('/').split('/').next()
            .ok_or(Error::InvalidPath)?;

        // 2. Alist 必须使用请求者自己的凭证（私有访问）
        let credential = ctx.get_requester_credential("alist", server_id)
            .await?
            .ok_or(Error::CredentialRequired)?;

        // 3. 获取 Alist 服务并调用
        let service = self.get_service(ctx).await;
        let response = service.fs_get(&credential, path).await?;

        Ok(ParseResult {
            // ... 转换逻辑
        })
    }
}
```

#### Emby Provider（降级模式）

```rust
impl MediaProvider for EmbyProvider {
    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 提取 server_id
        let path = media.source_config.get("path")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        let server_id = path.trim_start_matches('/').split('/').next()
            .ok_or(Error::InvalidPath)?;

        // 2. 优先请求者凭证，降级到创建者凭证
        let credential = ctx.get_requester_credential("emby", server_id)
            .await?
            .or(ctx.get_creator_credential("emby", server_id).await?)
            .ok_or(Error::CredentialRequired)?;

        // 3. 调用 Emby API
        let service = self.get_service(ctx).await;
        let response = service.get_item(&credential, path).await?;

        Ok(ParseResult {
            // ... 转换逻辑
        })
    }
}
```

#### Direct URL Provider（无需凭证）

```rust
impl MediaProvider for DirectUrlProvider {
    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // Direct URL 不需要凭证，直接返回 URL
        Ok(ParseResult {
            parsed_data: ParsedData {
                playback_url: media.url.clone(),
                headers: HashMap::new(),
                proxy: false,
                expire_at: None,
            },
            metadata: MediaMetadata::default(),
            provider_data: serde_json::Value::Null,
        })
    }
}
```

### 4.4 凭证获取最佳实践

#### 原则 1: 明确凭证来源

❌ **错误**：使用自动降级（不明确）

```rust
// 不存在的方法，已移除
let credential = ctx.get_credential("bilibili", "bilibili").await?;
```

✅ **正确**：明确指定凭证来源

```rust
// 明确使用请求者凭证
let credential = ctx.get_requester_credential("bilibili", "bilibili").await?;

// 或明确使用创建者凭证
let credential = ctx.get_creator_credential("bilibili", "bilibili").await?;
```

#### 原则 2: 根据业务逻辑选择策略

✅ **共享模式**：仅使用创建者凭证

```rust
if share {
    ctx.get_creator_credential("bilibili", "bilibili").await?
} else {
    // 非共享模式逻辑
}
```

✅ **私有模式**：仅使用请求者凭证

```rust
ctx.get_requester_credential("alist", &server_id).await?
    .ok_or(Error::CredentialRequired)?
```

✅ **降级模式**：优先请求者，降级到创建者

```rust
ctx.get_requester_credential("emby", &server_id).await?
    .or(ctx.get_creator_credential("emby", &server_id).await?)
    .ok_or(Error::CredentialRequired)?
```

#### 原则 3: 提供清晰的错误信息

```rust
let credential = ctx.get_requester_credential("alist", &server_id).await?
    .ok_or_else(|| Error::MissingCredential {
        provider: "alist".to_string(),
        server_id: server_id.to_string(),
        message: "You must login to this Alist server first".to_string(),
    })?;
```

---

## 5. 本地服务实现

### 5.1 本地服务注册

参考 Go 版本的设计，本地服务在 Manager 初始化时自动注册：

```rust
// services/providers/mod.rs

use once_cell::sync::Lazy;

/// 全局本地服务实例（类似 Go 的 init() 初始化）
pub static LOCAL_BILIBILI_SERVICE: Lazy<Arc<LocalBilibiliService>> = Lazy::new(|| {
    Arc::new(LocalBilibiliService::new())
});

pub static LOCAL_ALIST_SERVICE: Lazy<Arc<LocalAlistService>> = Lazy::new(|| {
    Arc::new(LocalAlistService::new())
});

pub static LOCAL_EMBY_SERVICE: Lazy<Arc<LocalEmbyService>> = Lazy::new(|| {
    Arc::new(LocalEmbyService::new())
});
```

### 5.2 加载服务（类似 Go 的 LoadAlistClient）

```rust
// services/provider_instance_manager.rs

impl ProviderInstanceManager {
    /// 加载 Bilibili 服务（自动降级）
    ///
    /// 类似 Go 版本的 LoadAlistClient：
    /// - 找到指定实例：返回远程服务
    /// - 找不到：返回本地服务
    pub async fn load_bilibili_service(&self, name: Option<&str>) -> Arc<dyn BilibiliService> {
        if let Some(name) = name {
            let instance = self.get(name).await;
            if !instance.is_local() && instance.config.providers.contains(&"bilibili".to_string()) {
                return Arc::new(RemoteBilibiliService {
                    channel: instance.channel.as_ref().unwrap().clone(),
                }) as Arc<dyn BilibiliService>;
            }
        }

        // 返回本地服务
        LOCAL_BILIBILI_SERVICE.clone() as Arc<dyn BilibiliService>
    }

    /// 加载 Alist 服务（自动降级）
    pub async fn load_alist_service(&self, name: Option<&str>) -> Arc<dyn AlistService> {
        if let Some(name) = name {
            let instance = self.get(name).await;
            if !instance.is_local() && instance.config.providers.contains(&"alist".to_string()) {
                return Arc::new(RemoteAlistService {
                    channel: instance.channel.as_ref().unwrap().clone(),
                }) as Arc<dyn AlistService>;
            }
        }

        // 返回本地服务
        LOCAL_ALIST_SERVICE.clone() as Arc<dyn AlistService>
    }

    /// 加载 Emby 服务（自动降级）
    pub async fn load_emby_service(&self, name: Option<&str>) -> Arc<dyn EmbyService> {
        if let Some(name) = name {
            let instance = self.get(name).await;
            if !instance.is_local() && instance.config.providers.contains(&"emby".to_string()) {
                return Arc::new(RemoteEmbyService {
                    channel: instance.channel.as_ref().unwrap().clone(),
                }) as Arc<dyn EmbyService>;
            }
        }

        // 返回本地服务
        LOCAL_EMBY_SERVICE.clone() as Arc<dyn EmbyService>
    }

    /// 获取本地 Bilibili 服务
    pub fn local_bilibili_service() -> Arc<dyn BilibiliService> {
        LOCAL_BILIBILI_SERVICE.clone() as Arc<dyn BilibiliService>
    }

    /// 获取本地 Alist 服务
    pub fn local_alist_service() -> Arc<dyn AlistService> {
        LOCAL_ALIST_SERVICE.clone() as Arc<dyn AlistService>
    }

    /// 获取本地 Emby 服务
    pub fn local_emby_service() -> Arc<dyn EmbyService> {
        LOCAL_EMBY_SERVICE.clone() as Arc<dyn EmbyService>
    }
}
```

### 5.3 Provider 使用简化

使用 `load_*_service()` 方法，代码更简洁：

```rust
impl MediaProvider for BilibiliProvider {
    async fn parse(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<ParseResult> {
        // 1. 获取用户凭证
        let credential = ctx.get_credential("bilibili", Some(UserProviderCredential::BILIBILI_SERVER_ID)).await?
            .ok_or(Error::CredentialRequired)?;

        // 2. 选择实例名称（优先级：ctx > 凭证 > None）
        let instance_name = ctx.provider_instance_name.as_deref()
            .or_else(|| credential.provider_instance_name.as_deref());

        // 3. 加载服务（自动降级到本地）
        let service = self.provider_instance_manager
            .load_bilibili_service(instance_name)
            .await;

        // 4. 调用服务
        let request = ParseRequest {
            bvid: media.source_config["bvid"].as_str().unwrap().to_string(),
            credential: serde_json::to_string(&credential.credential_data)?,
        };

        let response = service.parse(&request).await?;

        // 5. 转换为 ParseResult
        Ok(ParseResult {
            // ... 转换逻辑
        })
    }
}
```

---

## 6. API 设计

### 6.1 REST API

```rust
// api/handlers/provider_instance.rs

/// 列出所有提供商实例
/// GET /api/admin/provider-instances
pub async fn list_provider_instances(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
) -> Result<Json<Vec<ProviderInstance>>> {
    let instances = provider_instance_manager.list().await;
    let configs: Vec<_> = instances.iter()
        .map(|i| i.config.clone())
        .collect();
    Ok(Json(configs))
}

/// 获取提供商实例详情
/// GET /api/admin/provider-instances/:name
pub async fn get_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Path(name): Path<String>,
) -> Result<Json<ProviderInstance>> {
    let instance = provider_instance_manager.get(&name).await
        .ok_or(Error::NotFound)?;
    Ok(Json(instance.config.clone()))
}

/// 添加提供商实例
/// POST /api/admin/provider-instances
pub async fn add_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Json(config): Json<ProviderInstance>,
) -> Result<StatusCode> {
    provider_instance_manager.add(config).await?;
    Ok(StatusCode::CREATED)
}

/// 更新提供商实例
/// PUT /api/admin/provider-instances/:name
pub async fn update_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Path(name): Path<String>,
    Json(mut config): Json<ProviderInstance>,
) -> Result<StatusCode> {
    config.name = name;
    provider_instance_manager.update(config).await?;
    Ok(StatusCode::OK)
}

/// 删除提供商实例
/// DELETE /api/admin/provider-instances/:name
pub async fn delete_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Path(name): Path<String>,
) -> Result<StatusCode> {
    provider_instance_manager.delete(&name).await?;
    Ok(StatusCode::NO_CONTENT)
}

/// 启用提供商实例
/// POST /api/admin/provider-instances/:name/enable
pub async fn enable_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Path(name): Path<String>,
) -> Result<StatusCode> {
    provider_instance_manager.enable(&name).await?;
    Ok(StatusCode::OK)
}

/// 禁用提供商实例
/// POST /api/admin/provider-instances/:name/disable
pub async fn disable_provider_instance(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
    Path(name): Path<String>,
) -> Result<StatusCode> {
    provider_instance_manager.disable(&name).await?;
    Ok(StatusCode::OK)
}

/// 健康检查
/// GET /api/admin/provider-instances/health
pub async fn health_check(
    State(provider_instance_manager): State<Arc<ProviderInstanceManager>>,
) -> Result<Json<HashMap<String, bool>>> {
    let results = provider_instance_manager.health_check().await;
    Ok(Json(results))
}
```

---

## 7. 初始化和注册

### 7.1 应用启动时初始化

```rust
// main.rs

use crate::services::provider_instance_manager::ProviderInstanceManager;

#[tokio::main]
async fn main() -> Result<()> {
    // 1. 初始化数据库连接池
    let db = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    // 2. 创建 Provider Instance Manager
    let provider_instance_manager = Arc::new(ProviderInstanceManager::new(db.clone()));

    // 3. 从数据库加载所有提供商实例
    provider_instance_manager.init().await?;

    // 4. 将 Provider Instance Manager 注入到应用状态
    let app_state = AppState {
        db,
        provider_instance_manager: provider_instance_manager.clone(),
    };

    // 5. 启动 HTTP 服务器
    let app = Router::new()
        .route("/api/admin/provider-instances", get(list_provider_instances).post(add_provider_instance))
        .route("/api/admin/provider-instances/:name", get(get_provider_instance).put(update_provider_instance).delete(delete_provider_instance))
        .route("/api/admin/provider-instances/:name/enable", post(enable_provider_instance))
        .route("/api/admin/provider-instances/:name/disable", post(disable_provider_instance))
        .route("/api/admin/provider-instances/health", get(health_check))
        .with_state(app_state);

    // ... 启动服务器

    Ok(())
}
```

---

## 8. 与 Go 版本的对比

| 特性       | Go 版本                          | Rust 版本                         |
|------------|----------------------------------|-----------------------------------|
| 服务发现   | ✅ Consul/Etcd                   | ❌ 不支持（简化）                 |
| 本地实例   | `init()` + 全局变量              | Manager 字段（单独存储）          |
| 自动降级   | `LoadAlistClient()` 手动判断     | `get()` 自动返回本地实例          |
| 接口统一   | gRPC interface                   | Rust trait (`dyn Service`)        |
| 连接管理   | `sync.Mutex`                     | `Arc + RwLock`                    |
| gRPC 客户端| go-kratos                        | tonic                             |
| 熔断器     | go-kratos/aegis                  | 可选（tower）                     |
| 类型安全   | 运行时                           | 编译时                            |
| 配置加密   | AES + Base64                     | 数据库级加密                      |
| 动态更新   | ✅                               | ✅                                |
| 健康检查   | ❌ 无                            | ✅ 有                             |

**Go 版本的 LoadAlistClient 实现**：

```go
func LoadAlistClient(name string) AlistInterface {
    if cli, ok := LoadClients().alist[name]; ok {
        return cli
    }
    return alistLocalClient  // 找不到返回本地实现
}
```

**Rust 版本的对应实现**：

```rust
pub async fn get(&self, name: &str) -> Arc<ConnectedProviderInstance> {
    // 尝试从远程实例 HashMap 中获取
    if let Some(instance) = self.instances.read().await.get(name).cloned() {
        return instance;
    }
    // 找不到时返回本地实例字段
    self.local_instance.clone()
}
```

**优化点**：

- ✅ 移除服务发现，简化部署
- ✅ 本地实例单独存储为字段，不占用 HashMap
- ✅ 使用 Rust 的类型系统提高安全性
- ✅ 更清晰的错误处理
- ✅ 更好的并发模型（async/await）
- ✅ 增加健康检查功能
- ✅ `get()` 方法保证总是返回实例（自动降级）

---

## 9. 配置示例

### 9.1 通过 API 添加实例

```bash
# 添加北京节点
curl -X POST http://localhost:8080/api/admin/provider-instances \
  -H "Content-Type: application/json" \
  -d '{
    "name": "beijing-node",
    "endpoint": "grpc://beijing.example.com:50051",
    "comment": "北京节点",
    "timeout": "10s",
    "tls": true,
    "insecure_tls": false,
    "providers": ["bilibili", "alist", "emby"],
    "enabled": true
  }'

# 启用/禁用实例
curl -X POST http://localhost:8080/api/admin/provider-instances/beijing-node/enable
curl -X POST http://localhost:8080/api/admin/provider-instances/beijing-node/disable

# 健康检查
curl http://localhost:8080/api/admin/provider-instances/health
```

### 9.2 通过数据库直接配置

```sql
-- 插入实例配置
INSERT INTO provider_instances (name, endpoint, timeout, tls, providers, enabled)
VALUES ('beijing-node', 'grpc://beijing.example.com:50051', '10s', true, '{bilibili,alist,emby}', true);

-- 应用重启后会自动加载
```

---

## 10. 最佳实践

### 10.1 实例选择策略（四级优先级）

Provider Instance Manager 使用四级优先级自动选择实例：

1. **明确指定**（最高优先级）
   - 在 `ProviderContext` 中设置 `provider_instance_name`
   - 适用场景：Media/Playlist 配置指定特定实例

2. **凭证关联**（第二优先级）
   - 在 `user_provider_credentials` 表中设置 `provider_instance_name`
   - 适用场景：用户登录凭证时指定默认实例

3. **自动选择远程实例**（第三优先级）
   - 系统根据负载均衡策略从远程实例池中选择
   - 适用场景：有多个可用远程实例时
   - 策略：轮询、随机、最小负载等

4. **本地实例降级**（兜底策略）
   - 如果以上都没找到可用实例，自动返回本地实例
   - 适用场景：无远程实例或所有远程实例不可用
   - 保证服务总是可用

**核心设计**：

- `get(name)` 方法总是返回实例（找不到返回本地）
- `try_get(name)` 方法可能返回 None（不自动降级）
- Provider 层无需判断是本地还是远程，统一调用接口即可

### 10.2 安全建议

- ✅ 在生产环境始终启用 TLS（`tls: true, insecure_tls: false`）
- ✅ 使用 JWT 进行实例认证
- ✅ 定期轮换 JWT 密钥
- ✅ 对敏感字段（jwt_secret, custom_ca）进行数据库级加密

### 10.3 性能优化

- ✅ 使用连接池复用 gRPC 连接
- ✅ 实现熔断器防止雪崩
- ✅ 配置合理的超时时间
- ✅ 监控实例健康状态

---

## 11. 总结

本文档描述了 SyncTV Rust 版本的 Provider Instance 配置管理系统，核心设计理念：

### 核心特性

1. **统一接口设计**
   - 本地实现和远程实例实现相同接口
   - Provider 层无需区分本地还是远程
   - 通过 `channel: Option<Channel>` 区分实例类型

2. **自动降级机制**
   - 本地实例单独存储为 `local_instance` 字段
   - `get()` 方法保证总是返回实例
   - 找不到远程实例时自动返回 `local_instance`
   - 保证服务高可用

3. **四级优先级选择**
   - ctx 指定 > 凭证关联 > 自动选择远程 > 本地降级
   - 灵活支持多种使用场景
   - 自动负载均衡

4. **简化的部署**
   - 移除服务发现（Consul/Etcd），降低复杂度
   - 支持动态添加/更新/删除远程实例
   - 本地实例无需配置，开箱即用

### 相比 Go 版本的优化

| 特性     | Go 版本             | Rust 版本                     |
|----------|---------------------|-------------------------------|
| 本地实例 | 全局变量            | Manager 字段（单独存储）      |
| 自动降级 | 手动判断            | `get()` 自动降级              |
| 接口统一 | gRPC interface      | Rust trait                    |
| 类型安全 | 运行时              | 编译时                        |
| 服务发现 | ✅ Consul/Etcd      | ❌ 简化移除                   |
| 熔断器   | go-kratos/aegis     | tower（可选）                 |

### 设计优势

- ✅ **高可用**：自动降级保证服务总是可用（本地实例作为兜底）
- ✅ **简洁**：Provider 层代码简化，无需判断本地/远程
- ✅ **清晰**：本地实例单独存储，HashMap 仅用于远程实例
- ✅ **灵活**：支持多种实例选择策略
- ✅ **安全**：Rust 类型系统保证编译时安全
- ✅ **易维护**：统一接口，易于扩展新的实例类型

这套设计既保留了跨地域解析的能力，又大幅简化了系统复杂度，更适合 Rust 生态和当前项目需求。

---

**上一章**: [08-视频内容管理](./08-视频内容管理.md)
**下一章**: [10-视频链接过期与代理机制](./10-视频链接过期与代理机制.md)
