# 22. 视频链接过期与代理机制

> 基于 Go SyncTV 实现分析，重新设计更优雅的 Rust 架构

---

## 目录

- [1. Go 版本实现分析](#1-go-版本实现分析)
- [2. Rust 重新设计](#2-rust-重新设计)
- [3. MediaProvider 抽象设计](#3-mediasource-抽象设计)
- [4. 代理层实现](#4-代理层实现)
- [5. 过期机制](#5-过期机制)
- [6. 实现示例](#6-实现示例)

---

## 1. Go 版本实现分析

### 1.1 核心机制

**ExpireID 系统**（Go 版本）：

```go
// 每个 Movie 有一个 ExpireID，用于检测内容是否过期
func (m *Movie) ExpireID(ctx context.Context) (uint64, error)
func (m *Movie) CheckExpired(ctx context.Context, expireID uint64) (bool, error)
```

**工作原理**：

- Alist Ali: 使用缓存时间戳
- Bilibili Live: 使用缓存时间戳
- 其他: 使用 CRC32(movieID) 作为基础 ID
- 客户端定期通过 WebSocket 发送 `ExpireID`，服务器检查是否变化
- 如果变化，发送 `MessageType_EXPIRED` 通知客户端刷新

### 1.2 JWT Token 使用

**Go 版本的 JWT**：

```go
type AuthClaims struct {
    UserID      string `json:"u"`
    UserVersion uint32 `json:"uv"`
    jwt.RegisteredClaims
}
```

**用途**：

1. ✅ **用户认证**：验证用户身份和房间权限
2. ✅ **M3U8 Segment**：每个 segment 生成独立的 JWT（包含 target URL）
3. ⚠️ **普通代理**：URL 查询参数中包含 token（实际上用 Session 就够了）

**生成的 URL 示例**：

```
# 普通代理
/api/room/movie/proxy/{movieId}?token={userJWT}&roomId={roomId}

# M3U8 Segment
/api/room/movie/proxy/{movieId}/m3u8/{targetToken}?token={userJWT}&roomId={roomId}
```

### 1.3 问题分析

Go 版本存在的问题：

1. **JWT 过度使用**：
   - 普通代理不需要 JWT，Session/Cookie 验证就够
   - 每个请求都携带 JWT 增加带宽

2. **ExpireID 轮询**：
   - 客户端需要定期通过 WebSocket 发送 ExpireID
   - 服务器需要每次检查是否过期

3. **缺乏统一抽象**：
   - 每个提供者的代理逻辑分散在不同文件
   - 难以扩展新的视频源

4. **M3U8 处理复杂**：
   - 需要重写整个 playlist
   - 每个 segment 生成独立 token

---

## 2. Rust 重新设计

### 2.1 设计原则

**核心理念**：

1. ✅ **Trait 抽象**：统一的 `MediaProvider` trait
2. ✅ **类型安全**：使用 enum 表示不同的代理策略
3. ✅ **Session 认证**：代理只需 Session，不需要 JWT
4. ✅ **客户端主动刷新**：服务器返回过期时间，客户端在到期前主动请求新链接
5. ✅ **零拷贝代理**：使用 `Stream` 高效转发

### 2.2 架构概览

```rust
┌──────────────────────────────────────────────────────────┐
│                    客户端请求                             │
│  GET /api/room/{roomId}/movie/{movieId}/url              │
│  Cookie: session=xxx                                     │
└──────────────────┬───────────────────────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  Session 验证         │
        │  - 用户是否在房间？   │
        │  - 是否有观看权限？   │
        └──────────┬────────────┘
                   │
                   ▼
        ┌────────────────────────────────────┐
        │  MediaProvider::generate_url() │
        │  (根据配置返回第三方或代理URL)      │
        └──────────┬────────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  返回 URL + 过期时间  │
        │  - url: 播放地址      │
        │  - expire_at: 时间戳  │
        │  (客户端据此主动刷新) │
        └──────────────────────┘
```

### 2.3 实现方式对比

| 特性 | 第三方直连 | 服务器代理 |
|------|-----------|-----------|
| **URL** | `https://upos-xxx.bilivideo.com/...` | `/api/proxy/movie/{movieId}` |
| **认证** | 无需认证（第三方 URL） | Session Cookie |
| **过期** | 返回 `expire_at`，客户端主动刷新 | 返回 `expire_at`（长有效期），服务器内部刷新上游 |
| **带宽** | 第三方 CDN | SyncTV 服务器 |
| **适用** | 一般观影 | 需要权限控制/流量统计 |

**说明**：客户端不需要区分这两种方式，只需要：

1. 使用返回的 `url` 播放视频
2. 监控 `expire_at` 时间戳
3. 在到期前重新请求 `/movie/{movieId}/url` 获取新链接

---

## 3. MediaProvider 抽象设计

### 3.1 核心 Trait

> **说明**：`MediaProvider` trait 的完整定义见 [08-视频内容管理.md](./08-视频内容管理.md)。
> 本章节重点关注其中与**播放URL生成**和**代理**相关的方法。

```rust
use async_trait::async_trait;
use bytes::Bytes;
use tokio_stream::Stream;

/// 媒体源抽象（代理相关部分）
#[async_trait]
pub trait MediaProvider: Send + Sync {
    // ... 其他方法见 08-视频内容管理.md ...

    /// 生成播放 URL（根据配置返回第三方直连或代理URL）
    ///
    /// 返回的 MediaSource 中包含：
    /// - url: 播放地址（第三方直连 或 代理端点）
    /// - expire_at: 过期时间戳（客户端据此主动刷新）
    ///
    /// # 参数
    /// - ctx: Provider 上下文，包含 instance、用户信息等
    /// - media: 媒体对象，包含 source_config、instance_id 等信息
    async fn generate_url(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<MediaSource>;

    /// 代理请求（仅当生成的URL是代理端点时调用）
    ///
    /// 实现要点：
    /// - 从缓存获取第三方真实URL
    /// - 根据不同平台选择代理策略（简单转发、M3U8重写、MPD处理等）
    /// - 使用 Stream 实现零拷贝转发
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - media: 媒体对象
    /// - request: 代理请求信息（包含请求头、路径参数等）
    async fn proxy_stream(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        request: ProxyRequest,
    ) -> Result<impl Stream<Item = Result<Bytes>>>;

    /// 检查是否需要刷新缓存的第三方URL
    ///
    /// 用于代理模式下，服务器内部判断缓存的第三方URL是否快过期
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - media: 媒体对象
    async fn should_refresh_cache(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<bool> {
        Ok(false)  // 默认不需要刷新
    }
}

/// 视频 URL 响应
#[derive(Debug, Serialize)]
pub struct MediaSource {
    /// 视频 URL（可能是第三方直连或代理端点）
    pub url: String,

    /// 过期时间戳（秒，可选）
    /// - Some(timestamp): 客户端应在此时间前主动请求新链接
    /// - None: 永久有效，无需刷新
    pub expire_at: Option<i64>,

    /// 视频类型
    pub video_type: VideoType,

    /// 额外的源（不同清晰度、编码）
    pub more_sources: Vec<MoreSource>,

    /// 字幕
    pub subtitles: HashMap<String, SubtitleInfo>,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum VideoType {
    /// 普通视频
    Mp4,
    /// HLS 流
    Hls,
    /// MPEG-DASH
    Mpd,
    /// FLV
    Flv,
}
```

### 3.2 代理策略

```rust
/// 代理策略（每个提供者可以有不同的代理方式）
#[derive(Debug, Clone)]
pub enum ProxyStrategy {
    /// 简单代理：直接转发流量
    Simple {
        headers: HashMap<String, String>,
    },

    /// M3U8 代理：重写播放列表
    M3u8 {
        headers: HashMap<String, String>,
        /// 是否需要重写 segment URLs
        rewrite_segments: bool,
    },

    /// MPD 代理：DASH 流处理
    Mpd {
        headers: HashMap<String, String>,
    },

    /// 自定义代理：特殊逻辑（如 Bilibili 多清晰度切换）
    Custom {
        handler: Box<dyn CustomProxyHandler>,
    },
}

/// 自定义代理处理器
#[async_trait]
pub trait CustomProxyHandler: Send + Sync {
    async fn handle(
        &self,
        movie: &Movie,
        request: ProxyRequest,
    ) -> Result<impl Stream<Item = Result<Bytes>>>;
}
```

### 3.3 配置系统

```rust
/// 视频配置（动态配置，可运行时修改）
pub struct VideoConfig {
    /// 是否启用代理模式
    pub proxy_enabled: bool,

    /// 代理缓存大小（字节）
    pub cache_size: u64,

    /// 是否缓存代理内容
    pub enable_cache: bool,
}

// 从动态配置读取
impl VideoConfig {
    pub async fn from_settings(
        settings: &DynamicSettings,
        vendor: &str,
    ) -> Self {
        Self {
            proxy_enabled: settings
                .get_bool(&format!("proxy.enable_{}", vendor))
                .unwrap_or(false),
            cache_size: settings
                .get_number(&format!("proxy.cache_size_{}", vendor))
                .unwrap_or(1_073_741_824) as u64,  // 1GB
            enable_cache: settings
                .get_bool(&format!("proxy.enable_cache_{}", vendor))
                .unwrap_or(true),
        }
    }
}
```

---

## 4. 代理层实现

### 4.1 统一代理端点

```rust
/// 代理请求处理（统一入口）
pub async fn proxy_movie(
    Path(movie_id): Path<String>,
    Query(params): Query<ProxyParams>,
    State(state): State<AppState>,
    session: Session,  // ← 使用 Session 而非 JWT
) -> Result<Response<Body>> {
    // 1. Session 验证
    let user_id: String = session.get("user_id")
        .ok_or(Error::Unauthorized)?;

    // 2. 获取电影信息
    let movie = state.db
        .get_movie(&movie_id)
        .await?;

    // 3. 验证房间权限
    let user_in_room = state.db
        .check_user_in_room(&movie.room_id, &user_id)
        .await?;

    if !user_in_room {
        return Err(Error::Forbidden("Not in room".into()));
    }

    // 4. 获取对应的媒体提供者
    let provider = state.provider_registry
        .get(&movie.source_type)
        .ok_or(Error::ProviderNotFound)?;

    // 5. 构建代理请求
    let proxy_request = ProxyRequest {
        movie_id: movie_id.clone(),
        query_params: params.clone(),
        headers: extract_headers(&state.request),
    };

    // 6. 调用媒体提供者的代理方法
    let stream = provider.proxy_stream(&movie, proxy_request).await?;

    // 7. 返回流式响应
    Ok(Response::builder()
        .header("Content-Type", "video/mp4")
        .body(Body::from_stream(stream))?)
}

#[derive(Debug, Deserialize)]
pub struct ProxyParams {
    /// 视频类型标识（如 "raw", "hevc" 等）
    pub t: Option<String>,

    /// 字幕 ID
    pub subtitle_id: Option<i32>,
}
```

### 4.2 缓存代理流

```rust
use moka::future::Cache;

pub struct ProxyCache {
    cache: Cache<String, Arc<Vec<u8>>>,
}

impl ProxyCache {
    pub fn new(max_size: u64) -> Self {
        Self {
            cache: Cache::builder()
                .max_capacity(max_size)
                .time_to_live(Duration::from_secs(3600))  // 1小时
                .build(),
        }
    }

    /// 代理并缓存
    pub async fn proxy_with_cache<S>(
        &self,
        cache_key: &str,
        upstream_url: &str,
        headers: &HashMap<String, String>,
    ) -> Result<impl Stream<Item = Result<Bytes>>>
    where
        S: Stream<Item = Result<Bytes>>,
    {
        // 1. 尝试从缓存读取
        if let Some(cached) = self.cache.get(cache_key).await {
            return Ok(stream::iter(vec![Ok(Bytes::from((*cached).clone()))]));
        }

        // 2. 请求上游
        let client = reqwest::Client::new();
        let mut request = client.get(upstream_url);

        for (key, value) in headers {
            request = request.header(key, value);
        }

        let response = request.send().await?;
        let bytes = response.bytes().await?;

        // 3. 存入缓存
        self.cache.insert(
            cache_key.to_string(),
            Arc::new(bytes.to_vec()),
        ).await;

        // 4. 返回流
        Ok(stream::iter(vec![Ok(bytes)]))
    }
}
```

### 4.3 M3U8 特殊处理

```rust
use m3u8_rs::{Playlist, parse_playlist_res};

/// M3U8 代理（重写 segment URLs）
pub async fn proxy_m3u8(
    upstream_url: &str,
    movie_id: &str,
    room_id: &str,
    headers: &HashMap<String, String>,
) -> Result<String> {
    // 1. 获取原始 M3U8
    let client = reqwest::Client::new();
    let response = client.get(upstream_url)
        .headers(headers_to_reqwest(headers))
        .send()
        .await?;

    let m3u8_content = response.text().await?;

    // 2. 解析 M3U8
    let parsed = parse_playlist_res(m3u8_content.as_bytes())?;

    // 3. 重写 segment URLs
    let rewritten = match parsed {
        Playlist::MasterPlaylist(mut master) => {
            for variant in &mut master.variants {
                variant.uri = rewrite_segment_url(
                    &variant.uri,
                    movie_id,
                    room_id,
                );
            }
            master.to_string()
        }
        Playlist::MediaPlaylist(mut media) => {
            for segment in &mut media.segments {
                segment.uri = rewrite_segment_url(
                    &segment.uri,
                    movie_id,
                    room_id,
                );
            }
            media.to_string()
        }
    };

    Ok(rewritten)
}

/// 重写 segment URL
fn rewrite_segment_url(
    original_url: &str,
    movie_id: &str,
    room_id: &str,
) -> String {
    // 编码原始 URL
    let encoded = base64::encode_config(original_url, base64::URL_SAFE_NO_PAD);

    // 生成代理 URL
    format!(
        "/api/proxy/movie/{}/segment/{}?roomId={}",
        movie_id,
        encoded,
        room_id
    )
}
```

---

## 5. 过期机制

### 5.1 客户端主动刷新

**设计原则**：

- 服务器在 `MediaSource` 中返回 `expire_at` 时间戳
- 客户端监控过期时间，在到期前主动请求新链接
- 对用户无感知，无需刷新页面

```rust
/// URL 缓存管理器（服务器端）
pub struct UrlCacheManager {
    /// 缓存第三方真实URL（用于代理模式）
    cache: Arc<DashMap<String, CachedUrl>>,

    /// Redis 用于跨副本共享
    redis: RedisPool,
}

#[derive(Debug, Clone)]
struct CachedUrl {
    url: String,
    created_at: Instant,
    expires_at: Instant,
}

impl UrlCacheManager {
    /// 获取或刷新缓存的URL
    pub async fn get_or_refresh(
        &self,
        movie: &Movie,
        provider: &Arc<dyn MediaProvider>,
        user: &User,
        room: &Room,
        config: &VideoConfig,
    ) -> Result<CachedUrl> {
        let cache_key = format!("url:{}:{}", movie.source_type, movie.id);

        // 1. 检查本地缓存
        if let Some(cached) = self.cache.get(&cache_key) {
            // 如果还有5分钟以上有效期，直接返回
            if cached.expires_at.duration_since(Instant::now()) > Duration::from_secs(300) {
                return Ok(cached.clone());
            }
        }

        // 2. 刷新URL（调用第三方API）
        let url_response = self.fetch_fresh_url(movie, provider, user, room, config).await?;

        // 计算过期时间
        let expire_duration = if let Some(expire_at) = url_response.expire_at {
            let now = Utc::now().timestamp();
            Duration::from_secs((expire_at - now).max(0) as u64)
        } else {
            Duration::from_secs(3600)  // 默认1小时
        };

        let cached = CachedUrl {
            url: url_response.url,
            created_at: Instant::now(),
            expires_at: Instant::now() + expire_duration,
        };

        // 3. 更新缓存
        self.cache.insert(cache_key.clone(), cached.clone());

        // 4. 同步到 Redis（跨副本共享）
        self.sync_to_redis(&cache_key, &cached).await?;

        Ok(cached)
    }

    /// 从第三方获取新URL
    async fn fetch_fresh_url(
        &self,
        movie: &Movie,
        provider: &Arc<dyn MediaProvider>,
        user: &User,
        room: &Room,
        config: &VideoConfig,
    ) -> Result<MediaSource> {
        // 调用媒体提供者的 generate_url 方法
        provider.generate_url(movie, user, room, config).await
    }
}
```

### 5.2 服务器端点实现

```rust
/// 获取视频播放 URL
pub async fn get_movie_url(
    Path((room_id, movie_id)): Path<(String, String)>,
    State(state): State<AppState>,
    session: Session,
) -> Result<Json<MediaSource>> {
    // 1. 验证用户权限
    let user_id: String = session.get("user_id")
        .ok_or(Error::Unauthorized)?;

    let user = state.db.get_user(&user_id).await?;
    let room = state.db.get_room(&room_id).await?;

    // 检查用户是否在房间
    if !state.db.check_user_in_room(&room_id, &user_id).await? {
        return Err(Error::Forbidden("Not in room".into()));
    }

    // 2. 获取电影信息
    let movie = state.db.get_movie(&movie_id).await?;

    // 3. 获取对应的媒体提供者
    let provider = state.provider_registry
        .get(&movie.source_type)
        .ok_or(Error::ProviderNotFound)?;

    // 4. 读取动态配置
    let config = VideoConfig::from_settings(
        &state.settings,
        &movie.source_type,
    ).await;

    // 5. 生成 URL（媒体提供者内部决定返回第三方直连还是代理）
    let url_response = provider.generate_url(&movie, &user, &room, &config).await?;

    Ok(Json(url_response))
}
```

---

## 6. 实现示例

### 6.1 Bilibili 媒体源

```rust
pub struct BilibiliProvider {
    client: BilibiliClient,
    cache: Arc<ProxyCache>,
    url_cache: Arc<UrlCacheManager>,
}

#[async_trait]
impl MediaProvider for BilibiliProvider {
    fn name(&self) -> &'static str {
        "bilibili"
    }

    fn can_handle(&self, url: &str) -> bool {
        url.contains("bilibili.com") || url.contains("b23.tv")
    }
    async fn generate_url(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<MediaSource> {
        // 从上下文获取配置信息
        let proxy_enabled = ctx.metadata.get("proxy_enabled")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if proxy_enabled {
            // 代理模式
            self.generate_proxy_url(ctx, media).await
        } else {
            // 直连模式
            self.generate_direct_url(ctx, media).await
        }
    }

    async fn proxy_stream(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        request: ProxyRequest,
    ) -> Result<impl Stream<Item = Result<Bytes>>> {
        // 1. 从缓存获取真实 URL
        let real_url = self.get_or_refresh_url(ctx, media).await?;

        // 2. 根据请求类型选择代理策略
        match request.query_params.t.as_deref() {
            Some("hevc") => {
                // HEVC 编码的 URL
                let bvid = media.source_config.get("bvid")
                    .and_then(|v| v.as_str())
                    .ok_or(Error::InvalidConfig)?;
                let hevc_url = self.client.get_hevc_url(bvid).await?;
                self.simple_proxy(&hevc_url, &request.headers).await
            }
            _ => {
                // 默认 URL
                self.simple_proxy(&real_url, &request.headers).await
            }
        }
    }

    async fn should_refresh_cache(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<bool> {
        // 检查缓存的 Bilibili URL 是否快过期
        if let Some(cached) = self.get_cached_url(&media.id).await {
            let age = cached.created_at.elapsed();
            Ok(age > Duration::from_secs(3300))  // 提前 5 分钟刷新
        } else {
            Ok(true)
        }
    }
}

impl BilibiliProvider {
    /// 生成第三方直连 URL
    async fn generate_direct_url(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<MediaSource> {
        // 从 source_config 获取 bvid
        let bvid = media.source_config.get("bvid")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 获取用户凭证
        let credential = ctx.get_credential().await?;

        // 调用 Bilibili API 获取真实播放 URL
        let play_url = self.client
            .get_play_url(bvid, credential.as_ref())
            .await?;

        let now = Utc::now().timestamp();

        Ok(MediaSource {
            url: play_url,
            expire_at: Some(now + 3600),  // 1小时后过期
            video_type: VideoType::Mpd,
            more_sources: vec![
                MoreSource {
                    name: "HEVC".into(),
                    url: self.client.get_hevc_url(bvid).await?,
                    video_type: VideoType::Mpd,
                },
            ],
            subtitles: HashMap::new(),
        })
    }

    /// 生成代理 URL
    async fn generate_proxy_url(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<MediaSource> {
        // 预先缓存第三方URL到服务器
        let _ = self.url_cache.get_or_refresh(ctx, media, self).await?;

        Ok(MediaSource {
            url: format!("/api/proxy/media/{}", media.id),
            expire_at: None,  // 代理模式：服务器内部自动刷新上游，客户端无需关心
            video_type: VideoType::Mpd,
            more_sources: vec![
                MoreSource {
                    name: "HEVC".into(),
                    url: format!("/api/proxy/media/{}?t=hevc", media.id),
                    video_type: VideoType::Mpd,
                },
            ],
            subtitles: HashMap::new(),
        })
    }

    /// 简单代理（零拷贝转发）
    async fn simple_proxy(
        &self,
        url: &str,
        headers: &HashMap<String, String>,
    ) -> Result<impl Stream<Item = Result<Bytes>>> {
        let client = reqwest::Client::new();
        let mut request = client.get(url);

        for (key, value) in headers {
            request = request.header(key, value);
        }

        let response = request.send().await?;
        Ok(response.bytes_stream().map(|r| r.map_err(Into::into)))
    }
}
```

### 6.2 Alist 媒体源

```rust
pub struct AlistProvider {
    client: AlistClient,
    cache: Arc<ProxyCache>,
    url_cache: Arc<UrlCacheManager>,
}

#[async_trait]
impl MediaProvider for AlistProvider {
    fn name(&self) -> &'static str {
        "alist"
    }

    fn can_handle(&self, url: &str) -> bool {
        // 根据配置的 Alist 服务器地址判断
        url.starts_with(&self.client.base_url)
    }
    async fn generate_url(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
    ) -> Result<MediaSource> {
        // 从上下文获取配置信息
        let proxy_enabled = ctx.metadata.get("proxy_enabled")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        if proxy_enabled {
            self.generate_proxy_url(ctx, media).await
        } else {
            self.generate_direct_url(ctx, media).await
        }
    }

    async fn proxy_stream(
        &self,
        ctx: &ProviderContext<'_>,
        media: &Media,
        request: ProxyRequest,
    ) -> Result<impl Stream<Item = Result<Bytes>>> {
        // 1. 从 ctx.instance 获取实例配置
        let instance = ctx.instance.ok_or(Error::MissingInstance)?;
        let instance_config: AlistInstanceConfig = serde_json::from_value(instance.config.clone())?;

        // 2. 从 media.source_config 获取 Alist 路径
        let alist_path = media.source_config.get("path")
            .and_then(|v| v.as_str())
            .ok_or(Error::InvalidConfig)?;

        // 3. 获取用户凭证
        let credential = ctx.get_credential().await?;

        // 4. 获取 Alist 文件信息
        let file_info = self.client
            .get_file_info(&instance_config.host, alist_path, credential.as_ref())
            .await?;

        // 3. 根据提供商选择代理策略
        match file_info.provider.as_str() {
            "AliyundriveOpen" => {
                // Ali 云盘：M3U8 代理
                let m3u8_url = self.get_ali_m3u8_url(&file_info).await?;
                self.proxy_m3u8(&m3u8_url, movie, request).await
            }
            "115 Cloud" => {
                // 115 云盘：简单代理
                let direct_url = self.get_115_url(&file_info).await?;
                self.simple_proxy(&direct_url, &HashMap::new()).await
            }
            _ => {
                // 默认：简单代理
                let url = self.get_alist_direct_url(&file_info).await?;
                self.simple_proxy(&url, &HashMap::new()).await
            }
        }
    }

    async fn should_refresh_cache(&self, ctx: &ProviderContext<'_>, media: &Media) -> Result<bool> {
        if let Some(cached) = self.get_cached_url(&media.id).await {
            Ok(cached.created_at.elapsed() > Duration::from_secs(1500))  // 提前5分钟刷新
        } else {
            Ok(true)
        }
    }
}

impl AlistProvider {
    /// Ali 云盘 M3U8 代理
    async fn proxy_m3u8(
        &self,
        m3u8_url: &str,
        movie: &Movie,
        request: ProxyRequest,
    ) -> Result<impl Stream<Item = Result<Bytes>>> {
        // 重写 M3U8 playlist
        let rewritten = proxy_m3u8(
            m3u8_url,
            &movie.id,
            &movie.room_id,
            &HashMap::new(),
        ).await?;

        Ok(stream::iter(vec![Ok(Bytes::from(rewritten))]))
    }
}
```

---

## 总结

### Rust 版本的优势

✅ **类型安全**：使用 trait 和 enum 统一抽象，编译时检查
✅ **零拷贝代理**：使用 `Stream` 高效转发，无需缓冲整个文件
✅ **智能缓存**：服务器自动刷新第三方 URL，客户端主动监控过期时间
✅ **Session 认证**：代理不需要 JWT，减少带宽
✅ **客户端主动刷新**：客户端根据 `expire_at` 主动请求新链接，简单高效
✅ **灵活配置**：通过动态配置控制代理模式，无需重启

### 与 Go 版本对比

| 特性 | Go 版本 | Rust 版本 |
|------|---------|----------|
| **过期检测** | 客户端通过 WebSocket 轮询 ExpireID | 客户端根据 `expire_at` 主动刷新 |
| **代理认证** | JWT Token | Session Cookie |
| **抽象设计** | 分散在各个 vendor 文件 | 统一的 `MediaProvider` trait |
| **M3U8 处理** | 每个 segment 生成 JWT | 使用 base64 编码 URL |
| **缓存策略** | 手动实现 | 使用 `moka` 自动 TTL |
| **类型安全** | 运行时检查 | 编译时保证 |
| **客户端接口** | 区分直连/代理模式 | 统一接口，客户端无需区分 |

**上一章**: [09-媒体源提供商配置管理](./09-媒体源提供商配置管理.md)
**下一章**: [11-实时互动](./13-自动连播设计.md)
