# 07. 实时互动

---

> **设计说明**: 本章整合了聊天系统和弹幕系统的最终设计方案（第15章修正内容）

## 7.1 聊天系统

### 7.1.1 设计目标

- ✅ **持久化存储**（PostgreSQL）
- ✅ **仅保留最近500条**（数据库触发器自动清理）
- ✅ **提供历史查询接口**
- ✅ **实时广播**（gRPC bidirectional streaming + Redis Pub/Sub）
- ✅ **WebSocket 兼容**（可选，用于不支持 gRPC 的旧客户端）
- ✅ **支持消息删除**（管理员或发送者）

### 7.1.2 数据模型

```rust
// model/chat.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub id: String,              // nanoid
    pub room_id: String,         // nanoid
    pub user_id: String,         // nanoid
    pub username: String,
    pub content: String,
    pub message_type: String,    // text|system
    pub created_at: DateTime<Utc>,

    /// 内部 UUID（仅用于数据库操作，不序列化到 API）
    #[serde(skip)]
    pub user_uuid: Uuid,
}

#[derive(Debug, Deserialize)]
pub struct SendMessageRequest {
    pub content: String,
}
```

### 7.1.3 数据库表

> **注意**: `chat_messages` 表的完整 DDL 定义见 [04-数据库设计.md § 2.7](./04-数据库设计.md)

**表结构摘要**：

- **主键**: `id` (UUID)
- **关联**: `room_id`, `user_id`
- **内容**: `username`, `content`, `type`
- **自动清理**: 触发器保留每个房间最近 500 条消息
- **索引**: `(room_id, created_at DESC)`, `(user_id)`

### 7.1.4 聊天服务

```rust
// service/chat_service.rs
pub struct ChatService {
    chat_repo: Arc<ChatRepository>,
    cluster_sync: Arc<ClusterSync>,
    rate_limiter: Arc<RateLimiter>,
    filter: Arc<ContentFilter>,
    user_repo: Arc<UserRepository>,
    room_service: Arc<RoomService>,
}

impl ChatService {
    /// 发送聊天消息
    pub async fn send_message(
        &self,
        room_id: &str,      // nanoid string
        user_id: &str,      // nanoid string
        content: String,
    ) -> Result<ChatMessage> {
        // 内部转换 nanoid 到 UUID
        let user_uuid = id_mapper.nanoid_to_uuid(user_id)?;
        // 1. 权限检查
        self.room_service.check_permission(
            room_id,
            user_id,
            Permission::SEND_CHAT_MESSAGE,
        ).await?;

        // 2. 限流（10条/秒）
        let rate_key = format!("chat:rate:{}:{}", room_id, user_id);
        if !self.rate_limiter.check(&rate_key, 10, Duration::from_secs(1)).await? {
            return Err(Error::TooManyRequests {
                retry_after: 1,
            });
        }

        // 3. 内容验证
        if content.is_empty() || content.len() > 500 {
            return Err(Error::InvalidInput {
                field: "content",
                message: "消息内容必须在1-500字符之间",
            });
        }

        // 4. 内容过滤
        let filtered_content = self.filter.filter(&content).await?;

        // 5. 获取用户信息
        let user = self.user_repo.get(user_uuid).await?
            .ok_or(Error::UserNotFound(user_uuid))?;

        // 6. 生成消息 ID
        let message_uuid = Uuid::new_v4();
        let message_nanoid = id_mapper.generate_nanoid_for_uuid(message_uuid).await?;

        // 7. 创建消息
        let message = ChatMessage {
            id: message_nanoid.clone(),
            room_id: room_id.to_string(),
            user_id: user_id.to_string(),
            username: user.username.clone(),
            content: filtered_content,
            message_type: "text".to_string(),
            created_at: Utc::now(),
            user_uuid,
        };

        // 8. 持久化（会自动触发清理旧消息，保留最近500条）
        self.chat_repo.create(&message).await?;

        // 9. 实时广播
        self.cluster_sync.publish(ClusterEvent::ChatMessage {
            room_id: room_id.to_string(),
            user_id: user_id.to_string(),
            username: message.username.clone(),
            message: message.content.clone(),
            timestamp: message.created_at.timestamp_millis(),
        }).await?;

        tracing::info!(
            room_id = room_id,
            user_id = user_id,
            message_id = %message.id,
            "Chat message sent"
        );

        Ok(message)
    }

    /// 获取聊天历史（最近500条内）
    pub async fn get_history(
        &self,
        room_id: &str,      // nanoid string
        before: Option<DateTime<Utc>>,
        limit: u32,
    ) -> Result<Vec<ChatMessage>> {
        // 限制每次最多返回100条
        let limit = limit.min(100);

        self.chat_repo.list_by_room(room_id, before, limit).await
    }

    /// 删除消息（仅管理员或消息发送者）
    pub async fn delete_message(
        &self,
        room_id: &str,      // nanoid string
        message_id: String,  // nanoid
        operator_id: &str,  // nanoid string
    ) -> Result<()> {
        // 获取消息
        let message = self.chat_repo.get(&message_id).await?
            .ok_or(Error::MessageNotFound)?;

        // 权限检查：管理员或消息发送者
        if message.user_id != operator_id {
            self.room_service.check_permission(
                room_id,
                operator_id,
                Permission::DELETE_MESSAGE,
            ).await?;
        }

        // 删除
        self.chat_repo.delete(&message_id).await?;

        // 通知其他用户
        self.cluster_sync.publish(ClusterEvent::ChatMessageDeleted {
            room_id: room_id.to_string(),
            message_id,
            operator_id: operator_id.to_string(),
        }).await?;

        Ok(())
    }
}
```

### 7.1.5 聊天 Repository

```rust
// repository/chat_repository.rs
pub struct ChatRepository {
    pool: Arc<PgPool>,
}

impl ChatRepository {
    pub async fn create(&self, message: &ChatMessage) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO chat_messages (id, room_id, user_id, username, content, type, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            "#,
            message.id,
            message.room_id,
            message.user_id,
            message.username,
            message.content,
            message.message_type,
            message.created_at,
        )
        .execute(&*self.pool)
        .await?;

        Ok(())
    }

    pub async fn list_by_room(
        &self,
        room_id: &str,      // nanoid string
        before: Option<DateTime<Utc>>,
        limit: u32,
    ) -> Result<Vec<ChatMessage>> {
        let messages = if let Some(before_time) = before {
            sqlx::query_as!(
                ChatMessage,
                r#"
                SELECT id, room_id, user_id, username, content, type as message_type, created_at
                FROM chat_messages
                WHERE room_id = $1 AND created_at < $2
                ORDER BY created_at DESC
                LIMIT $3
                "#,
                room_id,
                before_time,
                limit as i64
            )
            .fetch_all(&*self.pool)
            .await?
        } else {
            sqlx::query_as!(
                ChatMessage,
                r#"
                SELECT id, room_id, user_id, username, content, type as message_type, created_at
                FROM chat_messages
                WHERE room_id = $1
                ORDER BY created_at DESC
                LIMIT $2
                "#,
                room_id,
                limit as i64
            )
            .fetch_all(&*self.pool)
            .await?
        };

        Ok(messages)
    }

    pub async fn delete(&self, message_id: &str) -> Result<()> {
        sqlx::query!(
            "DELETE FROM chat_messages WHERE id = $1",
            message_id
        )
        .execute(&*self.pool)
        .await?;

        Ok(())
    }
}
```

## 7.2 弹幕系统（纯内存实现）

### 7.2.1 设计目标

- ✅ **不持久化存储**（无数据库表）
- ✅ **仅实时广播**（gRPC bidirectional streaming + Redis Pub/Sub）
- ✅ **WebSocket 兼容**（可选，用于不支持 gRPC 的旧客户端）
- ✅ **内存缓存最近10秒弹幕**（最多100条）
- ✅ **支持新用户快速同步**
- ✅ **支持外部弹幕源**（Bilibili直播弹幕转发）
- ❌ **不提供历史弹幕查询**
- ❌ **不支持弹幕删除**（无持久化数据）

### 7.2.2 数据模型

```rust
// model/danmaku.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Danmaku {
    pub id: String,              // nanoid
    pub room_id: String,         // nanoid
    pub user_id: String,         // nanoid
    pub username: String,

    pub content: String,         // 弹幕内容
    pub color: String,           // 颜色（HEX，如 #FFFFFF）
    pub position: DanmakuPosition,
    pub font_size: u8,           // 字体大小 18-36

    pub video_time: f64,         // 出现在视频的哪个时间点（秒）
    pub send_time: i64,          // 发送时间戳（毫秒）

    pub source: DanmakuSource,

    /// 内部 UUID（仅用于数据库操作，不序列化到 API）
    #[serde(skip)]
    pub user_uuid: Option<Uuid>,  // 外部来源的弹幕可能没有 UUID
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DanmakuPosition {
    Scroll,      // 滚动弹幕
    Top,         // 顶部固定
    Bottom,      // 底部固定
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum DanmakuSource {
    User,                                    // 用户发送
    Bilibili { room_id: u64 },               // Bilibili 直播弹幕
    Platform { name: String },               // 其他平台
}

#[derive(Debug, Deserialize)]
pub struct SendDanmakuRequest {
    pub content: String,
    pub video_time: f64,
    pub position: Option<DanmakuPosition>,
    pub color: Option<String>,
    pub font_size: Option<u8>,
}
```

### 7.2.3 弹幕内存缓存

```rust
// danmaku/cache.rs
use std::collections::VecDeque;
use dashmap::DashMap;

/// 弹幕内存缓存（用于新用户加入时快速同步）
pub struct DanmakuCache {
    cache: Arc<DashMap<String, RwLock<VecDeque<Danmaku>>>>,  // room_id (nanoid) -> 弹幕队列
    max_duration: Duration,  // 最多缓存10秒的弹幕
}

impl DanmakuCache {
    pub fn new() -> Self {
        Self {
            cache: Arc::new(DashMap::new()),
            max_duration: Duration::from_secs(10),
        }
    }

    /// 添加弹幕到缓存
    pub async fn add(&self, room_id: &str, danmaku: Danmaku) {
        let queue = self.cache
            .entry(room_id.to_string())
            .or_insert_with(|| RwLock::new(VecDeque::new()));

        let mut queue = queue.write().await;
        queue.push_back(danmaku);

        // 清理过期弹幕（超过10秒）
        let now = Utc::now().timestamp_millis();
        let cutoff = now - self.max_duration.as_millis() as i64;

        while let Some(front) = queue.front() {
            if front.send_time < cutoff {
                queue.pop_front();
            } else {
                break;
            }
        }

        // 限制队列大小（最多100条）
        while queue.len() > 100 {
            queue.pop_front();
        }
    }

    /// 获取最近的弹幕（用于新用户加入）
    pub async fn get_recent(&self, room_id: &str) -> Vec<Danmaku> {
        if let Some(queue) = self.cache.get(room_id) {
            let queue = queue.read().await;
            queue.iter().cloned().collect()
        } else {
            Vec::new()
        }
    }

    /// 清空房间缓存
    pub fn clear(&self, room_id: &str) {
        self.cache.remove(room_id);
    }

    /// 获取缓存统计
    pub async fn stats(&self, room_id: &str) -> (usize, Option<i64>) {
        if let Some(queue) = self.cache.get(room_id) {
            let queue = queue.read().await;
            let count = queue.len();
            let oldest = queue.front().map(|d| d.send_time);
            (count, oldest)
        } else {
            (0, None)
        }
    }
}
```

### 7.2.4 弹幕服务

```rust
// service/danmaku_service.rs
pub struct DanmakuService {
    danmaku_cache: Arc<DanmakuCache>,    // 仅内存缓存
    cluster_sync: Arc<ClusterSync>,
    rate_limiter: Arc<RateLimiter>,
    filter: Arc<ContentFilter>,
    user_repo: Arc<UserRepository>,
    room_service: Arc<RoomService>,
}

impl DanmakuService {
    /// 发送弹幕（仅实时广播，不持久化）
    pub async fn send_danmaku(
        &self,
        room_id: &str,      // nanoid string
        user_id: &str,      // nanoid string
        danmaku: SendDanmakuRequest,
    ) -> Result<Danmaku> {
        // 内部转换 nanoid 到 UUID
        let user_uuid = id_mapper.nanoid_to_uuid(user_id)?;
        // Step 1: 检查权限
        self.room_service.check_permission(
            room_id,
            user_id,
            Permission::SEND_CHAT_MESSAGE,
        ).await?;

        // Step 2: 限流检查（每用户每秒最多 3 条弹幕）
        let rate_key = format!("danmaku:rate:{}:{}", room_id, user_id);
        if !self.rate_limiter.check(&rate_key, 3, Duration::from_secs(1)).await? {
            return Err(Error::TooManyRequests {
                retry_after: 1,
            });
        }

        // Step 3: 内容验证
        if danmaku.content.is_empty() || danmaku.content.len() > 100 {
            return Err(Error::InvalidInput {
                field: "content",
                message: "弹幕内容必须在1-100字符之间",
            });
        }

        // Step 4: 内容过滤
        let filtered_content = self.filter.filter(&danmaku.content).await?;

        // Step 5: 获取用户信息
        let user = self.user_repo.get(user_uuid).await?
            .ok_or(Error::UserNotFound(user_uuid))?;

        // Step 6: 生成弹幕 ID
        let danmaku_uuid = Uuid::new_v4();
        let danmaku_nanoid = id_mapper.generate_nanoid_for_uuid(danmaku_uuid).await?;

        // Step 7: 创建弹幕对象
        let danmaku_obj = Danmaku {
            id: danmaku_nanoid.clone(),
            room_id: room_id.to_string(),
            user_id: user_id.to_string(),
            username: user.username,
            content: filtered_content,
            color: danmaku.color
                .unwrap_or_else(|| "#FFFFFF".to_string()),
            position: danmaku.position
                .unwrap_or(DanmakuPosition::Scroll),
            font_size: danmaku.font_size
                .unwrap_or(25)
                .clamp(18, 36),
            video_time: danmaku.video_time.max(0.0),
            send_time: Utc::now().timestamp_millis(),
            source: DanmakuSource::User,
            user_uuid: Some(user_uuid),
        };

        // Step 8: 添加到内存缓存（可选）
        self.danmaku_cache.add(room_id, danmaku_obj.clone()).await;

        // Step 9: 实时广播到房间（通过 gRPC bidirectional streaming）
        //         客户端通过 MessageStream RPC 接收实时消息
        self.cluster_sync.publish(ClusterEvent::DanmakuSent {
            room_id: room_id.to_string(),
            danmaku: danmaku_obj.clone(),
        }).await?;

        tracing::info!(
            room_id = room_id,
            user_id = user_id,
            danmaku_id = %danmaku_obj.id,
            "Danmaku sent"
        );

        Ok(danmaku_obj)
    }

    /// 获取最近弹幕（仅用于新用户加入时同步）
    pub async fn get_recent_danmaku(&self, room_id: &str) -> Vec<Danmaku> {
        self.danmaku_cache.get_recent(room_id).await
    }

    /// 连接到外部弹幕源（如 Bilibili 直播）
    pub async fn connect_external_danmaku(
        &self,
        room_id: &str,      // nanoid string
        source: DanmakuSourceConfig,
    ) -> Result<()> {
        match source {
            DanmakuSourceConfig::Bilibili { live_room_id } => {
                self.start_bilibili_danmaku_stream(room_id, live_room_id).await?;
            }
        }

        Ok(())
    }

    /// 启动 Bilibili 弹幕流（仅实时转发）
    async fn start_bilibili_danmaku_stream(
        &self,
        room_id: &str,      // nanoid string
        bilibili_room_id: u64,
    ) -> Result<()> {
        let room_id = room_id.to_string();
        let cluster_sync = self.cluster_sync.clone();
        let danmaku_cache = self.danmaku_cache.clone();

        tokio::spawn(async move {
            let mut client = BilibiliDanmakuClient::new(bilibili_room_id);

            if let Err(e) = client.connect().await {
                error!(
                    room_id = room_id,
                    bilibili_room_id = bilibili_room_id,
                    error = ?e,
                    "Failed to connect to Bilibili danmaku"
                );
                return;
            }

            info!(
                room_id = room_id,
                bilibili_room_id = bilibili_room_id,
                "Connected to Bilibili danmaku stream"
            );

            while let Some(danmaku_text) = client.recv().await {
                let danmaku = Danmaku {
                    id: Uuid::new_v4().to_string(),
                    room_id: room_id.clone(),
                    user_id: Uuid::nil(),  // 外部弹幕使用nil UUID
                    username: "Bilibili用户".to_string(),
                    content: danmaku_text,
                    color: "#FFFFFF".to_string(),
                    position: DanmakuPosition::Scroll,
                    font_size: 25,
                    video_time: 0.0,  // 直播弹幕无视频时间
                    send_time: Utc::now().timestamp_millis(),
                    source: DanmakuSource::Bilibili { room_id: bilibili_room_id },
                };

                // 添加到内存缓存
                danmaku_cache.add(&room_id, danmaku.clone()).await;

                // 实时广播
                if let Err(e) = cluster_sync.publish(ClusterEvent::DanmakuSent {
                    room_id,
                    danmaku,
                }).await {
                    error!(error = ?e, "Failed to broadcast Bilibili danmaku");
                }
            }

            warn!(
                room_id = room_id,
                bilibili_room_id = bilibili_room_id,
                "Bilibili danmaku stream ended"
            );
        });

        Ok(())
    }
}
```

## 7.3 Bilibili 弹幕对接

### 7.3.1 Bilibili 弹幕客户端

```rust
// danmaku/bilibili_client.rs
use tokio_tungstenite::{connect_async, tungstenite::Message};
use flate2::read::ZlibDecoder;
use brotli::Decompressor;

pub struct BilibiliDanmakuClient {
    room_id: u64,
    ws: Option<WebSocketStream<TcpStream>>,
}

impl BilibiliDanmakuClient {
    pub fn new(room_id: u64) -> Self {
        Self {
            room_id,
            ws: None,
        }
    }

    /// 连接到 Bilibili 弹幕服务器
    pub async fn connect(&mut self) -> Result<()> {
        // Step 1: 获取真实房间ID和Token
        let (real_room_id, token) = self.get_room_info().await?;

        // Step 2: 连接 WebSocket
        let url = "wss://broadcastlv.chat.bilibili.com/sub";
        let (ws, _) = connect_async(url).await?;
        self.ws = Some(ws);

        // Step 3: 发送认证消息
        self.send_auth(real_room_id, &token).await?;

        // Step 4: 启动心跳
        self.start_heartbeat();

        Ok(())
    }

    /// 接收弹幕
    pub async fn recv(&mut self) -> Option<String> {
        let ws = self.ws.as_mut()?;

        loop {
            match ws.next().await {
                Some(Ok(Message::Binary(data))) => {
                    if let Some(danmaku) = self.parse_message(&data) {
                        return Some(danmaku);
                    }
                }
                Some(Err(e)) => {
                    tracing::error!(error = ?e, "WebSocket error");
                    return None;
                }
                None => return None,
                _ => {}
            }
        }
    }

    /// 解析消息
    fn parse_message(&self, data: &[u8]) -> Option<String> {
        if data.len() < 16 {
            return None;
        }

        // 解析 header
        let header_len = u16::from_be_bytes([data[4], data[5]]) as usize;
        let version = u16::from_be_bytes([data[6], data[7]]);
        let command = u32::from_be_bytes([data[8], data[9], data[10], data[11]]);

        // 只处理普通消息
        if command != 5 {  // CMD_NORMAL
            return None;
        }

        let body = &data[header_len..];

        // 根据版本解压
        let decompressed = match version {
            0 | 1 => body.to_vec(),  // 无压缩
            2 => self.decompress_zlib(body).ok()?,  // zlib
            3 => self.decompress_brotli(body).ok()?,  // brotli
            _ => return None,
        };

        // 解析 JSON
        let msg: serde_json::Value = serde_json::from_slice(&decompressed).ok()?;

        // 提取弹幕
        if msg["cmd"] == "DANMU_MSG" {
            let info = msg["info"].as_array()?;
            let content = info.get(1)?.as_str()?;
            return Some(content.to_string());
        }

        None
    }

    /// zlib 解压
    fn decompress_zlib(&self, data: &[u8]) -> Result<Vec<u8>> {
        use std::io::Read;

        let mut decoder = ZlibDecoder::new(data);
        let mut result = Vec::new();
        decoder.read_to_end(&mut result)?;

        Ok(result)
    }

    /// brotli 解压
    fn decompress_brotli(&self, data: &[u8]) -> Result<Vec<u8>> {
        use std::io::Read;

        let mut decoder = Decompressor::new(data, 4096);
        let mut result = Vec::new();
        decoder.read_to_end(&mut result)?;

        Ok(result)
    }

    /// 启动心跳
    fn start_heartbeat(&self) {
        let ws = self.ws.clone();

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(30));

            loop {
                interval.tick().await;

                let heartbeat = vec![0u8; 16];  // 空包，CMD_HEARTBEAT = 2

                if let Some(mut ws) = ws {
                    if ws.send(Message::Binary(heartbeat)).await.is_err() {
                        break;
                    }
                }
            }
        });
    }
}
```

## 7.4 内容过滤与限流

### 7.4.1 内容过滤器

```rust
// utils/content_filter.rs
pub struct ContentFilter {
    sensitive_words: Arc<RwLock<HashSet<String>>>,
    regex_patterns: Arc<RwLock<Vec<Regex>>>,
}

impl ContentFilter {
    /// 过滤内容
    pub async fn filter(&self, content: &str) -> Result<String> {
        let mut filtered = content.to_string();

        // Step 1: 敏感词过滤
        let sensitive_words = self.sensitive_words.read().await;
        for word in sensitive_words.iter() {
            filtered = filtered.replace(word, &"*".repeat(word.len()));
        }

        // Step 2: 正则过滤
        let patterns = self.regex_patterns.read().await;
        for pattern in patterns.iter() {
            if pattern.is_match(&filtered) {
                return Err(Error::ContentBlocked);
            }
        }

        // Step 3: 长度检查
        if filtered.len() > 100 {
            filtered.truncate(100);
        }

        Ok(filtered)
    }

    /// 加载敏感词库
    pub async fn load_sensitive_words(&self) -> Result<()> {
        let words = self.db.load_sensitive_words().await?;

        let mut store = self.sensitive_words.write().await;
        *store = words.into_iter().collect();

        Ok(())
    }
}
```

### 7.4.2 限流器

```rust
// utils/rate_limiter.rs
use governor::{Quota, RateLimiter as GovernorRateLimiter};
use std::num::NonZeroU32;

pub struct RateLimiter {
    redis: deadpool_redis::Pool,
}

impl RateLimiter {
    /// 检查限流
    pub async fn check(
        &self,
        key: &str,
        max_requests: u32,
        window: Duration,
    ) -> Result<bool> {
        let mut conn = self.redis.get().await?;

        // 使用 Redis 的 INCR + EXPIRE 实现滑动窗口
        let count: u32 = redis::cmd("INCR")
            .arg(key)
            .query_async(&mut conn)
            .await?;

        if count == 1 {
            // 第一次请求，设置过期时间
            redis::cmd("EXPIRE")
                .arg(key)
                .arg(window.as_secs() as usize)
                .query_async(&mut conn)
                .await?;
        }

        Ok(count <= max_requests)
    }
}
```

## 7.5 总结

### 聊天系统特点

- ✅ **持久化存储**（PostgreSQL）
- ✅ **自动清理**（触发器保留最近500条）
- ✅ **历史查询**（分页支持）
- ✅ **实时广播**（gRPC bidirectional streaming + Redis Pub/Sub）
- ✅ **消息删除**（权限控制）

### 弹幕系统特点

- ✅ **零数据库开销**（纯内存）
- ✅ **10秒缓存窗口**（最多100条）
- ✅ **新用户快速同步**
- ✅ **外部源支持**（Bilibili直播）
- ✅ **实时广播**（gRPC bidirectional streaming + Redis Pub/Sub）
- ❌ **无历史查询**
- ❌ **无删除功能**

### 性能对比

| 特性 | 聊天系统 | 弹幕系统 |
|------|---------|---------|
| 持久化 | ✅ PostgreSQL | ❌ 无 |
| 缓存策略 | 数据库（500条） | 内存（10秒/100条） |
| 历史查询 | ✅ 支持 | ❌ 不支持 |
| 删除功能 | ✅ 支持 | ❌ 不支持 |
| 限流策略 | 10条/秒 | 3条/秒 |
| 内容长度 | 1-500字符 | 1-100字符 |
| 适用场景 | 重要讨论 | 实时互动 |

---

**上一章**: [10-视频链接过期与代理机制](./08-视频内容管理.md)
**下一章**: [12-时间同步与补偿](./14-通信架构设计.md)
