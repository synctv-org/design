# 23. 自动连播设计

---

## 目录

- [1. 功能需求](#1-功能需求)
- [2. 架构设计](#2-架构设计)
- [3. 播放模式](#3-播放模式)
- [4. 实现方案](#4-实现方案)
- [5. 边界情况处理](#5-边界情况处理)
- [6. 目录支持](#6-目录支持)

---

## 1. 功能需求

### 1.1 基本需求

- **自动播放下一个**: 当前视频播放完毕后自动播放下一个
- **播放模式**: 支持顺序播放、单曲循环、列表循环、随机播放
- **用户体验**: 无缝切换,无黑屏
- **房间级配置**: 自动连播是**房间设置**,由拥有 `SET_ROOM_SETTINGS` 权限的用户配置
- **多副本同步**: 自动连播状态在所有副本间同步

### 1.2 用户场景

| 场景 | 行为 | 预期 |
|------|------|------|
| 观看连续剧 | 启用自动连播 | 播放完一集自动播放下一集 |
| 听音乐 | 启用随机播放 | 随机播放播放列表中的歌曲 |
| 单曲循环 | 启用单曲循环 | 重复播放当前歌曲/视频 |
| 播放列表结束 | 列表循环模式 | 从第一个重新开始播放 |
| 手动切换 | 用户手动选择下一个 | 跳过自动连播,播放指定视频 |

### 1.3 目录支持

- **层级播放列表**: 支持目录嵌套结构,目录可以包含媒体文件或子目录
- **深度优先遍历**: 自动连播按照深度优先顺序遍历目录树
- **视频提供方集成**: Alist/Emby 的目录可以作为"虚拟播放列表"添加
- **动态加载**: 不预先加载所有媒体文件,支持大型目录(1000+ 媒体文件)
- **跨目录跳转**: 播放完当前目录的所有媒体文件后,自动进入下一个目录

---

## 2. 架构设计

### 2.1 核心组件

```
┌──────────────────────────────────────────────────────────────┐
│                       房间播放管理器                          │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐   │
│  │  播放列表    │  │  播放状态    │  │  自动连播       │   │
│  │  管理器      │  │  管理器      │  │  管理器         │   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬──────────┘   │
│         │                 │                 │              │
│         │          ┌──────▼──────┐          │              │
│         │          │ PlaylistTree│          │              │
│         │          │  (目录树)    │          │              │
│         │          └──────┬──────┘          │              │
│         │                 │                 │              │
│         └─────────────────┴─────────────────┘              │
│                          │                                 │
│                   ┌──────▼───────┐                        │
│                   │  播放模式     │                        │
│                   │  - 顺序       │                        │
│                   │  - 单曲循环   │                        │
│                   │  - 列表循环   │                        │
│                   │  - 随机       │                        │
│                   └──────────────┘                        │
│                                                              │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌──────────────────────────────────────────────────────────────┐
│               WebSocket 广播 (通知所有客户端)                 │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 播放模式枚举

```rust
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PlayMode {
    /// 顺序播放 (播放完停止)
    Sequential,

    /// 单曲循环 (重复播放当前)
    RepeatOne,

    /// 列表循环 (播放完从头开始)
    RepeatAll,

    /// 随机播放
    Shuffle,
}

impl Default for PlayMode {
    fn default() -> Self {
        Self::Sequential
    }
}
```

### 2.3 播放列表树结构

为了支持目录嵌套,播放列表使用**树结构**而不是平面数组。树由两种节点类型组成:

- **目录节点**: 来自 `playlists` 表,可以包含子目录和媒体文件
- **媒体节点**: 来自 `medias` 表,代表实际的媒体文件

```rust
/// 播放列表树(用于遍历)
#[derive(Debug, Clone)]
pub struct PlaylistTree {
    /// 树的根节点(顶级目录)
    pub roots: Vec<PlaylistNode>,

    /// 快速查找: node_id -> node
    pub node_map: HashMap<String, Arc<PlaylistNode>>,  // nanoid(12)
}

#[derive(Debug, Clone)]
pub enum PlaylistNode {
    /// 目录节点(来自 playlists 表)
    Directory {
        id: String,  // nanoid(12)
        room_id: String,  // nanoid(12)
        name: String,
        parent_id: Option<String>,  // nanoid(12)
        position: i32,
        children: Vec<Arc<PlaylistNode>>,
        parent: Option<Weak<PlaylistNode>>,
    },
    /// 媒体文件节点(来自 medias 表)
    Media {
        id: String,  // nanoid(12)
        playlist_id: String,  // nanoid(12)
        room_id: String,  // nanoid(12)
        name: String,
        position: i32,
        source_type: String,
        source_config: Option<serde_json::Value>,
        credential_source: Option<String>,
        parent: Option<Weak<PlaylistNode>>,
    },
}

impl PlaylistNode {
    pub fn id(&self) -> String {
        match self {
            PlaylistNode::Directory { id, .. } => id.clone(),
            PlaylistNode::Media { id, .. } => id.clone(),
        }
    }

    pub fn is_media(&self) -> bool {
        matches!(self, PlaylistNode::Media { .. })
    }

    pub fn is_directory(&self) -> bool {
        matches!(self, PlaylistNode::Directory { .. })
    }
}

impl PlaylistTree {
    /// 从数据库加载并构建树
    pub async fn from_room(room_id: &str, db: &DbPool) -> Result<Self> {
        // 1. 查询所有目录(来自 playlists 表)
        let playlists = sqlx::query!(
            r#"
            SELECT id, room_id, name, parent_id, position
            FROM playlists
            WHERE room_id = $1
            ORDER BY parent_id NULLS FIRST, position ASC
            "#,
            room_id
        )
        .fetch_all(db)
        .await?;

        // 2. 查询所有媒体文件(来自 medias 表)
        let medias = sqlx::query!(
            r#"
            SELECT id, playlist_id, room_id, name, position,
                   source_type, source_config, credential_source
            FROM medias
            WHERE room_id = $1
            ORDER BY playlist_id, position ASC
            "#,
            room_id
        )
        .fetch_all(db)
        .await?;

        Self::build_tree(playlists, medias)
    }

    /// 深度优先遍历: 获取下一个可播放的媒体文件
    pub fn next_media(&self, current_id: &str, mode: PlayMode) -> Option<String> {
        match mode {
            PlayMode::Sequential => self.next_dfs(current_id),
            PlayMode::RepeatOne => Some(*current_id),
            PlayMode::RepeatAll => {
                self.next_dfs(current_id)
                    .or_else(|| self.first_media())
            }
            PlayMode::Shuffle => {
                // TODO: 随机选择(考虑目录权重)
                None
            }
        }
    }
}
```

---

## 3. 播放模式

### 3.1 顺序播放 (Sequential)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 自动播放 C (index=2)
播放完 C → 自动播放 D (index=3)
播放完 D → 停止播放 (index=4, 超出范围)
```

**实现**:

```rust
pub fn next_sequential(
    playlist: &[Movie],
    current_index: usize,
) -> Option<usize> {
    let next_index = current_index + 1;

    if next_index < playlist.len() {
        Some(next_index)
    } else {
        None  // 播放列表结束
    }
}
```

### 3.2 单曲循环 (RepeatOne)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 自动播放 B (index=1)
播放完 B → 自动播放 B (index=1)
... (无限循环)
```

**实现**:

```rust
pub fn next_repeat_one(current_index: usize) -> Option<usize> {
    Some(current_index)  // 始终返回当前索引
}
```

### 3.3 列表循环 (RepeatAll)

```
播放列表: [A, B, C, D]
当前: C (index=2)

播放完 C → 自动播放 D (index=3)
播放完 D → 自动播放 A (index=0, 循环)
播放完 A → 自动播放 B (index=1)
... (无限循环)
```

**实现**:

```rust
pub fn next_repeat_all(
    playlist: &[Movie],
    current_index: usize,
) -> Option<usize> {
    if playlist.is_empty() {
        return None;
    }

    let next_index = (current_index + 1) % playlist.len();
    Some(next_index)
}
```

### 3.4 随机播放 (Shuffle)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 随机播放 D (index=3)
播放完 D → 随机播放 A (index=0)
播放完 A → 随机播放 C (index=2)
... (随机但不重复,直到所有歌曲播放完)
```

**实现** (使用 Fisher-Yates 洗牌算法):

```rust
use rand::seq::SliceRandom;
use rand::thread_rng;

pub struct ShuffleManager {
    /// 原始播放列表索引
    original_indices: Vec<usize>,

    /// 洗牌后的索引列表
    shuffled_indices: Vec<usize>,

    /// 当前在洗牌列表中的位置
    current_position: usize,
}

impl ShuffleManager {
    pub fn new(playlist_len: usize) -> Self {
        let mut original_indices: Vec<usize> = (0..playlist_len).collect();
        let mut shuffled_indices = original_indices.clone();
        shuffled_indices.shuffle(&mut thread_rng());

        Self {
            original_indices,
            shuffled_indices,
            current_position: 0,
        }
    }

    /// 获取下一个随机索引
    pub fn next(&mut self) -> Option<usize> {
        self.current_position += 1;

        if self.current_position >= self.shuffled_indices.len() {
            // 重新洗牌
            self.shuffled_indices.shuffle(&mut thread_rng());
            self.current_position = 0;
        }

        self.shuffled_indices.get(self.current_position).copied()
    }

    /// 更新播放列表长度 (添加/删除电影时)
    pub fn update(&mut self, new_len: usize) {
        self.original_indices = (0..new_len).collect();
        self.shuffled_indices = self.original_indices.clone();
        self.shuffled_indices.shuffle(&mut thread_rng());
        self.current_position = 0;
    }
}
```

### 3.5 目录遍历算法

对于包含目录的播放列表,使用**深度优先遍历(DFS)**:

```
播放列表树结构:
/ (root directory, name='')
├── Video1.mp4                    <- Media (medias表)
├── [电视剧/权力的游戏]           <- Directory (playlists表)
│   ├── [第一季]                  <- Directory (playlists表)
│   │   ├── S01E01.mp4           <- Media (medias表)
│   │   ├── S01E02.mp4           <- Media (medias表)
│   │   └── S01E03.mp4           <- Media (medias表)
│   └── [第二季]                  <- Directory (playlists表)
│       ├── S02E01.mp4           <- Media (medias表)
│       └── S02E02.mp4           <- Media (medias表)
├── Video2.mp4                    <- Media (medias表)
└── [电影集合]                    <- Directory (playlists表)
    ├── Movie1.mp4                <- Media (medias表)
    └── Movie2.mp4                <- Media (medias表)

深度优先遍历顺序(顺序播放):
1. Video1.mp4                     (媒体文件)
2. [进入] 权力的游戏/第一季       (目录)
3. S01E01.mp4                     (媒体文件)
4. S01E02.mp4                     (媒体文件)
5. S01E03.mp4                     (媒体文件)
6. [进入] 权力的游戏/第二季       (目录)
7. S02E01.mp4                     (媒体文件)
8. S02E02.mp4                     (媒体文件)
9. [退出] 权力的游戏              (返回上级目录)
10. Video2.mp4                    (媒体文件)
11. [进入] 电影集合               (目录)
12. Movie1.mp4                    (媒体文件)
13. Movie2.mp4                    (媒体文件)
14. [结束]

注意: 根目录 name 为空字符串 ''，在视图中显示为 /
```

---

## 4. 实现方案

### 4.1 PlaylistTree 深度优先遍历

完整的深度优先遍历实现,支持目录和媒体文件的混合树结构:

```rust
impl PlaylistTree {
    /// 深度优先获取下一个媒体文件
    fn next_dfs(&self, current_id: &str) -> Option<String> {
        let current_node = self.node_map.get(current_id)?;

        // 1. 如果当前节点是目录,进入第一个子节点
        if let PlaylistNode::Directory { children, .. } = current_node.as_ref() {
            if let Some(first_child) = children.first() {
                return Self::first_media_in_subtree(first_child);
            }
        }

        // 2. 在当前层级找下一个兄弟节点
        if let Some(next_sibling) = self.next_sibling(current_node) {
            if next_sibling.is_media() {
                return Some(next_sibling.id());
            } else {
                // 兄弟是目录,进入第一个媒体文件
                return Self::first_media_in_subtree(&next_sibling);
            }
        }

        // 3. 回溯到父节点,找父节点的下一个兄弟
        let mut current = current_node.clone();
        loop {
            let parent_weak = match current.as_ref() {
                PlaylistNode::Directory { parent, .. } => parent,
                PlaylistNode::Media { parent, .. } => parent,
            };

            if let Some(parent_weak) = parent_weak {
                if let Some(parent) = parent_weak.upgrade() {
                    if let Some(next_sibling) = self.next_sibling(&parent) {
                        if next_sibling.is_media() {
                            return Some(next_sibling.id());
                        } else {
                            return Self::first_media_in_subtree(&next_sibling);
                        }
                    }
                    current = parent;
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        // 4. 已经到达播放列表末尾
        None
    }

    /// 获取兄弟节点中的下一个
    fn next_sibling(&self, node: &Arc<PlaylistNode>) -> Option<Arc<PlaylistNode>> {
        let parent_weak = match node.as_ref() {
            PlaylistNode::Directory { parent, .. } => parent,
            PlaylistNode::Media { parent, .. } => parent,
        };

        let siblings = if let Some(parent_weak) = parent_weak {
            if let Some(parent) = parent_weak.upgrade() {
                if let PlaylistNode::Directory { children, .. } = parent.as_ref() {
                    children.clone()
                } else {
                    return None;
                }
            } else {
                return None;
            }
        } else {
            // 顶级节点
            self.roots.iter().map(|n| Arc::new(n.clone())).collect()
        };

        siblings.iter()
            .skip_while(|n| n.id() != node.id())
            .nth(1)
            .cloned()
    }

    /// 获取第一个可播放的媒体文件(用于RepeatAll)
    fn first_media(&self) -> Option<String> {
        self.roots.first().and_then(|root| {
            if root.is_media() {
                Some(root.id())
            } else {
                Self::first_media_in_subtree(root)
            }
        })
    }

    /// 在子树中递归查找第一个媒体文件
    fn first_media_in_subtree(node: &PlaylistNode) -> Option<String> {
        if let PlaylistNode::Directory { children, .. } = node {
            for child in children {
                if child.is_media() {
                    return Some(child.id());
                }
                if let Some(id) = Self::first_media_in_subtree(child) {
                    return Some(id);
                }
            }
        }
        None
    }

    /// 构建树结构(从 playlists 和 medias 表)
    fn build_tree(
        playlists: Vec<PlaylistRow>,
        medias: Vec<MediaRow>,
    ) -> Result<Self> {
        let mut node_map: HashMap<String, Arc<PlaylistNode>> = HashMap::new();  // nanoid(12)
        let mut children_map: HashMap<Option<String>, Vec<Arc<PlaylistNode>>> = HashMap::new();  // nanoid(12)

        // 1. 创建所有目录节点
        for playlist in playlists {
            let node = Arc::new(PlaylistNode::Directory {
                id: playlist.id,
                room_id: playlist.room_id.clone(),
                name: playlist.name.clone(),
                parent_id: playlist.parent_id,
                position: playlist.position,
                children: Vec::new(),
                parent: None,
            });
            node_map.insert(playlist.id, node.clone());
            children_map.entry(playlist.parent_id).or_default().push(node);
        }

        // 2. 创建所有媒体节点并关联到父目录
        for media in medias {
            let node = Arc::new(PlaylistNode::Media {
                id: media.id,
                playlist_id: media.playlist_id,
                room_id: media.room_id.clone(),
                name: media.name.clone(),
                position: media.position,
                source_type: media.source_type.clone(),
                source_config: media.source_config.clone(),
                credential_source: media.credential_source.clone(),
                parent: None,
            });
            node_map.insert(media.id, node.clone());
            children_map.entry(Some(media.playlist_id)).or_default().push(node);
        }

        // 3. 连接父子关系
        // ... (省略父子关系连接代码)

        // 4. 构建根节点列表
        let roots = children_map.remove(&None).unwrap_or_default();

        Ok(Self { roots, node_map })
    }
}
```

### 4.2 MediaProvider 扩展

为了支持视频提供方(Alist/Emby)的智能连播,扩展 `MediaProvider` trait:

> **注意**：以下示例代码中的 `list_directory` 方法签名已更新为：
>
> ```rust
> async fn list_directory(
>     &self,
>     ctx: &ProviderContext<'_>,
>     playlist: &Playlist,
>     relative_path: Option<&str>,
>     keyword: Option<&str>,
>     page: usize,
>     page_size: usize,
> ) -> Result<DirectoryListing>
> ```
>
> 完整签名见 [04-数据库设计.md](./04-数据库设计.md) 和 [08-视频内容管理.md](./08-视频内容管理.md)

```rust
#[async_trait]
pub trait MediaProvider: Send + Sync {
    // ... 现有方法 ...

    /// 获取同目录下的下一个视频
    ///
    /// 用于视频提供方的智能连播(如 Alist 目录)
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - current_media: 当前媒体对象
    ///
    /// # 注意
    /// 此方法为可选扩展，实际实现需要调用 list_directory 获取目录内容
    async fn get_next_video(
        &self,
        ctx: &ProviderContext<'_>,
        current_media: &Media,
    ) -> Result<Option<DirectoryItem>> {
        // 默认实现：需要根据实际情况调用 list_directory
        // 这里仅为示意，实际需要传递正确的 playlist 对象
        Err(Error::NotSupported)
    }

    /// 递归列出目录下所有视频（用于"播完整个目录"模式）
    ///
    /// # 参数
    /// - ctx: Provider 上下文
    /// - playlist: 动态目录对象
    /// - max_depth: 最大递归深度（防止无限递归）
    ///
    /// # 注意
    /// 此方法为可选扩展，实际实现需要调用 list_directory 递归获取
    async fn list_videos_recursive(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        max_depth: usize,
    ) -> Result<Vec<DirectoryItem>> {
        // 默认实现：需要递归调用 list_directory
        Err(Error::NotSupported)

        // 过滤视频文件并排序
        let mut videos: Vec<_> = files
            .into_iter()
            .filter(|v| v.r#type == VideoType::Video)
            .collect();

        // 自然排序(支持 S01E01, S01E02 等)
        videos.sort_by(|a, b| natord::compare(&a.title, &b.title));

        // 找到当前视频的位置
        let current_index = videos.iter()
            .position(|v| v.id == path)?;

        // 返回下一个
        Ok(videos.get(current_index + 1).cloned())
    }

    /// 获取目录的所有子视频(递归)
    ///
    /// 用于"添加目录到播放列表"功能
    async fn list_videos_recursive(
        &self,
        path: &str,
        recursive: bool,
    ) -> Result<Vec<VideoInfo>> {
        let mut result = Vec::new();
        let items = self.list_directory(path).await?;

        for item in items {
            match item.r#type {
                VideoType::Video | VideoType::Live => {
                    result.push(item);
                }
                VideoType::Folder if recursive => {
                    let sub_items = self.list_videos_recursive(&item.id, recursive).await?;
                    result.extend(sub_items);
                }
                _ => {}
            }
        }

        Ok(result)
    }
}
```

### 4.3 缓存优化

为避免每次都从数据库重建播放列表树,使用缓存:

```rust
/// 播放列表树缓存
pub struct PlaylistTreeCache {
    cache: Arc<DashMap<String, (PlaylistTree, Instant)>>,
    ttl: Duration,
}

impl PlaylistTreeCache {
    pub fn new(ttl: Duration) -> Self {
        Self {
            cache: Arc::new(DashMap::new()),
            ttl,
        }
    }

    pub async fn get_or_load(
        &self,
        room_id: &str,
        db: &DbPool,
    ) -> Result<PlaylistTree> {
        // 1. 检查缓存
        if let Some(entry) = self.cache.get(room_id) {
            let (tree, cached_at) = entry.value();
            if cached_at.elapsed() < self.ttl {
                return Ok(tree.clone());
            }
        }

        // 2. 从数据库加载
        let tree = PlaylistTree::from_room(room_id, db).await?;

        // 3. 更新缓存
        self.cache.insert(room_id.to_string(), (tree.clone(), Instant::now()));

        Ok(tree)
    }

    pub fn invalidate(&self, room_id: &str) {
        self.cache.remove(room_id);
    }
}
```

### 4.4 房间设置

```rust
/// 房间自动连播设置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutoPlaySettings {
    /// 是否启用自动连播
    pub enabled: bool,

    /// 播放模式
    pub mode: PlayMode,

    /// 自动播放延迟 (秒)
    /// 视频播放完后等待多久再播放下一个
    pub delay: u32,
}

impl Default for AutoPlaySettings {
    fn default() -> Self {
        Self {
            enabled: true,
            mode: PlayMode::Sequential,
            delay: 3,  // 默认3秒延迟
        }
    }
}
```

### 4.5 播放完成事件处理(支持目录)

```rust
/// 处理视频播放完成事件(支持目录遍历)
pub async fn handle_video_ended(
    room: &Room,
    current_media_id: &str,  // nanoid(12)
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
    tree_cache: &PlaylistTreeCache,
) -> Result<()> {
    // 1. 检查是否启用自动连播
    if !room.settings.auto_play.enabled {
        tracing::debug!("Auto play disabled for room {}", room.id);
        return Ok(());
    }

    // 2. 加载播放列表树(带缓存)
    let tree = tree_cache.get_or_load(&room.id, db).await?;

    // 3. 根据播放模式计算下一个媒体文件ID
    let next_id = match room.settings.auto_play.mode {
        PlayMode::Sequential => tree.next_dfs(current_media_id),
        PlayMode::RepeatOne => Some(*current_media_id),
        PlayMode::RepeatAll => {
            tree.next_dfs(current_media_id)
                .or_else(|| tree.first_media())
        }
        PlayMode::Shuffle => {
            // TODO: 实现随机算法
            None
        }
    };

    // 4. 如果有下一个,延迟后自动播放
    if let Some(next_id) = next_id {
        // 从数据库加载完整的 Media 对象
        let next_media = sqlx::query_as!(
            Media,
            r#"
            SELECT id, playlist_id, room_id, creator_id, name, position,
                   source_type, source_config, credential_source
            FROM medias
            WHERE id = $1
            "#,
            next_id
        )
        .fetch_one(db)
        .await?;

        // 如果是 Alist/Emby 的视频,可能需要刷新元数据(URL可能过期)
        if next_media.needs_refresh() {
            if let Some(provider) = provider_registry.get(&next_media.source_type).await {
                if let Ok(video_info) = provider.parse(
                    &next_media.source_config,
                    next_media.credential_source.as_ref(),
                ).await {
                    // 更新元数据到数据库
                    refresh_media_metadata(&next_media, video_info, db).await?;
                }
            }
        }

        let delay = Duration::from_secs(room.settings.auto_play.delay as u64);

        // 广播"即将播放下一个"事件(倒计时)
        room.broadcast_auto_play_countdown(
            &next_id,
            &next_media.name,
            room.settings.auto_play.delay,
        ).await?;

        tokio::time::sleep(delay).await;

        // 切换到下一个媒体文件
        room.set_current_media(&next_id).await?;

        // 广播自动播放开始事件
        room.broadcast_auto_play_started(&next_id).await?;

        tracing::info!(
            "Auto play: room={}, current={}, next={}",
            room.id,
            current_media_id,
            next_id
        );
    } else {
        tracing::info!("Playlist ended for room {}", room.id);

        // 广播播放列表结束事件
        room.broadcast_playlist_ended().await?;
    }

    Ok(())
}
```

### 4.6 WebSocket 消息定义

服务端 → 客户端消息:

```javascript
// 自动播放倒计时(视频播放完成后)
{
  "type": "auto_play.countdown",
  "data": {
    "next_media_id": "abc123xyz456",  // nanoid(12)
    "next_media_name": "S01E02.mp4",
    "countdown": 3,
    "mode": "sequential"  // "sequential" | "repeat_one" | "repeat_all" | "shuffle"
  }
}

// 自动播放开始
{
  "type": "auto_play.started",
  "data": {
    "media_id": "550e8400-e29b-41d4-a716-446655440020"
  }
}

// 播放列表结束(Sequential模式)
{
  "type": "playlist.ended",
  "data": {}
}
```

客户端 → 服务端消息:

```javascript
// 取消自动播放(倒计时期间)
{
  "type": "auto_play.cancel",
  "data": {}
}
```

### 4.7 客户端实现要点

客户端需要实现自动连播相关UI和交互：

**接收自动播放事件**：

- 监听 `auto_play.countdown` 消息
- 提取 `next_media_id` 和 `countdown` 秒数

**倒计时UI**：

- 显示倒计时提示："{countdown}秒后自动播放下一个"
- 每秒更新倒计时数字
- 倒计时结束时清理UI

**取消功能**：

- 显示"取消自动播放"按钮
- 点击时发送 `cancel_auto_play` 消息到服务端
- 清除倒计时定时器

**状态管理**：

- 记录倒计时状态（是否正在倒计时）
- 管理倒计时定时器生命周期
- 处理多个快速切换的倒计时事件

---

## 5. 边界情况处理

### 5.1 播放列表为空

```rust
pub async fn handle_empty_playlist(room: &Room) -> Result<()> {
    tracing::warn!("Playlist empty for room {}", room.id);

    // 停止播放
    room.set_player_state(PlayerState {
        action: PlayerAction::Pause,
        position: 0.0,
        rate: 1.0,
    }).await?;

    // 广播播放列表为空事件
    room.broadcast_playlist_empty().await?;

    Ok(())
}
```

### 5.2 播放列表变更

```rust
/// 播放列表发生变更时 (添加/删除媒体文件或目录)
pub async fn handle_playlist_changed(
    room: &Room,
    change_type: PlaylistChangeType,
    tree_cache: &PlaylistTreeCache,
) -> Result<()> {
    // 使缓存失效
    tree_cache.invalidate(&room.id);

    match change_type {
        PlaylistChangeType::MediaAdded { media_id } => {
            // 如果是随机模式,更新洗牌列表
            if room.settings.auto_play.mode == PlayMode::Shuffle {
                // TODO: 更新随机播放管理器
            }
        }
        PlaylistChangeType::MediaRemoved { media_id } => {
            // 如果删除的是当前播放的媒体文件
            let current = room.get_current_media().await?;
            if current.id == media_id {
                // 自动播放下一个
                handle_video_ended(room, &media_id, db, provider_registry, tree_cache).await?;
            }
        }
        PlaylistChangeType::DirectoryAdded { playlist_id } => {
            // 添加目录不影响随机模式
        }
        PlaylistChangeType::DirectoryRemoved { playlist_id } => {
            // 如果删除的目录包含当前播放的媒体文件
            // 需要检查并跳到下一个
        }
        PlaylistChangeType::Reordered => {
            // 重新排序不影响随机模式
        }
    }

    Ok(())
}
```

### 5.3 权限检查

**重要**: 自动连播是**房间设置**,不是用户权限。用户需要有 `SET_ROOM_SETTINGS` 权限才能修改自动连播配置。

```rust
/// 检查用户是否有权限修改自动连播设置
pub async fn can_modify_auto_play_settings(
    user: &User,
    room: &Room,
) -> Result<bool> {
    // 1. 全局管理员可以修改任何房间设置
    if user.role.is_admin_or_above() && user.status == UserStatus::Active {
        return Ok(true);
    }

    // 2. 获取用户在房间的成员信息
    let member = room.get_member(user.id).await
        .ok_or(Error::NotRoomMember)?;

    // 3. 检查成员状态
    if member.status != MemberStatus::Active {
        return Ok(false);
    }

    // 4. 检查是否有修改房间设置的权限
    Ok(member.has_permission(room, Permissions::SET_ROOM_SETTINGS))
}

/// 修改自动连播设置 API
#[axum::debug_handler]
pub async fn update_auto_play_settings(
    Extension(user): Extension<User>,
    Extension(room): Extension<Room>,
    Json(payload): Json<UpdateAutoPlayRequest>,
) -> Result<StatusCode> {
    // 1. 权限检查
    if !can_modify_auto_play_settings(&user, &room).await? {
        return Err(Error::PermissionDenied.into());
    }

    // 2. 更新房间设置
    room.settings.auto_play.enabled = payload.enabled;
    room.settings.auto_play.mode = payload.mode;
    room.settings.auto_play.delay = payload.delay;

    // 3. 保存到数据库
    room.save_settings().await?;

    // 4. 广播设置变更
    room.broadcast_settings_changed().await?;

    Ok(StatusCode::NO_CONTENT)
}

#[derive(Deserialize)]
pub struct UpdateAutoPlayRequest {
    pub enabled: bool,
    pub mode: PlayMode,
    pub delay: u32,
}
```

### 5.4 多副本同步

```rust
/// 自动连播状态存储到 Redis (多副本同步)
pub async fn save_auto_play_state(
    redis: &RedisPool,
    room_id: &str,
    state: &AutoPlayState,
) -> Result<()> {
    let key = format!("room:{}:auto_play", room_id);
    let value = serde_json::to_string(state)?;

    redis.set_ex(&key, value, 300).await?;

    // 发布变更通知
    redis.publish(
        "auto_play:changed",
        serde_json::to_string(state)?,
    ).await?;

    Ok(())
}

#[derive(Serialize, Deserialize)]
pub struct AutoPlayState {
    pub room_id: String,
    pub enabled: bool,
    pub mode: PlayMode,
    pub current_index: usize,
    pub next_index: Option<usize>,
    pub scheduled_at: Option<i64>,  // 预定播放时间
}
```

### 5.5 空目录

处理空目录的情况(跳过空目录):

```rust
impl PlaylistTree {
    fn next_dfs(&self, current_id: &Uuid) -> Option<Uuid> {
        let current_node = self.node_map.get(current_id)?;

        // 跳过空目录
        if let PlaylistNode::Directory { children, .. } = current_node.as_ref() {
            if let Some(first_child) = children.first() {
                if first_child.is_directory() {
                    if let PlaylistNode::Directory { children: sub_children, .. } = first_child.as_ref() {
                        if sub_children.is_empty() {
                            // 空目录,跳过到下一个兄弟
                            return self.next_sibling(current_node).map(|n| n.id());
                        }
                    }
                }
                return Self::first_media_in_subtree(first_child);
            }
        }

        // ... 其他逻辑 ...
    }
}
```

### 5.6 目录被删除

监听播放列表变更并使缓存失效:

```rust
/// 监听媒体文件被删除
pub async fn handle_media_removed(
    room: &Room,
    media_id: &Uuid,
    cache: &PlaylistTreeCache,
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    // 1. 使缓存失效
    cache.invalidate(&room.id);

    // 2. 如果删除的是当前播放的媒体文件
    let current = room.get_current_media().await?;

    if current.id == *media_id {
        // 跳到下一个
        handle_video_ended(room, &current.id, db, provider_registry, cache).await?;
    }

    Ok(())
}

/// 监听目录被删除
pub async fn handle_directory_removed(
    room: &Room,
    playlist_id: &Uuid,
    cache: &PlaylistTreeCache,
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    // 1. 使缓存失效
    cache.invalidate(&room.id);

    // 2. 如果删除的目录包含当前播放的媒体文件
    let current = room.get_current_media().await?;

    if is_ancestor_directory(playlist_id, &current.playlist_id, db).await? {
        // 跳到下一个
        handle_video_ended(room, &current.id, db, provider_registry, cache).await?;
    }

    Ok(())
}

/// 检查是否是祖先目录
async fn is_ancestor_directory(ancestor_id: &Uuid, descendant_id: &Uuid, db: &DbPool) -> Result<bool> {
    let mut current_id = *descendant_id;

    loop {
        let playlist = sqlx::query!(
            r#"SELECT parent_id FROM playlists WHERE id = $1"#,
            current_id
        )
        .fetch_one(db)
        .await?;

        if let Some(parent_id) = playlist.parent_id {
            if parent_id == *ancestor_id {
                return Ok(true);
            }
            current_id = parent_id;
        } else {
            break;
        }
    }

    Ok(false)
}
```

### 5.7 视频提供方不可用

处理视频提供方错误(自动跳过):

```rust
/// 处理视频加载错误
pub async fn handle_video_load_error(
    room: &Room,
    media_id: &Uuid,
    error: &Error,
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
    cache: &PlaylistTreeCache,
) -> Result<()> {
    match error {
        Error::ProviderUnavailable | Error::ProviderAuthFailed => {
            // 视频提供者不可用,跳过该媒体文件
            tracing::warn!(
                "Provider unavailable for media {}, skipping to next",
                media_id
            );

            // 自动播放下一个
            handle_video_ended(room, media_id, db, provider_registry, cache).await?;
        }
        _ => {
            // 其他错误,停止播放
            room.broadcast_playback_error(error).await?;
        }
    }

    Ok(())
}
```

---

## 6. 目录支持

### 6.1 添加目录到播放列表 API

```http
POST /api/v1/rooms/{room_id}/playlists
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "name": "权力的游戏",                  // 目录名称
  "parent_id": null,                     // 父目录ID, null表示根目录
  "position": 0                          // 在父目录中的位置
}

Response: 201 Created
{
  "code": 0,
  "message": "success",
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440020",
    "room_id": "room_abc123xyz",
    "creator_id": "user_abc123xyz",
    "name": "权力的游戏",
    "parent_id": null,
    "position": 0,
    "created_at": "2024-01-15T11:30:00Z"
  }
}
```

### 6.2 从视频提供方导入目录 API

```http
POST /api/v1/rooms/{room_id}/playlists/import
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "source_type": "alist",               // 视频源类型
  "source_config": {                    // 源配置(包含路径等信息)
    "path": "/电视剧/权力的游戏"
  },
  "credential_source": "alist_main",    // 凭证来源
  "parent_id": null,                    // 父目录ID
  "recursive": true                     // 是否递归导入子目录
}

Response: 201 Created
{
  "code": 0,
  "message": "success",
  "data": {
    "playlist_id": "550e8400-e29b-41d4-a716-446655440020",
    "media_count": 16,
    "directory_count": 2
  }
}
```

### 6.3 预览下一个媒体文件 API

```http
GET /api/v1/rooms/{room_id}/medias/{media_id}/next?mode=sequential
Authorization: Bearer {token}

Query Parameters:
- mode: 播放模式 (sequential|repeat_one|repeat_all|shuffle)

Response: 200 OK
{
  "code": 0,
  "message": "success",
  "data": {
    "next_media": {
      "id": "550e8400-e29b-41d4-a716-446655440022",
      "name": "S01E02.mp4",
      "playlist_id": "550e8400-e29b-41d4-a716-446655440020",
      "source_type": "alist",
      "source_config": { "path": "/电视剧/权力的游戏/第一季/S01E02.mp4" }
    },
    "will_loop": false,           // RepeatAll模式下如果循环回第一个
    "playlist_ended": false       // Sequential模式下如果到达末尾
  }
}
```

---

## 总结

本章节设计了一个**灵活、可靠、支持目录层级**的自动连播系统:

✅ **多种播放模式**: 顺序、单曲循环、列表循环、随机
✅ **目录支持**: 深度优先遍历,跨目录自动连播
✅ **视频提供方集成**: Alist/Emby 目录作为虚拟播放列表
✅ **用户体验**: 倒计时提示、可取消、无缝切换
✅ **房间级配置**: 自动连播是房间设置,由拥有 `SET_ROOM_SETTINGS` 权限的用户配置
✅ **性能优化**: PlaylistTree 缓存,避免重复查询
✅ **边界情况**: 空列表、空目录、目录删除、视频提供方不可用
✅ **多副本同步**: Redis 存储自动连播状态

关键设计:

- ❌ 自动连播不是用户权限
- ✅ 自动连播是房间设置 (RoomSettings.auto_play)
- ✅ 修改自动连播配置需要 `SET_ROOM_SETTINGS` 权限
- ✅ 自动连播触发是基于房间配置,不需要用户操作
- ✅ 使用 PlaylistTree 支持目录层级结构
- ✅ 深度优先遍历(DFS)跨目录自动播放
- ✅ MediaProvider 扩展支持 get_next_video 和 list_videos_recursive

核心改进:

- 数据结构: 从平面数组升级为 PlaylistTree(支持目录嵌套)
- 遍历算法: 从简单 index+1 升级为深度优先遍历(DFS)
- 数据库设计: 目录(playlists表) + 媒体文件(medias表) 分离存储
- API 扩展: 添加目录、从视频源导入、预览下一个媒体文件
- 缓存优化: PlaylistTreeCache 提升性能

数据库映射:

- `playlists` 表: 存储目录节点,包含 id, room_id, name, parent_id, position
- `medias` 表: 存储媒体文件节点,包含 id, playlist_id, room_id, name, position, source_type, source_config
- 根目录: name 为空字符串 `''`,在视图中显示为 `/`
- 树结构: 通过 parent_id (playlists) 和 playlist_id (medias) 构建完整的目录树

**上一章**: [12-时间同步与补偿](./12-时间同步与补偿.md)
**下一章**: [14-通信架构设计](./18-API文档生成方案.md)
