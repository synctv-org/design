# 23. 自动连播设计

---

## 目录

- [1. 功能需求](#1-功能需求)
- [2. 架构设计](#2-架构设计)
- [3. 播放模式](#3-播放模式)
- [4. 实现方案](#4-实现方案)
- [5. 边界情况处理](#5-边界情况处理)
- [6. 目录支持](#6-目录支持)

---

## 1. 功能需求

### 1.1 基本需求

- **自动播放下一个**: 当前视频播放完毕后自动播放下一个
- **播放模式**: 支持顺序播放、单曲循环、列表循环、随机播放
- **用户体验**: 无缝切换,无黑屏
- **房间级配置**: 自动连播是**房间设置**,由拥有 `SET_ROOM_SETTINGS` 权限的用户配置
- **多副本同步**: 自动连播状态在所有副本间同步

### 1.2 用户场景

| 场景 | 行为 | 预期 |
|------|------|------|
| 观看连续剧 | 启用自动连播 | 播放完一集自动播放下一集 |
| 听音乐 | 启用随机播放 | 随机播放播放列表中的歌曲 |
| 单曲循环 | 启用单曲循环 | 重复播放当前歌曲/视频 |
| 播放列表结束 | 列表循环模式 | 从第一个重新开始播放 |
| 手动切换 | 用户手动选择下一个 | 跳过自动连播,播放指定视频 |

### 1.3 目录支持

- **层级播放列表**: 支持目录嵌套结构,目录可以包含媒体文件或子目录
- **文件夹内播放**: 自动连播只在当前playlist（文件夹）内进行,不跨目录
- **视频提供方集成**: Alist/Emby 的目录可以作为"动态文件夹"添加
- **动态加载**: 动态文件夹不预先加载所有媒体文件,支持大型目录(1000+ 媒体文件)
- **手动切换**: 播放完当前文件夹后停止,用户手动切换到下一个文件夹

---

## 2. 架构设计

### 2.1 核心组件

```
┌──────────────────────────────────────────────────────────────┐
│                       房间播放管理器                          │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐   │
│  │  播放列表    │  │  播放状态    │  │  自动连播       │   │
│  │  管理器      │  │  管理器      │  │  管理器         │   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬──────────┘   │
│         │                 │                 │              │
│         │                 │                 │              │
│         │                 │                 │              │
│         │                 │                 │              │
│         │                 │                 │              │
│         └─────────────────┴─────────────────┘              │
│                          │                                 │
│                   ┌──────▼───────┐                        │
│                   │  播放模式     │                        │
│                   │  - 顺序       │                        │
│                   │  - 单曲循环   │                        │
│                   │  - 列表循环   │                        │
│                   │  - 随机       │                        │
│                   └──────────────┘                        │
│                          │                                 │
│         ┌────────────────┴────────────────┐               │
│         │                                 │               │
│  ┌──────▼───────┐              ┌──────────▼──────────┐   │
│  │ 静态播放列表  │              │   动态文件夹         │   │
│  │ SQL查询      │              │ Provider.next()     │   │
│  └──────────────┘              └─────────────────────┘   │
│                                                              │
└──────────────────────────────────────────────────────────────┘
                         │
                         ▼
┌──────────────────────────────────────────────────────────────┐
│               WebSocket 广播 (通知所有客户端)                 │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 播放模式枚举

```rust
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PlayMode {
    /// 顺序播放 (播放完停止)
    Sequential,

    /// 单曲循环 (重复播放当前)
    RepeatOne,

    /// 列表循环 (播放完从头开始)
    RepeatAll,

    /// 随机播放
    Shuffle,
}

impl Default for PlayMode {
    fn default() -> Self {
        Self::Sequential
    }
}
```

### 2.3 自动播放范围

自动播放的范围是**当前playlist（文件夹）**，不跨目录：

```
播放列表结构:
根目录/
├── [文件夹] 权力的游戏/    <- Playlist A (position=0, type_order=0)
│   ├── S01E01.mp4         <- Media 1 (playlist_id=A, position=0)
│   ├── S01E02.mp4         <- Media 2 (playlist_id=A, position=1)
│   └── S01E03.mp4         <- Media 3 (playlist_id=A, position=2)
├── [文件夹] 绝命毒师/      <- Playlist B (position=1, type_order=0)
│   ├── S01E01.mp4         <- Media 4 (playlist_id=B, position=0)
│   └── S01E02.mp4         <- Media 5 (playlist_id=B, position=1)
└── [视频] 特别节目.mp4     <- Media 6 (playlist_id=ROOT, position=0)

列表显示顺序（type_order → position）:
1. [文件夹] 权力的游戏/    (type_order=0, position=0)
2. [文件夹] 绝命毒师/      (type_order=0, position=1)
3. [视频] 特别节目.mp4     (type_order=1, position=0)

自动播放行为:
- 播放 Media 1 (S01E01.mp4) 完成 → 自动播放 Media 2 (S01E02.mp4)
- 播放 Media 2 完成 → 自动播放 Media 3 (S01E03.mp4)
- 播放 Media 3 完成 → 停止播放 (不会跨到 Playlist B)

如果想播放 Playlist B，用户需要手动切换
```

**设计原则**：
- ✅ 自动播放只在当前playlist内进行
- ✅ 按`position`字段顺序播放（只查询media，不包括playlist）
- ✅ 播放完当前playlist的最后一个media后停止
- ✅ Playlist 和 Media 的 position 独立管理
- ✅ 列表显示时 playlist 在前（type_order=0），media 在后（type_order=1）
- ❌ 不跨playlist自动播放
- ❌ 不需要深度优先遍历树结构

---

## 3. 播放模式

### 3.1 顺序播放 (Sequential)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 自动播放 C (index=2)
播放完 C → 自动播放 D (index=3)
播放完 D → 停止播放 (index=4, 超出范围)
```

**实现**:

```rust
pub fn next_sequential(
    playlist: &[Movie],
    current_index: usize,
) -> Option<usize> {
    let next_index = current_index + 1;

    if next_index < playlist.len() {
        Some(next_index)
    } else {
        None  // 播放列表结束
    }
}
```

### 3.2 单曲循环 (RepeatOne)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 自动播放 B (index=1)
播放完 B → 自动播放 B (index=1)
... (无限循环)
```

**实现**:

```rust
pub fn next_repeat_one(current_index: usize) -> Option<usize> {
    Some(current_index)  // 始终返回当前索引
}
```

### 3.3 列表循环 (RepeatAll)

```
播放列表: [A, B, C, D]
当前: C (index=2)

播放完 C → 自动播放 D (index=3)
播放完 D → 自动播放 A (index=0, 循环)
播放完 A → 自动播放 B (index=1)
... (无限循环)
```

**实现**:

```rust
pub fn next_repeat_all(
    playlist: &[Movie],
    current_index: usize,
) -> Option<usize> {
    if playlist.is_empty() {
        return None;
    }

    let next_index = (current_index + 1) % playlist.len();
    Some(next_index)
}
```

### 3.4 随机播放 (Shuffle)

```
播放列表: [A, B, C, D]
当前: B (index=1)

播放完 B → 随机播放 D (index=3)
播放完 D → 随机播放 A (index=0)
播放完 A → 随机播放 C (index=2)
... (随机但不重复,直到所有歌曲播放完)
```

**实现** (使用 Fisher-Yates 洗牌算法):

```rust
use rand::seq::SliceRandom;
use rand::thread_rng;

pub struct ShuffleManager {
    /// 原始播放列表索引
    original_indices: Vec<usize>,

    /// 洗牌后的索引列表
    shuffled_indices: Vec<usize>,

    /// 当前在洗牌列表中的位置
    current_position: usize,
}

impl ShuffleManager {
    pub fn new(playlist_len: usize) -> Self {
        let mut original_indices: Vec<usize> = (0..playlist_len).collect();
        let mut shuffled_indices = original_indices.clone();
        shuffled_indices.shuffle(&mut thread_rng());

        Self {
            original_indices,
            shuffled_indices,
            current_position: 0,
        }
    }

    /// 获取下一个随机索引
    pub fn next(&mut self) -> Option<usize> {
        self.current_position += 1;

        if self.current_position >= self.shuffled_indices.len() {
            // 重新洗牌
            self.shuffled_indices.shuffle(&mut thread_rng());
            self.current_position = 0;
        }

        self.shuffled_indices.get(self.current_position).copied()
    }

    /// 更新播放列表长度 (添加/删除电影时)
    pub fn update(&mut self, new_len: usize) {
        self.original_indices = (0..new_len).collect();
        self.shuffled_indices = self.original_indices.clone();
        self.shuffled_indices.shuffle(&mut thread_rng());
        self.current_position = 0;
    }
}
```

### 3.5 文件夹内顺序播放

自动播放只在当前playlist（文件夹）内按`position`顺序进行:

```
Playlist: 权力的游戏/第一季 (id=playlist_abc)
├── S01E01.mp4  (id=media_001, playlist_id=playlist_abc, position=0)
├── S01E02.mp4  (id=media_002, playlist_id=playlist_abc, position=1)
└── S01E03.mp4  (id=media_003, playlist_id=playlist_abc, position=2)

顺序播放行为:
1. 播放 S01E01.mp4 (position=0)
2. 播放完成 → 查询 playlist_id=playlist_abc AND position=1 → 播放 S01E02.mp4
3. 播放完成 → 查询 playlist_id=playlist_abc AND position=2 → 播放 S01E03.mp4
4. 播放完成 → 查询 playlist_id=playlist_abc AND position=3 → 未找到 → 停止

SQL查询:
SELECT id, name FROM medias
WHERE playlist_id = $1 AND position > $2
ORDER BY position ASC
LIMIT 1
```

---

## 4. 实现方案

### 4.1 静态播放列表的下一个Media查询

简单的SQL查询,在当前playlist内按position顺序查找下一个media:

```rust
/// 在静态播放列表中查找下一个media
///
/// 只在当前playlist（文件夹）内查找，不跨目录
async fn get_next_in_playlist(
    current_media: &Media,
    mode: PlayMode,
    db: &DbPool,
) -> Result<Option<Media>> {
    match mode {
        PlayMode::Sequential => {
            // 顺序播放: 查找position更大的下一个
            sqlx::query_as!(
                Media,
                r#"
                SELECT id, playlist_id, room_id, creator_id, name, position,
                       source_provider, source_config, metadata, provider_data,
                       created_at, updated_at
                FROM medias
                WHERE playlist_id = $1 AND position > $2
                ORDER BY position ASC
                LIMIT 1
                "#,
                current_media.playlist_id,
                current_media.position
            )
            .fetch_optional(db)
            .await
        }

        PlayMode::RepeatOne => {
            // 单曲循环: 返回当前media
            Ok(Some(current_media.clone()))
        }

        PlayMode::RepeatAll => {
            // 列表循环: 尝试查找下一个，如果没有则回到第一个
            let next = sqlx::query_as!(
                Media,
                r#"
                SELECT id, playlist_id, room_id, creator_id, name, position,
                       source_provider, source_config, metadata, provider_data,
                       created_at, updated_at
                FROM medias
                WHERE playlist_id = $1 AND position > $2
                ORDER BY position ASC
                LIMIT 1
                "#,
                current_media.playlist_id,
                current_media.position
            )
            .fetch_optional(db)
            .await?;

            if next.is_some() {
                Ok(next)
            } else {
                // 回到第一个
                sqlx::query_as!(
                    Media,
                    r#"
                    SELECT id, playlist_id, room_id, creator_id, name, position,
                           source_provider, source_config, metadata, provider_data,
                           created_at, updated_at
                    FROM medias
                    WHERE playlist_id = $1
                    ORDER BY position ASC
                    LIMIT 1
                    "#,
                    current_media.playlist_id
                )
                .fetch_optional(db)
                .await
            }
        }

        PlayMode::Shuffle => {
            // 随机播放: 在当前playlist内随机选择一个不同的media
            sqlx::query_as!(
                Media,
                r#"
                SELECT id, playlist_id, room_id, creator_id, name, position,
                       source_provider, source_config, metadata, provider_data,
                       created_at, updated_at
                FROM medias
                WHERE playlist_id = $1 AND id != $2
                ORDER BY RANDOM()
                LIMIT 1
                "#,
                current_media.playlist_id,
                current_media.id
            )
            .fetch_optional(db)
            .await
        }
    }
}
```

### 4.2 动态文件夹自动播放

对于动态文件夹(Alist目录、Emby播放列表等),自动播放通过 `DynamicFolder` trait 的 `next()` 方法实现。

完整的 `DynamicFolder` trait 定义见 [08-视频内容管理.md](./08-视频内容管理.md)。

**动态文件夹检测**:

```rust
impl Playlist {
    /// 判断是否为动态目录
    ///
    /// 动态目录的特征:
    /// - source_provider不为空(如"alist", "emby")
    /// - source_config不为空(包含Provider特定配置)
    ///
    /// 完整定义见 04-数据库设计.md
    pub fn is_dynamic(&self) -> bool {
        self.source_provider.is_some()
    }
}
```

**Provider接口要求**:

```rust
pub trait MediaProvider: Send + Sync {
    // ... 现有方法 ...

    /// 将Provider转换为DynamicFolder trait对象(如果支持)
    ///
    /// # 返回值
    /// - Some: Provider支持动态文件夹功能
    /// - None: Provider不支持(如直链Provider)
    fn as_dynamic_folder(&self) -> Option<&dyn DynamicFolder> {
        None  // 默认不支持
    }
}

// Alist Provider实现示例
impl MediaProvider for AlistProvider {
    fn as_dynamic_folder(&self) -> Option<&dyn DynamicFolder> {
        Some(self)  // Alist支持动态文件夹
    }
}
```

**关键接口**:

```rust
#[async_trait]
pub trait DynamicFolder: MediaProvider {
    /// 获取下一个播放项
    ///
    /// 用于动态文件夹(Emby播放列表、Alist目录)的自动播放
    ///
    /// # 参数
    /// - ctx: Provider上下文(包含凭证等)
    /// - playlist: 动态文件夹的Playlist对象
    /// - current_media: 当前正在播放的Media对象
    /// - mode: 播放模式(顺序/循环/随机等)
    ///
    /// # 返回值
    /// - Ok(Some(NextPlayItem)): 找到下一个播放项
    /// - Ok(None): 没有下一个(播放列表结束)
    /// - Err: Provider错误(如网络错误、认证失败)
    async fn next(
        &self,
        ctx: &ProviderContext<'_>,
        playlist: &Playlist,
        current_media: &Media,
        mode: PlayMode,
    ) -> Result<Option<NextPlayItem>>;
}

/// 下一个播放项信息
pub struct NextPlayItem {
    /// 媒体名称
    pub name: String,

    /// 项目类型(Video/Audio/Live)
    pub item_type: ItemType,

    /// 源配置(包含Provider特定的标识符,如路径、ID等)
    pub source_config: Value,

    /// 元数据(时长、分辨率等)
    pub metadata: Metadata,

    /// Provider内部数据(用于状态追踪、分页等)
    pub provider_data: Value,
}
```

**使用场景**:

1. **Emby播放列表**: Provider内部维护播放列表状态,根据`mode`返回下一项
2. **Alist目录**: 动态列出目录内容,自然排序后返回下一个文件
3. **分页支持**: Provider内部管理分页状态,自动加载下一页
4. **循环模式**: Provider根据`mode`决定是否循环到第一项

### 4.3 性能优化

由于自动播放只需要简单的SQL查询（按position查找下一个），性能已经足够好：

```rust
// 静态播放列表: 单个索引查询
// CREATE INDEX idx_medias_playlist_position ON medias(playlist_id, position);

// 查询计划:
// Index Scan using idx_medias_playlist_position on medias
// Index Cond: (playlist_id = '...' AND position > 42)
// Limit: 1

// 时间复杂度: O(log N)
// 典型响应时间: < 1ms
```

**不需要缓存的原因**：
- ✅ 单次SQL查询，索引支持，性能优秀
- ✅ 不需要构建复杂的树结构
- ✅ 不需要跨目录遍历
- ✅ 内存占用小

### 4.4 房间设置

```rust
/// 房间自动连播设置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutoPlaySettings {
    /// 是否启用自动连播
    pub enabled: bool,

    /// 播放模式
    pub mode: PlayMode,

    /// 自动播放延迟 (秒)
    /// 视频播放完后等待多久再播放下一个
    pub delay: u32,
}

impl Default for AutoPlaySettings {
    fn default() -> Self {
        Self {
            enabled: true,
            mode: PlayMode::Sequential,
            delay: 3,  // 默认3秒延迟
        }
    }
}
```

### 4.5 自动播放流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                     视频播放完成事件                              │
└────────────────────────────┬────────────────────────────────────┘
                             │
                    ┌────────▼────────┐
                    │ 是否启用自动连播? │
                    └────────┬────────┘
                             │
                    ┌────────▼────────────────────┐
                    │ 加载当前Media和所属Playlist  │
                    └────────┬────────────────────┘
                             │
                    ┌────────▼────────┐
                    │ 判断播放列表类型 │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │                             │
    ┌─────────▼─────────────┐     ┌────────▼────────────┐
    │   静态播放列表         │     │    动态文件夹        │
    │(source_provider=NULL) │     │(source_provider!=NULL)│
    └─────────┬─────────────┘     └────────┬────────────┘
              │                             │
    ┌─────────▼─────────────┐     ┌────────▼────────────────┐
    │ SQL查询下一个Media     │     │ 调用Provider.next()     │
    │ - playlist_id相同      │     │ - 传递当前Media         │
    │ - position更大         │     │ - 传递播放模式          │
    │ - ORDER BY position   │     │ - Provider内部状态管理   │
    │ - 根据PlayMode        │     └────────┬────────────────┘
    └─────────┬─────────────┘              │
              │                   ┌─────────▼─────────────┐
              │                   │ 动态创建/更新Media记录 │
              │                   │ - 查找已有记录         │
              │                   │ - 创建新记录           │
              │                   │ - 更新元数据           │
              │                   └─────────┬─────────────┘
              │                             │
              └──────────────┬──────────────┘
                             │
                    ┌────────▼────────┐
                    │ 有下一个播放项?  │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │ YES                         │ NO
    ┌─────────▼──────────┐      ┌──────────▼──────────┐
    │ 广播倒计时消息       │      │ 广播播放列表结束消息  │
    │ - 显示下一个名称     │      │ - 停止播放           │
    │ - 倒计时N秒         │      └─────────────────────┘
    └─────────┬──────────┘
              │
    ┌─────────▼──────────┐
    │ 延迟N秒后切换       │
    │ - set_current_media│
    │ - 广播播放开始事件   │
    └────────────────────┘
```

### 4.6 播放完成事件处理(支持静态播放列表和动态文件夹)

```rust
/// 处理视频播放完成事件
///
/// 支持两种自动播放模式:
/// 1. 静态播放列表: 在当前playlist内按position查找下一个
/// 2. 动态文件夹: 调用Provider.next()动态获取下一项
pub async fn handle_video_ended(
    room: &Room,
    current_media_id: &str,  // nanoid(12)
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    // 1. 检查是否启用自动连播
    if !room.settings.auto_play.enabled {
        tracing::debug!("Auto play disabled for room {}", room.id);
        return Ok(());
    }

    // 2. 加载当前Media对象
    let current_media = sqlx::query_as!(
        Media,
        r#"
        SELECT id, playlist_id, room_id, creator_id, name, position,
               source_provider, source_config, metadata, provider_data,
               created_at, updated_at
        FROM medias
        WHERE id = $1
        "#,
        current_media_id
    )
    .fetch_one(db)
    .await?;

    // 3. 加载所属Playlist对象
    let playlist = sqlx::query_as!(
        Playlist,
        r#"
        SELECT id, room_id, creator_id, name, parent_id, position,
               source_provider, source_config, source_provider_backend,
               created_at, updated_at
        FROM playlists
        WHERE id = $1
        "#,
        current_media.playlist_id
    )
    .fetch_one(db)
    .await?;

    // 4. 判断是静态播放列表还是动态文件夹
    let next_item = if playlist.is_dynamic() {
        // 动态文件夹: 调用Provider.next()
        get_next_from_provider(
            &playlist,
            &current_media,
            room.settings.auto_play.mode,
            provider_registry,
            db,
        ).await?
    } else {
        // 静态播放列表: 在当前playlist内按position查找
        get_next_from_playlist(
            &current_media,
            room.settings.auto_play.mode,
            db,
        ).await?
    };

    // 5. 如果有下一个,延迟后自动播放
    if let Some(next_item) = next_item {
        let delay = Duration::from_secs(room.settings.auto_play.delay as u64);

        // 广播"即将播放下一个"事件(倒计时)
        room.broadcast_auto_play_countdown(
            &next_item.id,
            &next_item.name,
            room.settings.auto_play.delay,
        ).await?;

        tokio::time::sleep(delay).await;

        // 切换到下一个媒体文件
        room.set_current_media(&next_item.id).await?;

        // 广播自动播放开始事件
        room.broadcast_auto_play_started(&next_item.id).await?;

        tracing::info!(
            "Auto play: room={}, current={}, next={}",
            room.id,
            current_media_id,
            next_item.id
        );
    } else {
        tracing::info!("Playlist ended for room {}", room.id);

        // 广播播放列表结束事件
        room.broadcast_playlist_ended().await?;
    }

    Ok(())
}

/// 从动态文件夹Provider获取下一个播放项
async fn get_next_from_provider(
    playlist: &Playlist,
    current_media: &Media,
    mode: PlayMode,
    provider_registry: &MediaProviderRegistry,
    db: &DbPool,
) -> Result<Option<NextMediaItem>> {
    // 1. 获取Provider实例
    let source_provider = playlist.source_provider
        .as_ref()
        .ok_or(Error::NotDynamicFolder)?;

    let provider = provider_registry
        .get(source_provider)
        .ok_or(Error::ProviderNotFound)?;

    // 2. 检查Provider是否支持DynamicFolder
    let dynamic_folder = provider
        .as_dynamic_folder()
        .ok_or(Error::NotDynamicFolder)?;

    // 3. 构建Provider上下文
    let ctx = ProviderContext {
        backend: playlist.source_provider_backend.as_deref(),
        db,
    };

    // 4. 调用Provider.next()获取下一个播放项
    let next_play_item = dynamic_folder
        .next(&ctx, playlist, current_media, mode)
        .await?;

    // 5. 如果有下一个,创建或更新Media记录
    if let Some(next_item) = next_play_item {
        let media_id = create_or_update_media(
            playlist,
            &next_item,
            db,
        ).await?;

        Ok(Some(NextMediaItem {
            id: media_id,
            name: next_item.name,
        }))
    } else {
        Ok(None)
    }
}

/// 从静态播放列表获取下一个媒体文件
///
/// 只在当前playlist（文件夹）内查找，不跨目录
async fn get_next_from_playlist(
    current_media: &Media,
    mode: PlayMode,
    db: &DbPool,
) -> Result<Option<NextMediaItem>> {
    // 调用4.1节定义的查询函数
    let next_media = get_next_in_playlist(current_media, mode, db).await?;

    Ok(next_media.map(|media| NextMediaItem {
        id: media.id,
        name: media.name,
    }))
}

/// 创建或更新Media记录(用于动态文件夹)
///
/// 动态文件夹的内容可能不在数据库中,需要动态创建Media记录
async fn create_or_update_media(
    playlist: &Playlist,
    next_item: &NextPlayItem,
    db: &DbPool,
) -> Result<String> {
    // 1. 尝试根据source_config查找已有的Media记录
    //    (避免重复创建相同的媒体文件)
    let source_provider = playlist.source_provider
        .as_ref()
        .ok_or(Error::NotDynamicFolder)?;

    let existing = sqlx::query_scalar!(
        r#"
        SELECT id FROM medias
        WHERE playlist_id = $1
          AND source_provider = $2
          AND source_config = $3
        "#,
        playlist.id,
        source_provider.to_string(),
        next_item.source_config
    )
    .fetch_optional(db)
    .await?;

    if let Some(media_id) = existing {
        // 更新元数据(可能已过期)
        sqlx::query!(
            r#"
            UPDATE medias
            SET name = $1,
                metadata = $2,
                provider_data = $3,
                updated_at = NOW()
            WHERE id = $4
            "#,
            next_item.name,
            serde_json::to_value(&next_item.metadata)?,
            next_item.provider_data,
            media_id
        )
        .execute(db)
        .await?;

        Ok(media_id)
    } else {
        // 创建新的Media记录
        let media_id = nanoid::nanoid!(12);
        let source_provider = playlist.source_provider
            .as_ref()
            .ok_or(Error::NotDynamicFolder)?;

        sqlx::query!(
            r#"
            INSERT INTO medias (
                id, playlist_id, room_id, creator_id, name, position,
                source_provider, source_config,
                metadata, provider_data, created_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
            "#,
            media_id,
            playlist.id,
            playlist.room_id,
            playlist.creator_id,  // 使用playlist创建者作为media创建者
            next_item.name,
            0,  // position暂时为0(动态文件夹不需要严格的position)
            source_provider.to_string(),
            next_item.source_config,
            serde_json::to_value(&next_item.metadata)?,
            next_item.provider_data,
        )
        .execute(db)
        .await?;

        Ok(media_id)
    }
}

/// 下一个媒体项(简化版,仅包含ID和名称)
struct NextMediaItem {
    id: String,  // nanoid(12)
    name: String,
}
```

### 4.7 WebSocket 消息定义

服务端 → 客户端消息:

```javascript
// 自动播放倒计时(视频播放完成后)
{
  "type": "auto_play.countdown",
  "data": {
    "next_media_id": "abc123xyz456",  // nanoid(12)
    "next_media_name": "S01E02.mp4",
    "countdown": 3,
    "mode": "sequential"  // "sequential" | "repeat_one" | "repeat_all" | "shuffle"
  }
}

// 自动播放开始
{
  "type": "auto_play.started",
  "data": {
    "media_id": "550e8400-e29b-41d4-a716-446655440020"
  }
}

// 播放列表结束(Sequential模式)
{
  "type": "playlist.ended",
  "data": {}
}
```

客户端 → 服务端消息:

```javascript
// 取消自动播放(倒计时期间)
{
  "type": "auto_play.cancel",
  "data": {}
}
```

### 4.8 客户端实现要点

客户端需要实现自动连播相关UI和交互：

**接收自动播放事件**：

- 监听 `auto_play.countdown` 消息
- 提取 `next_media_id` 和 `countdown` 秒数

**倒计时UI**：

- 显示倒计时提示："{countdown}秒后自动播放下一个"
- 每秒更新倒计时数字
- 倒计时结束时清理UI

**取消功能**：

- 显示"取消自动播放"按钮
- 点击时发送 `cancel_auto_play` 消息到服务端
- 清除倒计时定时器

**状态管理**：

- 记录倒计时状态（是否正在倒计时）
- 管理倒计时定时器生命周期
- 处理多个快速切换的倒计时事件

---

## 5. 边界情况处理

### 5.1 播放列表为空

```rust
pub async fn handle_empty_playlist(room: &Room) -> Result<()> {
    tracing::warn!("Playlist empty for room {}", room.id);

    // 停止播放
    room.set_player_state(PlayerState {
        action: PlayerAction::Pause,
        position: 0.0,
        rate: 1.0,
    }).await?;

    // 广播播放列表为空事件
    room.broadcast_playlist_empty().await?;

    Ok(())
}
```

### 5.2 播放列表变更

```rust
/// 播放列表发生变更时 (添加/删除媒体文件)
pub async fn handle_playlist_changed(
    room: &Room,
    change_type: PlaylistChangeType,
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    match change_type {
        PlaylistChangeType::MediaAdded { media_id } => {
            // 添加媒体文件不影响当前播放
            tracing::debug!("Media {} added to room {}", media_id, room.id);
        }
        PlaylistChangeType::MediaRemoved { media_id } => {
            // 如果删除的是当前播放的媒体文件
            let current = room.get_current_media().await?;
            if current.id == media_id {
                // 自动播放下一个
                handle_video_ended(room, &media_id, db, provider_registry).await?;
            }
        }
        PlaylistChangeType::Reordered => {
            // 重新排序不影响当前播放，但会影响下一个播放项
            tracing::debug!("Playlist reordered in room {}", room.id);
        }
    }

    Ok(())
}
```

### 5.3 权限检查

**重要**: 自动连播是**房间设置**,不是用户权限。用户需要有 `SET_ROOM_SETTINGS` 权限才能修改自动连播配置。

```rust
/// 检查用户是否有权限修改自动连播设置
pub async fn can_modify_auto_play_settings(
    user: &User,
    room: &Room,
) -> Result<bool> {
    // 1. 全局管理员可以修改任何房间设置
    if user.role.is_admin_or_above() && user.status == UserStatus::Active {
        return Ok(true);
    }

    // 2. 获取用户在房间的成员信息
    let member = room.get_member(user.id).await
        .ok_or(Error::NotRoomMember)?;

    // 3. 检查成员状态
    if member.status != MemberStatus::Active {
        return Ok(false);
    }

    // 4. 检查是否有修改房间设置的权限
    Ok(member.has_permission(room, Permissions::SET_ROOM_SETTINGS))
}

/// 修改自动连播设置 API
#[axum::debug_handler]
pub async fn update_auto_play_settings(
    Extension(user): Extension<User>,
    Extension(room): Extension<Room>,
    Json(payload): Json<UpdateAutoPlayRequest>,
) -> Result<StatusCode> {
    // 1. 权限检查
    if !can_modify_auto_play_settings(&user, &room).await? {
        return Err(Error::PermissionDenied.into());
    }

    // 2. 更新房间设置
    room.settings.auto_play.enabled = payload.enabled;
    room.settings.auto_play.mode = payload.mode;
    room.settings.auto_play.delay = payload.delay;

    // 3. 保存到数据库
    room.save_settings().await?;

    // 4. 广播设置变更
    room.broadcast_settings_changed().await?;

    Ok(StatusCode::NO_CONTENT)
}

#[derive(Deserialize)]
pub struct UpdateAutoPlayRequest {
    pub enabled: bool,
    pub mode: PlayMode,
    pub delay: u32,
}
```

### 5.4 多副本同步

```rust
/// 自动连播状态存储到 Redis (多副本同步)
pub async fn save_auto_play_state(
    redis: &RedisPool,
    room_id: &str,
    state: &AutoPlayState,
) -> Result<()> {
    let key = format!("room:{}:auto_play", room_id);
    let value = serde_json::to_string(state)?;

    redis.set_ex(&key, value, 300).await?;

    // 发布变更通知
    redis.publish(
        "auto_play:changed",
        serde_json::to_string(state)?,
    ).await?;

    Ok(())
}

#[derive(Serialize, Deserialize)]
pub struct AutoPlayState {
    pub room_id: String,
    pub enabled: bool,
    pub mode: PlayMode,
    pub current_index: usize,
    pub next_index: Option<usize>,
    pub scheduled_at: Option<i64>,  // 预定播放时间
}
```

### 5.5 空播放列表

处理播放列表为空的情况：

```rust
/// 检查播放列表是否为空
async fn is_playlist_empty(playlist_id: &str, db: &DbPool) -> Result<bool> {
    let count = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM medias
        WHERE playlist_id = $1
        "#,
        playlist_id
    )
    .fetch_one(db)
    .await?;

    Ok(count == 0)
}
```

### 5.6 媒体文件被删除

监听媒体文件删除事件，如果是当前播放的文件则自动播放下一个：

```rust
/// 监听媒体文件被删除
pub async fn handle_media_removed(
    room: &Room,
    media_id: &str,  // nanoid(12)
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    // 如果删除的是当前播放的媒体文件
    let current = room.get_current_media().await?;

    if current.id == media_id {
        // 跳到下一个
        handle_video_ended(room, &current.id, db, provider_registry).await?;
    }

    Ok(())
}
```

### 5.7 视频提供方不可用

处理视频提供方错误(自动跳过):

```rust
/// 处理视频加载错误
pub async fn handle_video_load_error(
    room: &Room,
    media_id: &str,  // nanoid(12)
    error: &Error,
    db: &DbPool,
    provider_registry: &MediaProviderRegistry,
) -> Result<()> {
    match error {
        Error::ProviderUnavailable | Error::ProviderAuthFailed => {
            // 视频提供者不可用,跳过该媒体文件
            tracing::warn!(
                "Provider unavailable for media {}, skipping to next",
                media_id
            );

            // 自动播放下一个
            handle_video_ended(room, media_id, db, provider_registry).await?;
        }
        _ => {
            // 其他错误,停止播放
            room.broadcast_playback_error(error).await?;
        }
    }

    Ok(())
}
```

---

## 6. 目录支持

### 6.1 添加目录到播放列表 API

```http
POST /api/v1/rooms/{room_id}/playlists
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "name": "权力的游戏",                  // 目录名称
  "parent_id": null,                     // 父目录ID, null表示根目录
  "position": null                       // 可选：指定位置，null则自动计算
}

Response: 201 Created
{
  "code": 0,
  "message": "success",
  "data": {
    "id": "abc123xyz456",
    "room_id": "room_abc123",
    "creator_id": "user_abc123",
    "name": "权力的游戏",
    "parent_id": null,
    "position": 2,                       // 自动计算：父目录中最大playlist position + 1
    "created_at": "2024-01-15T11:30:00Z"
  }
}
```

**Position 自动计算逻辑**:

```rust
/// 添加 Playlist 时自动计算 position
async fn calculate_playlist_position(
    parent_id: Option<&str>,
    room_id: &str,
    db: &DbPool,
) -> Result<i32> {
    // 查找父目录中所有 playlist 的最大 position（包括静态和动态）
    let max_position = sqlx::query_scalar!(
        r#"
        SELECT COALESCE(MAX(position), -1) as "max_pos!"
        FROM playlists
        WHERE room_id = $1
          AND parent_id IS NOT DISTINCT FROM $2
        "#,
        room_id,
        parent_id
    )
    .fetch_one(db)
    .await?;

    Ok(max_position + 1)
}
```

### 6.2 从视频提供方导入目录 API

```http
POST /api/v1/rooms/{room_id}/playlists/import
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "source_type": "alist",               // 视频源类型
  "source_config": {                    // 源配置(包含路径等信息)
    "path": "/电视剧/权力的游戏"
  },
  "credential_source": "alist_main",    // 凭证来源
  "parent_id": null,                    // 父目录ID
  "recursive": true                     // 是否递归导入子目录
}

Response: 201 Created
{
  "code": 0,
  "message": "success",
  "data": {
    "playlist_id": "550e8400-e29b-41d4-a716-446655440020",
    "media_count": 16,
    "directory_count": 2
  }
}
```

### 6.3 添加媒体文件 API

```http
POST /api/v1/rooms/{room_id}/medias
Authorization: Bearer {token}
Content-Type: application/json

Request:
{
  "playlist_id": "abc123xyz456",         // 所属 playlist
  "name": "S01E01.mp4",
  "source_provider": "alist",
  "source_config": { "path": "/..." },
  "position": null                       // 可选：指定位置，null则自动计算
}

Response: 201 Created
{
  "code": 0,
  "message": "success",
  "data": {
    "id": "media_abc123",
    "playlist_id": "abc123xyz456",
    "room_id": "room_abc123",
    "creator_id": "user_abc123",
    "name": "S01E01.mp4",
    "position": 5,                       // 自动计算：playlist中最大media position + 1
    "source_provider": "alist",
    "created_at": "2024-01-15T11:30:00Z"
  }
}
```

**Position 自动计算逻辑**:

```rust
/// 添加 Media 时自动计算 position
async fn calculate_media_position(
    playlist_id: &str,
    db: &DbPool,
) -> Result<i32> {
    // 查找当前 playlist 中所有 media 的最大 position
    let max_position = sqlx::query_scalar!(
        r#"
        SELECT COALESCE(MAX(position), -1) as "max_pos!"
        FROM medias
        WHERE playlist_id = $1
        "#,
        playlist_id
    )
    .fetch_one(db)
    .await?;

    Ok(max_position + 1)
}
```

### 6.4 列出播放列表内容 API

```http
GET /api/v1/rooms/{room_id}/playlists/{playlist_id}/items
Authorization: Bearer {token}

Query Parameters:
- type: 可选，过滤类型 ("playlist" | "media" | "all")，默认 "all"
- page: 页码，默认 1
- page_size: 每页数量，默认 50

Response: 200 OK
{
  "code": 0,
  "message": "success",
  "data": {
    "items": [
      // 先列出所有子 playlist（文件夹）
      {
        "type": "playlist",
        "id": "playlist_001",
        "name": "第一季",
        "position": 0,
        "item_count": 10,             // 该文件夹内的项目数
        "is_dynamic": false
      },
      {
        "type": "playlist",
        "id": "playlist_002",
        "name": "第二季",
        "position": 1,
        "item_count": 8,
        "is_dynamic": false
      },
      // 然后列出所有 media（媒体文件）
      {
        "type": "media",
        "id": "media_001",
        "name": "特别篇.mp4",
        "position": 0,
        "duration": 3600,
        "source_provider": "alist"
      },
      {
        "type": "media",
        "id": "media_002",
        "name": "幕后花絮.mp4",
        "position": 1,
        "duration": 1800,
        "source_provider": "direct_url"
      }
    ],
    "total": 4,
    "page": 1,
    "page_size": 50
  }
}
```

**查询逻辑**:

```rust
/// 列出播放列表内容
///
/// 排序规则：
/// 1. 先列出所有 playlist（按 position 排序）
/// 2. 再列出所有 media（按 position 排序）
async fn list_playlist_items(
    room_id: &str,
    playlist_id: Option<&str>,  // None 表示根目录
    item_type: Option<ItemType>,  // None | Some(Playlist) | Some(Media)
    page: usize,
    page_size: usize,
    db: &DbPool,
) -> Result<Vec<PlaylistItem>> {
    let offset = (page - 1) * page_size;

    match item_type {
        // 只查询 playlist（包括静态和动态）
        Some(ItemType::Playlist) => {
            sqlx::query_as!(
                PlaylistItem,
                r#"
                SELECT 'playlist' as type, id, name, position, created_at
                FROM playlists
                WHERE room_id = $1
                  AND parent_id IS NOT DISTINCT FROM $2
                ORDER BY position ASC
                LIMIT $3 OFFSET $4
                "#,
                room_id,
                playlist_id,
                page_size as i64,
                offset as i64
            )
            .fetch_all(db)
            .await
        }

        // 只查询 media
        Some(ItemType::Media) => {
            sqlx::query_as!(
                PlaylistItem,
                r#"
                SELECT 'media' as type, id, name, position, created_at
                FROM medias
                WHERE room_id = $1
                  AND playlist_id IS NOT DISTINCT FROM $2
                ORDER BY position ASC
                LIMIT $3 OFFSET $4
                "#,
                room_id,
                playlist_id,
                page_size as i64,
                offset as i64
            )
            .fetch_all(db)
            .await
        }

        // 查询全部：先 playlist 后 media
        None => {
            // 使用 UNION ALL 合并结果，按类型和 position 排序
            sqlx::query_as!(
                PlaylistItem,
                r#"
                SELECT * FROM (
                    -- 子 playlist（文件夹，包括静态和动态）
                    SELECT
                        'playlist' as type,
                        id,
                        name,
                        position,
                        0 as type_order,  -- playlist 排在前面
                        created_at
                    FROM playlists
                    WHERE room_id = $1
                      AND parent_id IS NOT DISTINCT FROM $2

                    UNION ALL

                    -- media（媒体文件）
                    SELECT
                        'media' as type,
                        id,
                        name,
                        position,
                        1 as type_order,  -- media 排在后面
                        created_at
                    FROM medias
                    WHERE room_id = $1
                      AND playlist_id IS NOT DISTINCT FROM $2
                ) items
                ORDER BY type_order ASC, position ASC
                LIMIT $3 OFFSET $4
                "#,
                room_id,
                playlist_id,
                page_size as i64,
                offset as i64
            )
            .fetch_all(db)
            .await
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ItemType {
    Playlist,
    Media,
}
```

### 6.5 预览下一个媒体文件 API

```http
GET /api/v1/rooms/{room_id}/medias/{media_id}/next?mode=sequential
Authorization: Bearer {token}

Query Parameters:
- mode: 播放模式 (sequential|repeat_one|repeat_all|shuffle)

Response: 200 OK
{
  "code": 0,
  "message": "success",
  "data": {
    "next_media": {
      "id": "550e8400-e29b-41d4-a716-446655440022",
      "name": "S01E02.mp4",
      "playlist_id": "550e8400-e29b-41d4-a716-446655440020",
      "source_type": "alist",
      "source_config": { "path": "/电视剧/权力的游戏/第一季/S01E02.mp4" }
    },
    "will_loop": false,           // RepeatAll模式下如果循环回第一个
    "playlist_ended": false       // Sequential模式下如果到达末尾
  }
}
```

---

## 总结

本章节设计了一个**简洁、高效、支持静态播放列表和动态文件夹**的自动连播系统:

✅ **多种播放模式**: 顺序、单曲循环、列表循环、随机
✅ **静态播放列表**: SQL查询,在当前playlist内按position顺序播放
✅ **动态文件夹**: Provider.next()接口,支持Alist目录、Emby播放列表
✅ **统一处理**: 自动检测播放列表类型,选择合适的算法
✅ **用户体验**: 倒计时提示、可取消、无缝切换
✅ **房间级配置**: 自动连播是房间设置,由拥有 `SET_ROOM_SETTINGS` 权限的用户配置
✅ **性能优化**: 索引优化的SQL查询,响应时间<1ms
✅ **边界情况**: 空列表、媒体删除、视频提供方不可用
✅ **多副本同步**: Redis 存储自动连播状态

关键设计:

- ❌ 自动连播不是用户权限
- ✅ 自动连播是房间设置 (RoomSettings.auto_play)
- ✅ 修改自动连播配置需要 `SET_ROOM_SETTINGS` 权限
- ✅ 自动连播触发是基于房间配置,不需要用户操作
- ✅ **只在当前playlist（文件夹）内自动播放，不跨目录**
- ✅ 静态播放列表使用简单SQL查询(按position顺序)
- ✅ 动态文件夹使用 DynamicFolder trait 的 next() 方法
- ✅ 动态文件夹内容按需创建/更新Media记录,不预先加载
- ✅ Provider内部维护状态(分页、索引等),支持大型目录

核心改进:

**播放列表类型区分**:
- 静态播放列表: source_provider为NULL,内容预先添加到数据库
- 动态文件夹: source_provider不为NULL(如"alist"、"emby"),内容动态获取

**自动播放算法**:
- 静态: SQL查询 `WHERE playlist_id=$1 AND position>$2 ORDER BY position LIMIT 1`
- 动态: Provider.next() → Provider内部逻辑(目录列表、自然排序、分页等)

**Media记录管理**:
- 静态: 提前创建所有Media记录
- 动态: 播放时按需创建/更新Media记录(create_or_update_media)

**数据库设计**:
- `playlists` 表: 同时支持静态目录和动态文件夹
  - source_provider=NULL: 静态目录
  - source_provider!=NULL: 动态文件夹(Alist/Emby)
  - source_provider_backend: 凭证后端标识
  - position: 在父目录中的排序位置（自动计算或手动指定）
- `medias` 表: 存储媒体文件节点
  - 静态播放列表: 预先创建
  - 动态文件夹: 首次播放时创建,根据source_config去重
  - provider_data: Provider内部状态(分页、索引等)
  - position: 在当前playlist中的排序位置（自动计算或手动指定）

**Position 管理规则**:
- Playlist 和 Media 的 position 独立管理
- 添加时自动计算：未指定则为最大position+1
- 列表显示：先显示所有 playlist，再显示所有 media
- API 支持过滤：可选只显示 playlist 或只显示 media

**Provider接口**:
- `MediaProvider::as_dynamic_folder()`: 判断是否支持动态文件夹
- `DynamicFolder::next()`: 获取下一个播放项(返回NextPlayItem)
- `DynamicFolder::list_directory()`: 列出目录内容(用于手动浏览)

**上一章**: [12-时间同步与补偿](./12-时间同步与补偿.md)
**下一章**: [14-通信架构设计](./18-API文档生成方案.md)
