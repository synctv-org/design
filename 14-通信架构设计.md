# 08. 通信架构设计

---

## 8.0 架构概览

### 8.0.1 设计目标

**核心原则**：

- 主要业务逻辑在 gRPC 中实现
- 同时支持多种客户端协议
- 最小化重复代码
- 自动生成 API 文档

**支持的协议**：

```
┌─────────────────────────────────────────────────┐
│  客户端                                          │
├─────────────────────────────────────────────────┤
│  • Native App        → gRPC (Protobuf)         │
│  • Web Browser       → gRPC-Web (Protobuf)     │
│  • HTTP Client       → HTTP/JSON               │
│  • Admin Dashboard   → HTTP/JSON               │
└────────────┬────────────────────────────────────┘
             │
       单一端口 :8080
             │
   ┌─────────▼──────────┐
   │  SyncTV Server     │
   │  (Rust)            │
   ├────────────────────┤
   │ 1. gRPC Services   │ ← 核心业务逻辑 (tonic)
   │ 2. gRPC-Web Layer  │ ← 浏览器支持 (tonic-web)
   │ 3. HTTP/JSON Layer │ ← REST API (axum)
   │ 4. API Docs        │ ← OpenAPI (utoipa)
   └────────────────────┘
```

### 8.0.2 技术栈

| 组件 | 技术 | 用途 |
|-----|------|-----|
| gRPC 框架 | tonic | gRPC 服务器和客户端 |
| HTTP 框架 | axum | HTTP/JSON API |
| gRPC-Web | tonic-web | 浏览器支持 |
| API 文档 | utoipa | OpenAPI/Swagger |
| 代码生成 | tonic-build | Protobuf 编译 |
| 序列化 | prost | Protobuf 序列化 |

---

## 8.1 三层架构

### 8.1.1 第一层：gRPC 服务（核心）

所有业务逻辑在 gRPC 服务中实现：

```rust
// proto/client.proto
service ClientService {
  // 用户认证
  rpc Login(LoginRequest) returns (LoginResponse);
  rpc Register(RegisterRequest) returns (RegisterResponse);

  // 房间管理
  rpc CreateRoom(CreateRoomRequest) returns (CreateRoomResponse);
  rpc JoinRoom(JoinRoomRequest) returns (JoinRoomResponse);

  // 实时消息流
  rpc MessageStream(stream ClientMessage) returns (stream ServerMessage);
}
```

**实现**：

```rust
// grpc/client.rs
#[tonic::async_trait]
impl ClientService for ClientServiceImpl {
    async fn login(
        &self,
        request: Request<LoginRequest>,
    ) -> Result<Response<LoginResponse>, Status> {
        let req = request.into_inner();

        // 核心业务逻辑
        let (user, tokens) = self.user_service
            .authenticate(&req.username, &req.password)
            .await
            .map_err(|e| Status::unauthenticated(e.to_string()))?;

        Ok(Response::new(LoginResponse {
            user: Some(user.into()),
            access_token: tokens.access_token,
            refresh_token: tokens.refresh_token,
            expires_in: tokens.expires_in,
        }))
    }

    // ... 其他方法
}
```

### 8.1.2 第二层：gRPC-Web（浏览器支持）

使用 tonic-web 让浏览器可以直接调用 gRPC：

```rust
use tonic_web::GrpcWebLayer;

Server::builder()
    .accept_http1(true)
    .layer(GrpcWebLayer::new())  // 添加 gRPC-Web 支持
    .add_service(ClientServiceServer::new(client_impl))
    .serve(addr)
    .await?;
```

**浏览器客户端**：

```javascript
import { ClientServiceClient } from './generated/client_grpc_web_pb';

const client = new ClientServiceClient('http://localhost:8080', null, null);

// 直接调用 gRPC
const response = await client.login({
  username: 'alice',
  password: 'secret'
});

console.log('Token:', response.getAccessToken());
```

**特点**：

- ✅ 浏览器可以直接调用 gRPC
- ✅ 使用 Protobuf（比 JSON 小 30-50%）
- ✅ 类型安全
- ⚠️ 需要客户端使用 grpc-web 库

### 8.1.3 第三层：HTTP/JSON API（兼容性）

为不支持 gRPC 的客户端提供 HTTP/JSON API：

#### 方案 A：手动包装（完全控制）

```rust
// http/handlers.rs

/// HTTP Login Handler
#[utoipa::path(
    post,
    path = "/api/v1/auth/login",
    request_body = LoginRequest,
    responses(
        (status = 200, description = "Login successful", body = LoginResponse),
        (status = 401, description = "Invalid credentials")
    ),
    tag = "Authentication"
)]
async fn http_login(
    Json(req): Json<LoginRequest>,
    State(service): State<Arc<ClientServiceImpl>>,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    // 调用 gRPC 服务的业务逻辑
    let result = service.user_service
        .authenticate(&req.username, &req.password)
        .await
        .map_err(|e| (
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "authentication_failed".into(),
                message: e.to_string(),
            })
        ))?;

    Ok(Json(LoginResponse {
        user: Some(result.0.into()),
        access_token: result.1.access_token,
        refresh_token: result.1.refresh_token,
        expires_in: result.1.expires_in,
    }))
}
```

**注册路由**：

```rust
let grpc_router = Server::builder()
    .add_service(client_service)
    .into_router();

let http_router = Router::new()
    .route("/api/v1/auth/login", post(http_login))
    .route("/api/v1/auth/register", post(http_register))
    .route("/api/v1/rooms", post(http_create_room))
    .route("/api/v1/rooms/:id", get(http_get_room))
    .with_state(app_state);

// 合并
let app = grpc_router
    .into_axum_router()
    .merge(http_router);

Server::builder()
    .accept_http1(true)
    .add_routes(app.into())
    .serve(addr)
    .await?;
```

#### 方案 B：宏简化（减少重复）

```rust
// 定义宏自动生成 HTTP handler
macro_rules! grpc_http_bridge {
    (
        $service:ty,
        $method:ident,
        $request:ty,
        $response:ty,
        $path:expr,
        $http_method:ident
    ) => {
        #[utoipa::path(
            $http_method,
            path = $path,
            request_body = $request,
            responses(
                (status = 200, body = $response)
            )
        )]
        async fn paste::paste! { [<http_ $method>] } (
            Json(req): Json<$request>,
            State(service): State<Arc<$service>>,
        ) -> Result<Json<$response>, StatusCode> {
            let grpc_req = Request::new(req);
            let result = service.$method(grpc_req)
                .await
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
                .into_inner();
            Ok(Json(result))
        }
    };
}

// 使用宏
grpc_http_bridge!(
    ClientServiceImpl,
    login,
    LoginRequest,
    LoginResponse,
    "/api/v1/auth/login",
    post
);

grpc_http_bridge!(
    ClientServiceImpl,
    create_room,
    CreateRoomRequest,
    CreateRoomResponse,
    "/api/v1/rooms",
    post
);
```

#### 方案 C：代码生成（最自动化）

创建 build script 自动生成 HTTP handlers：

```rust
// build.rs
fn main() {
    // 1. 编译 protobuf
    tonic_build::configure()
        .build_server(true)
        .compile(&["proto/client.proto"], &["proto"])
        .unwrap();

    // 2. 生成 HTTP bridge 代码
    generate_http_bridge("proto/client.proto", "src/http/generated.rs");
}

fn generate_http_bridge(proto_file: &str, output: &str) {
    // 解析 proto 文件
    // 为每个 rpc 方法生成对应的 HTTP handler
    // 生成 utoipa 注解
}
```

**生成的代码**：

```rust
// src/http/generated.rs (自动生成)

#[utoipa::path(post, path = "/api/v1/auth/login")]
pub async fn http_login(
    Json(req): Json<LoginRequest>,
    State(service): State<Arc<ClientServiceImpl>>,
) -> Result<Json<LoginResponse>, StatusCode> {
    let result = service.login(Request::new(req)).await?;
    Ok(Json(result.into_inner()))
}

// ... 其他方法
```

---

## 8.2 API 文档生成

### 8.2.1 HTTP API 文档（utoipa）

```rust
use utoipa::OpenApi;

#[derive(OpenApi)]
#[openapi(
    paths(
        http_login,
        http_register,
        http_create_room,
        http_get_room,
    ),
    components(
        schemas(
            LoginRequest,
            LoginResponse,
            RegisterRequest,
            RegisterResponse,
            CreateRoomRequest,
            CreateRoomResponse,
            User,
            Room,
            ErrorResponse,
        )
    ),
    tags(
        (name = "Authentication", description = "User authentication endpoints"),
        (name = "Rooms", description = "Room management endpoints"),
    ),
    info(
        title = "SyncTV API",
        version = "1.0.0",
        description = "SyncTV Sync Watching Platform API",
        license(name = "MIT"),
    )
)]
struct ApiDoc;

// 提供 Swagger UI
async fn serve_swagger() -> impl IntoResponse {
    Html(SwaggerUi::new("/api/docs").url("/api/openapi.json", ApiDoc::openapi()))
}

let app = Router::new()
    .route("/api/docs", get(serve_swagger))
    .route("/api/openapi.json", get(|| async {
        Json(ApiDoc::openapi())
    }));
```

**访问文档**：

- Swagger UI: <http://localhost:8080/api/docs>
- OpenAPI JSON: <http://localhost:8080/api/openapi.json>

### 8.2.2 gRPC API 文档（Server Reflection）

```rust
use tonic_reflection::server::Builder as ReflectionBuilder;

// 启用 gRPC Server Reflection
let reflection = ReflectionBuilder::configure()
    .register_encoded_file_descriptor_set(proto::FILE_DESCRIPTOR_SET)
    .build()
    .unwrap();

Server::builder()
    .add_service(reflection)  // 添加 reflection 服务
    .add_service(client_service)
    .serve(addr)
    .await?;
```

**使用工具查看 gRPC API**：

```bash
# grpcurl (命令行工具)
grpcurl -plaintext localhost:8080 list
grpcurl -plaintext localhost:8080 describe synctv.client.ClientService

# grpcui (Web UI)
grpcui -plaintext localhost:8080
```

### 8.2.3 Protobuf 文档生成

使用 protoc-gen-doc 生成 Markdown/HTML 文档：

```bash
# 安装
go install github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc@latest

# 生成文档
protoc --doc_out=./docs --doc_opt=markdown,api.md proto/*.proto
```

**生成的文档示例**：

```markdown
# SyncTV API Reference

## ClientService

### Login
Authenticates a user and returns access tokens.

**Request:**
```protobuf
message LoginRequest {
  string username = 1;
  string password = 2;
}
```

**Response:**

```protobuf
message LoginResponse {
  User user = 1;
  string access_token = 2;
  string refresh_token = 3;
  int64 expires_in = 4;
}
```

```

---

## 8.3 协议选择指南

### 8.3.1 客户端选择

| 客户端类型 | 推荐协议 | 原因 |
|-----------|---------|------|
| **Native App (iOS/Android)** | gRPC | 性能最优，类型安全 |
| **Web Browser (SPA)** | gRPC-Web | 直接调用，性能好 |
| **Legacy HTTP Client** | HTTP/JSON | 兼容性 |
| **第三方集成** | HTTP/JSON | 文档完善，易集成 |
| **Admin Dashboard** | HTTP/JSON | 简单，易调试 |
| **内部微服务** | gRPC | 性能最优 |

### 8.3.2 性能对比

**消息大小**（同样的数据）：
- gRPC (Protobuf): 100 bytes
- gRPC-Web (Protobuf): 100 bytes
- HTTP/JSON: 250 bytes

**延迟**（本地测试）：
- gRPC: 1-2ms
- gRPC-Web: 2-3ms
- HTTP/JSON: 2-4ms

---

## 8.4 完整示例

### 8.4.1 启动服务器

```rust
// main.rs
#[tokio::main]
async fn main() -> Result<()> {
    let addr = "0.0.0.0:8080".parse()?;

    // 1. 创建 gRPC 服务
    let client_service = ClientServiceServer::new(ClientServiceImpl::new(...));
    let cluster_service = ClusterServiceServer::new(ClusterServiceImpl::new(...));

    // 2. 创建 gRPC reflection (用于文档)
    let reflection = tonic_reflection::server::Builder::configure()
        .register_encoded_file_descriptor_set(proto::FILE_DESCRIPTOR_SET)
        .build()?;

    // 3. 创建 gRPC 路由
    let grpc_router = Server::builder()
        .layer(GrpcWebLayer::new())  // gRPC-Web 支持
        .add_service(reflection)
        .add_service(client_service)
        .add_service(cluster_service)
        .into_router();

    // 4. 创建 HTTP 路由
    let http_router = Router::new()
        // 认证
        .route("/api/v1/auth/login", post(http_login))
        .route("/api/v1/auth/register", post(http_register))
        // 房间
        .route("/api/v1/rooms", post(http_create_room))
        .route("/api/v1/rooms/:id", get(http_get_room))
        // 文档
        .route("/api/docs", get(serve_swagger_ui))
        .route("/api/openapi.json", get(serve_openapi_spec))
        // 健康检查
        .route("/health", get(health_check))
        .route("/metrics", get(prometheus_metrics))
        .with_state(app_state);

    // 5. 合并并启动
    let app = grpc_router
        .into_axum_router()
        .merge(http_router);

    tracing::info!("Server listening on {}", addr);
    tracing::info!("gRPC endpoint: grpc://{}", addr);
    tracing::info!("gRPC-Web endpoint: http://{}", addr);
    tracing::info!("HTTP API: http://{}/api/v1", addr);
    tracing::info!("API Docs: http://{}/api/docs", addr);

    Server::builder()
        .accept_http1(true)
        .add_routes(app.into())
        .serve(addr)
        .await?;

    Ok(())
}
```

---

## 8.5 推荐实施策略

### 阶段 1：核心 gRPC（Week 1-2）

- ✅ 实现所有 gRPC 服务
- ✅ 添加 gRPC-Web 支持
- ✅ 启用 Server Reflection

### 阶段 2：关键 HTTP API（Week 3）

- ✅ 手动实现常用接口的 HTTP 版本
  - 登录/注册
  - 房间创建/加入
  - 基本查询
- ✅ 添加 utoipa 注解

### 阶段 3：自动化（Week 4）

- ✅ 开发宏或代码生成工具
- ✅ 自动生成剩余 HTTP handlers
- ✅ 生成完整 OpenAPI 文档

### 阶段 4：文档完善（Week 5）

- ✅ Swagger UI 集成
- ✅ Protobuf 文档生成
- ✅ 示例代码和教程

---

## 8.6 维护建议

### 单一真理来源

```
Proto 文件 (*.proto)
    ↓
    ├─→ gRPC 服务 (自动生成)
    ├─→ HTTP handlers (手动/宏/生成)
    ├─→ 客户端代码 (自动生成)
    └─→ API 文档 (自动生成)
```

### 开发流程

1. 修改 proto 文件
2. 运行 `cargo build` (自动生成 gRPC 代码)
3. 更新/生成 HTTP handlers
4. 测试两种协议
5. 更新文档

### 测试策略

```rust
#[cfg(test)]
mod tests {
    // 测试 gRPC
    #[tokio::test]
    async fn test_grpc_login() {
        let mut client = ClientServiceClient::connect(...).await.unwrap();
        let response = client.login(...).await.unwrap();
        assert!(response.into_inner().access_token.len() > 0);
    }

    // 测试 HTTP（应该得到相同结果）
    #[tokio::test]
    async fn test_http_login() {
        let response = reqwest::post("http://localhost:8080/api/v1/auth/login")
            .json(&LoginRequest { ... })
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), 200);
    }
}
```

---

**上一章**: [13-自动连播设计](./11-实时互动.md)
**下一章**: [15-API接口定义](./15-API接口定义.md)
