# 10. 实时消息流 (gRPC Streaming)

---

## 10.0 协议选择：gRPC Streaming vs WebSocket

### 10.0.1 设计决策

**使用 gRPC bidirectional streaming 替代传统 WebSocket**：

**gRPC Streaming 优势**：

- ✅ **类型安全**: Protobuf 自动生成类型定义，编译期检查
- ✅ **性能更优**: 二进制编码，比 JSON 更紧凑高效
- ✅ **自动流控**: HTTP/2 内置流控机制
- ✅ **多路复用**: 单连接支持多个并发流
- ✅ **自动重连**: tonic 客户端库自动处理断线重连
- ✅ **元数据支持**: gRPC metadata 用于认证和追踪

**与 WebSocket 对比**：

| 特性 | gRPC Streaming | WebSocket |
|-----|----------------|-----------|
| 编码格式 | Protobuf (二进制) | JSON (文本) |
| 类型安全 | ✅ 编译期检查 | ❌ 运行时解析 |
| 流控 | ✅ HTTP/2 内置 | ❌ 手动实现 |
| 重连 | ✅ 自动 | ❌ 手动实现 |
| 多路复用 | ✅ 原生支持 | ❌ 单一连接 |
| 认证 | ✅ Metadata/Interceptor | ⚠️ 首次握手 |
| 代码生成 | ✅ tonic-build | ❌ 手动定义 |

### 10.0.2 架构设计

```
┌─────────────────────────────────────────────────────────┐
│  客户端 gRPC Streaming 连接                              │
├─────────────────────────────────────────────────────────┤
│  Client A → Node-1 (ClientService.MessageStream)       │
│  Client B → Node-2 (ClientService.MessageStream)       │
│  Client C → Node-1 (ClientService.MessageStream)       │
│  Client D → Node-3 (ClientService.MessageStream)       │
└─────────────────────────────────────────────────────────┘
                    │
                    │ 消息流转 (Protobuf)
                    ▼
┌─────────────────────────────────────────────────────────┐
│  Redis Pub/Sub (消息总线)                               │
├─────────────────────────────────────────────────────────┤
│  频道: room:{room_id}:messages                          │
│  - Client A 发送消息 → Node-1 → Redis PUBLISH          │
│  - Redis 广播到所有订阅该房间的节点                     │
│  - Node-1, Node-2, Node-3 接收消息                     │
│  - 各节点推送到本地的 gRPC streaming 客户端             │
└─────────────────────────────────────────────────────────┘
```

**关键点**：

- 客户端通过 `ClientService.MessageStream` RPC 建立双向流
- 服务端通过 Redis Pub/Sub 实现跨节点消息分发
- 单个客户端连接可以同时接收和发送消息

### 10.0.3 Protobuf 消息定义

```protobuf
syntax = "proto3";

package synctv.client;

// 客户端服务
service ClientService {
  // 实时消息流（双向流）
  rpc MessageStream(stream ClientMessage) returns (stream ServerMessage);
}

// 客户端发送的消息
message ClientMessage {
  string message_id = 1;
  int64 timestamp = 2;

  oneof payload {
    PingMessage ping = 10;
    JoinRoomMessage join_room = 11;
    LeaveRoomMessage leave_room = 12;
    ChatMessage chat = 13;
    DanmakuMessage danmaku = 14;
    PlayControlMessage play_control = 15;
  }
}

// 服务端推送的消息
message ServerMessage {
  string message_id = 1;
  int64 timestamp = 2;

  oneof payload {
    PongMessage pong = 10;
    RoomStateUpdate room_state = 11;
    ChatBroadcast chat = 12;
    DanmakuBroadcast danmaku = 13;
    MemberUpdate member = 14;
    PlayStatusUpdate play_status = 15;
    ErrorMessage error = 16;
  }
}

message JoinRoomMessage {
  string room_id = 1;
  string password = 2;  // 可选
}

message ChatMessage {
  string room_id = 1;
  string content = 2;
}

message ChatBroadcast {
  string room_id = 1;
  string user_id = 2;
  string username = 3;
  string content = 4;
  int64 timestamp = 5;
}
```

### 10.0.4 服务端实现

```rust
use tonic::{Request, Response, Status};
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;

pub struct MyClientService {
    room_hub: Arc<RoomMessageHub>,
    redis_client: Arc<redis::Client>,
}

#[tonic::async_trait]
impl ClientService for MyClientService {
    type MessageStreamStream = ReceiverStream<Result<ServerMessage, Status>>;

    async fn message_stream(
        &self,
        request: Request<tonic::Streaming<ClientMessage>>,
    ) -> Result<Response<Self::MessageStreamStream>, Status> {
        // 1. 验证认证token
        let metadata = request.metadata();
        let token = metadata
            .get("authorization")
            .and_then(|v| v.to_str().ok())
            .ok_or_else(|| Status::unauthenticated("Missing token"))?;

        let user_id = verify_jwt_token(token)
            .map_err(|_| Status::unauthenticated("Invalid token"))?;

        // 2. 创建双向通道
        let mut client_stream = request.into_inner();
        let (tx, rx) = mpsc::channel(100);

        let room_hub = self.room_hub.clone();
        let redis_client = self.redis_client.clone();

        // 3. 启动消息处理任务
        tokio::spawn(async move {
            let mut current_room: Option<String> = None;
            let client_id = Uuid::new_v4().to_string();

            while let Some(result) = client_stream.message().await? {
                let msg = result?;

                match msg.payload {
                    Some(client_message::Payload::Ping(ping)) => {
                        // 处理心跳
                        let pong = ServerMessage {
                            message_id: Uuid::new_v4().to_string(),
                            timestamp: Utc::now().timestamp_millis(),
                            payload: Some(server_message::Payload::Pong(PongMessage {
                                client_time: ping.client_time,
                                server_time: Utc::now().timestamp_millis(),
                            })),
                        };
                        tx.send(Ok(pong)).await?;
                    }
                    Some(client_message::Payload::JoinRoom(join)) => {
                        // 加入房间
                        current_room = Some(join.room_id.clone());

                        // 注册到房间订阅
                        room_hub.join_room(
                            join.room_id.clone(),
                            client_id.clone(),
                            user_id,
                            tx.clone(),
                        ).await?;

                        // 发送加入成功消息
                        let msg = ServerMessage {
                            message_id: Uuid::new_v4().to_string(),
                            timestamp: Utc::now().timestamp_millis(),
                            payload: Some(server_message::Payload::RoomState(
                                get_room_state(&join.room_id).await?
                            )),
                        };
                        tx.send(Ok(msg)).await?;
                    }
                    Some(client_message::Payload::Chat(chat)) => {
                        // 处理聊天消息
                        let broadcast = ChatBroadcast {
                            room_id: chat.room_id.clone(),
                            user_id: user_id.to_string(),
                            username: get_username(user_id).await?,
                            content: chat.content,
                            timestamp: Utc::now().timestamp_millis(),
                        };

                        // 发布到 Redis
                        let msg_json = serde_json::to_string(&broadcast)?;
                        publish_to_redis(&redis_client, &chat.room_id, msg_json).await?;
                    }
                    _ => {}
                }
            }

            // 清理：离开房间
            if let Some(room_id) = current_room {
                room_hub.leave_room(&room_id, &client_id).await?;
            }

            Ok::<_, anyhow::Error>(())
        });

        Ok(Response::new(ReceiverStream::new(rx)))
    }
}
```

### 10.0.5 房间消息管理器

```rust
// 房间消息管理器（集成 Redis Pub/Sub）
pub struct RoomMessageHub {
    redis_client: Arc<redis::Client>,
    // room_id -> 订阅句柄
    subscriptions: Arc<DashMap<String, Arc<RoomSubscription>>>,
}

pub struct RoomSubscription {
    room_id: String,
    // client_id -> (user_id, sender)
    clients: Arc<DashMap<String, (Uuid, mpsc::Sender<Result<ServerMessage, Status>>)>>,
    // Redis 订阅
    redis_sub: Arc<Mutex<redis::aio::PubSub>>,
}

impl RoomMessageHub {
    /// 客户端加入房间
    pub async fn join_room(
        &self,
        room_id: String,
        client_id: String,
        user_id: Uuid,
        sender: mpsc::Sender<Result<ServerMessage, Status>>,
    ) -> Result<()> {
        // 1. 获取或创建房间订阅
        let subscription = self.get_or_create_subscription(&room_id).await?;

        // 2. 添加客户端到本地列表
        subscription.clients.insert(client_id, (user_id, sender));

        Ok(())
    }

    /// 获取或创建房间订阅
    async fn get_or_create_subscription(
        &self,
        room_id: &str,
    ) -> Result<Arc<RoomSubscription>> {
        if let Some(sub) = self.subscriptions.get(room_id) {
            return Ok(sub.clone());
        }

        // 创建 Redis 订阅
        let mut conn = self.redis_client.get_async_connection().await?;
        let mut pubsub = conn.into_pubsub();
        let channel = format!("room:{}:messages", room_id);
        pubsub.subscribe(&channel).await?;

        let subscription = Arc::new(RoomSubscription {
            room_id: room_id.to_string(),
            clients: Arc::new(DashMap::new()),
            redis_sub: Arc::new(Mutex::new(pubsub)),
        });

        // 启动消息分发任务
        let sub_clone = subscription.clone();
        tokio::spawn(async move {
            sub_clone.start_distribution().await;
        });

        self.subscriptions.insert(room_id.to_string(), subscription.clone());

        Ok(subscription)
    }
}

impl RoomSubscription {
    /// 启动 Redis → gRPC streaming 消息分发
    async fn start_distribution(&self) {
        let mut pubsub = self.redis_sub.lock().await;

        loop {
            match pubsub.on_message().next().await {
                Some(msg) => {
                    let payload: String = match msg.get_payload() {
                        Ok(p) => p,
                        Err(e) => {
                            error!("Failed to get payload: {}", e);
                            continue;
                        }
                    };

                    // 解析为 ServerMessage
                    let server_msg: ServerMessage = match serde_json::from_str(&payload) {
                        Ok(m) => m,
                        Err(e) => {
                            error!("Failed to parse message: {}", e);
                            continue;
                        }
                    };

                    // 分发到本地所有客户端的 gRPC stream
                    let mut disconnected = Vec::new();
                    for entry in self.clients.iter() {
                        let client_id = entry.key();
                        let (_, sender) = entry.value();

                        if sender.send(Ok(server_msg.clone())).await.is_err() {
                            disconnected.push(client_id.clone());
                        }
                    }

                    // 清理断开的客户端
                    for client_id in disconnected {
                        self.clients.remove(&client_id);
                    }
                }
                None => {
                    warn!("Redis pubsub stream ended for room {}", self.room_id);
                    break;
                }
            }
        }
    }
}
```

### 10.0.6 消息流转

```
客户端 A (Node-1) 发送消息
    │
    │ gRPC streaming → Node-1
    │ ClientMessage { chat: ChatMessage {...} }
    ▼
Node-1 接收消息
    │
    │ 1. 验证 Protobuf 格式
    │ 2. 业务逻辑处理
    │ 3. 存储到数据库 (如需要)
    ▼
序列化并发布到 Redis
    │
    │ PUBLISH room:123:messages '{"room_id":"123","user_id":"...","content":"hello"}'
    ▼
Redis Pub/Sub 广播
    │
    ├──→ Node-1 订阅者接收
    │    └─→ 反序列化为 ServerMessage
    │         └─→ 推送到本地 Client A, C 的 gRPC stream
    │
    ├──→ Node-2 订阅者接收
    │    └─→ 反序列化为 ServerMessage
    │         └─→ 推送到本地 Client B 的 gRPC stream
    │
    └──→ Node-3 订阅者接收
         └─→ 反序列化为 ServerMessage
              └─→ 推送到本地 Client D 的 gRPC stream
```

### 10.0.7 优势

**架构优势**：

- ✅ **无亲和性依赖**: 客户端可连接任意节点
- ✅ **故障容错**: 节点故障时客户端 gRPC 自动重连到其他节点
- ✅ **水平扩展**: 副本数量可任意增减
- ✅ **简化配置**: 无需配置 sessionAffinity
- ✅ **消息顺序**: Redis Pub/Sub 保证消息顺序

**gRPC 特定优势**：

- ✅ **类型安全**: 编译期检查，减少运行时错误
- ✅ **性能更优**: Protobuf 二进制编码，节省带宽
- ✅ **自动流控**: HTTP/2 内置背压机制
- ✅ **自动重连**: tonic 客户端库自动处理断线重连
- ✅ **多路复用**: 单个 TCP 连接支持多个并发流

### 10.0.6 性能优化

**本地缓存**：

- 只订阅有客户端连接的房间
- 最后一个客户端离开时取消订阅

**连接池**：

- 复用 Redis 连接
- 使用连接池避免频繁建立连接

```rust
// 自动清理无客户端的订阅
impl RoomSubscription {
    pub async fn cleanup_if_empty(&self) -> bool {
        if self.clients.is_empty() {
            // 取消 Redis 订阅
            let mut pubsub = self.redis_sub.lock().await;
            let channel = format!("room:{}:messages", self.room_id);
            pubsub.unsubscribe(&channel).await.ok();
            true
        } else {
            false
        }
    }
}
```

---

---

> **注意**: 以下 10.1-10.9 章节展示 WebSocket 实现，作为**兼容层**存在，用于不支持 gRPC 的旧客户端。
> **推荐使用 gRPC bidirectional streaming**（见 10.0.3-10.0.4 章节）作为主要通信协议。

---

## 10.1 连接生命周期 (WebSocket 兼容层)

### 10.1.1 连接建立流程

#### 连接URL

```
ws://synctv.io/api/v1/rooms/{room_id}/ws?token={jwt_token}
```

#### 连接状态机

```rust
// 连接状态机
pub enum WsConnectionState {
    Connecting,
    Connected,
    Authenticated,
    Subscribed(String),  // room_id (nanoid)
    Disconnecting,
    Closed,
}

// WebSocket处理器
pub struct WsHandler {
    state: Arc<RwLock<WsConnectionState>>,
    session_id: String,
    user_id: Option<Uuid>,    // UUID
    room_id: Option<String>,  // nanoid
    last_ping: Arc<RwLock<Instant>>,
}
```

#### 连接处理实现

```rust
impl WsHandler {
    pub async fn handle_connection(
        ws: WebSocket,
        token: String,
        room_id: String,  // nanoid
        auth_service: Arc<AuthService>,
        room_hub: Arc<RoomHub>,
    ) -> Result<()> {
        // 1. 验证token (RS256 JWT)
        let claims = auth_service.verify_token(&token).await?;
        let user_id = claims.sub;  // nanoid

        // 2. 检查房间权限
        let member = room_hub.get_member(room_id, user_id).await?;

        // 3. 创建会话
        let session_id = Uuid::new_v4().to_string();
        let (tx, mut rx) = mpsc::unbounded_channel();

        // 4. 注册到RoomHub
        room_hub.add_client(room_id, user_id, session_id.clone(), tx.clone()).await;

        // 5. 发送初始状态
        let init_message = json!({
            "type": "connected",
            "data": {
                "session_id": session_id,
                "room": room_hub.get_room_info(room_id).await?,
                "members": room_hub.get_room_members(room_id).await?,
                "current_state": room_hub.get_current_state(room_id).await?,
            }
        });
        tx.send(Message::Text(serde_json::to_string(&init_message)?)).ok();

        // 6. 启动消息循环
        let (mut ws_tx, mut ws_rx) = ws.split();

        // 发送任务
        let send_task = tokio::spawn(async move {
            while let Some(msg) = rx.recv().await {
                if ws_tx.send(msg).await.is_err() {
                    break;
                }
            }
        });

        // 接收任务
        let recv_task = tokio::spawn(async move {
            while let Some(result) = ws_rx.next().await {
                match result {
                    Ok(msg) => {
                        if let Err(e) = Self::handle_message(msg, &room_hub, room_id, user_id).await {
                            error!("Handle message error: {}", e);
                        }
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                }
            }
        });

        // 7. 等待任务结束
        tokio::select! {
            _ = send_task => {},
            _ = recv_task => {},
        }

        // 8. 清理
        room_hub.remove_client(room_id, user_id, &session_id).await;

        Ok(())
    }
}
```

### 10.1.2 连接握手

**连接URL格式**: `ws://synctv.io/api/v1/rooms/{room_id}/ws?token={jwt_token}`

**服务端响应**（第一条消息）：

```json
{
  "type": "connected",
  "data": {
    "session_id": "uuid",
    "room": { /* Room对象 */ },
    "members": [ /* Member列表 */ ],
    "current_state": { /* CurrentState对象 */ }
  }
}
```

## 10.2 心跳机制

### 10.2.1 心跳管理器

```rust
pub struct HeartbeatManager {
    interval: Duration,
    timeout: Duration,
}

impl HeartbeatManager {
    pub fn new() -> Self {
        Self {
            interval: Duration::from_secs(30),  // 30秒心跳间隔
            timeout: Duration::from_secs(90),   // 90秒超时
        }
    }

    // 启动心跳检测
    pub async fn start(&self, clients: Arc<DashMap<String, ClientInfo>>) {
        let interval = self.interval;
        let timeout = self.timeout;

        tokio::spawn(async move {
            let mut ticker = tokio::time::interval(interval);
            loop {
                ticker.tick().await;

                let now = Instant::now();
                let mut to_remove = Vec::new();

                for entry in clients.iter() {
                    let (session_id, client) = (entry.key(), entry.value());
                    let last_ping = *client.last_ping.read().await;

                    if now.duration_since(last_ping) > timeout {
                        warn!("Client timeout: {}", session_id);
                        to_remove.push(session_id.clone());
                    }
                }

                for session_id in to_remove {
                    clients.remove(&session_id);
                }
            }
        });
    }
}
```

### 10.2.2 心跳消息

**客户端发送**（每30秒）：

```json
{
  "type": "ping"
}
```

**服务端响应**：

```json
{
  "type": "pong",
  "timestamp": 1705312800000
}
```

```rust
// 心跳消息处理
async fn handle_ping(
    session_id: &str,
    clients: &DashMap<String, ClientInfo>,
) -> Result<()> {
    if let Some(client) = clients.get(session_id) {
        *client.last_ping.write().await = Instant::now();

        let pong = json!({
            "type": "pong",
            "timestamp": Utc::now().timestamp_millis()
        });

        client.tx.send(Message::Text(serde_json::to_string(&pong)?))?;
    }
    Ok(())
}
```

## 10.3 消息格式

### 10.3.1 统一消息封装

```rust
// 统一消息封装
#[derive(Serialize, Deserialize)]
pub struct WsMessage {
    #[serde(rename = "type")]
    pub msg_type: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<WsError>,
}

#[derive(Serialize, Deserialize)]
pub struct WsError {
    pub code: String,
    pub message: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
}
```

### 10.3.2 客户端消息类型

```rust
// 具体消息类型
#[derive(Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum ClientMessage {
    #[serde(rename = "ping")]
    Ping,

    #[serde(rename = "playback.toggle")]
    PlaybackToggle { action: PlayAction },

    #[serde(rename = "playback.seek")]
    PlaybackSeek { time: f64 },

    #[serde(rename = "playback.set_rate")]
    SetPlaybackRate { rate: f64 },

    #[serde(rename = "chat.send")]
    ChatSend { content: String },

    #[serde(rename = "danmaku.send")]
    DanmakuSend {
        content: String,
        video_time: f64,
        #[serde(rename = "type")]
        danmaku_type: DanmakuType,
        color: String,
        font_size: u8,
    },
}
```

### 10.3.3 服务端消息类型

```rust
#[derive(Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum ServerMessage {
    #[serde(rename = "connected")]
    Connected {
        session_id: String,
        room: RoomInfo,
        members: Vec<MemberInfo>,
        current_state: CurrentState,
    },

    #[serde(rename = "pong")]
    Pong {
        timestamp: i64,
    },

    #[serde(rename = "playback.status_changed")]
    PlaybackStatusChanged {
        status: String,
        current_time: f64,
        timestamp: i64,
        triggered_by: UserBrief,
    },

    #[serde(rename = "playback.seeked")]
    PlaybackSeeked {
        time: f64,
        timestamp: i64,
        triggered_by: UserBrief,
    },

    #[serde(rename = "chat.message")]
    ChatMessage {
        id: String,
        user_id: i64,
        username: String,
        content: String,
        created_at: String,
    },

    #[serde(rename = "error")]
    Error {
        code: String,
        message: String,
        details: Option<serde_json::Value>,
    },
}
```

## 10.4 消息类型定义

### 10.4.1 播放状态同步

```javascript
// 客户端发送
{
  "type": "playback.toggle",
  "data": {
    "action": "play"           // play|pause
  }
}

// 服务端广播
{
  "type": "playback.status_changed",
  "data": {
    "status": "playing",
    "current_time": 123.45,
    "timestamp": 1705312800000,
    "triggered_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}
```

### 10.4.2 跳转时间同步

```javascript
// 客户端发送
{
  "type": "playback.seek",
  "data": {
    "time": 456.78
  }
}

// 服务端广播
{
  "type": "playback.seeked",
  "data": {
    "time": 456.78,
    "timestamp": 1705312800000,
    "triggered_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}
```

### 10.4.3 播放速率同步

```javascript
// 客户端发送
{
  "type": "playback.set_rate",
  "data": {
    "rate": 1.5
  }
}

// 服务端广播
{
  "type": "playback.rate_changed",
  "data": {
    "rate": 1.5,
    "timestamp": 1705312800000,
    "triggered_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}
```

### 10.4.4 影片切换同步

```javascript
// 服务端广播（由REST API触发）
{
  "type": "movie.changed",
  "data": {
    "movie_id": 456,
    "movie_name": "盗梦空间",
    "movie_url": "https://...",
    "triggered_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}
```

### 10.4.5 聊天消息

```javascript
// 客户端发送
{
  "type": "chat.send",
  "data": {
    "content": "大家好！"
  }
}

// 服务端广播
{
  "type": "chat.message",
  "data": {
    "id": "uuid",
    "user_id": 1,
    "username": "alice",
    "content": "大家好！",
    "created_at": "2024-01-15T12:00:00Z"
  }
}
```

### 10.4.6 弹幕消息

```javascript
// 客户端发送
{
  "type": "danmaku.send",
  "data": {
    "content": "精彩！",
    "video_time": 123.45,
    "type": "scroll",
    "color": "#FFFFFF"
  }
}

// 服务端广播
{
  "type": "danmaku.message",
  "data": {
    "id": "uuid",
    "user_id": 1,
    "content": "精彩！",
    "video_time": 123.45,
    "type": "scroll",
    "color": "#FFFFFF",
    "source": "user",
    "created_at": "2024-01-15T12:00:00Z"
  }
}
```

### 10.4.7 成员加入/离开

```javascript
// 服务端广播
{
  "type": "member.joined",
  "data": {
    "user_id": 2,
    "username": "bob",
    "role": "member",
    "joined_at": "2024-01-15T12:00:00Z"
  }
}

{
  "type": "member.left",
  "data": {
    "user_id": 2,
    "username": "bob"
  }
}
```

### 10.4.8 成员权限变更

```javascript
// 服务端广播
{
  "type": "member.permissions_changed",
  "data": {
    "user_id": 2,
    "username": "bob",
    "role": "admin",
    "permissions": 2147483647,
    "changed_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}
```

### 10.4.9 直播状态变更

```javascript
// 服务端广播
{
  "type": "live.started",
  "data": {
    "stream_key": "room_123_abc123",
    "play_urls": {
      "hls": "https://...",
      "flv": "https://..."
    },
    "started_by": {
      "user_id": 1,
      "username": "alice"
    }
  }
}

{
  "type": "live.stopped",
  "data": {
    "stream_key": "room_123_abc123",
    "duration": 3600
  }
}
```

### 10.4.10 错误消息

```javascript
{
  "type": "error",
  "data": {
    "code": "PERMISSION_DENIED",
    "message": "您没有权限执行此操作",
    "details": {
      "required_permission": "PLAY_CONTROL"
    }
  }
}
```

## 10.5 视频长度处理与自动连播触发

> **核心问题**: 服务端如何知道视频播放完毕并触发自动连播？

### 10.5.1 视频长度来源

视频长度（duration）有多个来源，按优先级排序：

| 来源 | 可靠性 | 适用场景 | 说明 |
|------|--------|---------|------|
| **视频解析器API** | ⭐⭐⭐⭐⭐ | Bilibili/Emby | 最可靠，服务端直接存储 |
| **客户端上报** | ⭐⭐⭐⭐ | 所有格式 | **推荐方案**，`loadedmetadata`事件 |
| **服务端探测** | ⭐⭐⭐ | 直接URL | ffprobe探测，开销大 |
| **NULL** | ⭐⭐ | 未知/直播 | 完全依赖客户端ended事件 |

### 10.5.2 客户端上报消息

#### VideoDurationReport - 视频长度上报

```javascript
// 客户端 → 服务端
{
  "type": "video.duration_report",
  "data": {
    "movie_id": "550e8400-e29b-41d4-a716-446655440010",
    "duration": 3600,           // 秒
    "client_timestamp": 1706174400000
  }
}
```

**触发时机**: 视频元数据加载完成时（`loadedmetadata` 事件）

#### VideoEnded - 视频播放完成

**客户端 → 服务端**：

```json
{
  "type": "video.ended",
  "data": {
    "movie_id": "550e8400-e29b-41d4-a716-446655440010",
    "actual_duration": 3598,    // 可选：实际播放时长
    "client_timestamp": 1706178000000
  }
}
```

**触发时机**: 视频播放完成时（`ended` 事件）

### 10.5.3 服务端响应消息

#### AutoPlayCountdown - 自动连播倒计时

```javascript
// 服务端 → 客户端
{
  "type": "auto_play.countdown",
  "data": {
    "next_movie_id": "550e8400-e29b-41d4-a716-446655440011",
    "countdown": 3,             // 秒
    "mode": "sequential"        // sequential|repeat_one|repeat_all|shuffle
  }
}
```

**用途**: 通知所有客户端即将自动播放下一个视频，显示倒计时UI。

#### PlaylistEnded - 播放列表结束

```javascript
// 服务端 → 客户端
{
  "type": "playlist.ended",
  "data": {
    "will_restart": false       // RepeatAll模式会循环
  }
}
```

**用途**: 通知播放列表已结束（Sequential模式）。

#### MovieChanged - 影片切换

```javascript
// 服务端 → 客户端
{
  "type": "movie.changed",
  "data": {
    "movie_id": "550e8400-e29b-41d4-a716-446655440011",
    "triggered_by": null        // null表示自动连播触发
  }
}
```

**用途**: 通知影片已切换（包括手动切换和自动连播）。

### 10.5.4 取消自动播放

#### CancelAutoPlay - 取消自动播放

```javascript
// 客户端 → 服务端
{
  "type": "auto_play.cancel"
}
```

**用途**: 用户主动取消自动播放倒计时。

### 10.5.5 服务端处理流程

```rust
/// 处理视频播放完成事件
pub async fn handle_video_ended(
    ws_handler: &WsHandler,
    movie_id: Uuid,
    actual_duration: Option<i32>,
) -> Result<()> {
    let room = &ws_handler.room;

    // 1. 验证是当前播放的视频
    let current = room.get_current_movie().await?;
    if current.id != movie_id {
        return Ok(());  // 不是当前视频，忽略
    }

    // 2. 检查是否启用自动连播
    if !room.settings.auto_play.enabled {
        return Ok(());
    }

    // 3. 获取下一个视频
    let next_movie = get_next_video(
        &ws_handler.db,
        &ws_handler.parser_registry,
        &room.id,
        &movie_id,
        room.settings.auto_play.mode,
    )
    .await?;

    // 5. 广播倒计时或结束消息
    if let Some(next) = next_movie {
        let delay = room.settings.auto_play.delay;

        // 广播倒计时
        room.broadcast(ServerMessage::AutoPlayCountdown {
            next_movie_id: next.id,
            countdown: delay,
            mode: room.settings.auto_play.mode,
        })
        .await?;

        // 异步延迟切换（不阻塞）
        let room_clone = room.clone();
        let next_id = next.id;
        tokio::spawn(async move {
            tokio::time::sleep(Duration::from_secs(delay as u64)).await;

            // 切换视频
            let _ = room_clone.set_current_movie(&next_id).await;
            let _ = room_clone.broadcast(ServerMessage::MovieChanged {
                movie_id: next_id,
                triggered_by: None,
            })
            .await;
        });
    } else {
        // 播放列表结束
        room.broadcast(ServerMessage::PlaylistEnded {
            will_restart: room.settings.auto_play.mode == PlayMode::RepeatAll,
        })
        .await?;
    }

    Ok(())
}
```

### 10.5.6 客户端实现要点

客户端需要实现以下功能：

1. **监听视频元数据加载完成**
   - 获取视频时长并上报到服务端
   - 发送 `video.duration_report` 消息

2. **监听视频播放完成**
   - 发送 `video.ended` 消息通知服务端
   - 触发服务端自动连播逻辑

3. **处理服务端消息**
   - `auto_play.countdown`: 显示倒计时UI
   - `movie.changed`: 加载新视频
   - `playlist.ended`: 显示播放列表结束提示

4. **倒计时UI管理**
   - 显示倒计时提示和取消按钮
   - 用户可以取消自动播放
   - 倒计时结束后清理UI

### 10.5.7 边界情况处理

#### 客户端离线

**问题**: 所有客户端都离线，无人上报ended事件。

**解决方案**: 后台任务检测超时。

```rust
pub async fn check_inactive_rooms_task(db: PgPool, redis: RedisPool) {
    loop {
        let rooms = get_active_rooms(&redis).await;

        for room_id in rooms {
            let state = get_room_state(&redis, &room_id).await;

            if let Some(current_movie_id) = state.current_movie_id {
                // 获取duration
                let duration = get_video_duration(&db, &current_movie_id).await?;

                if let Some(duration) = duration {
                    let elapsed = state.last_activity.elapsed().as_secs();

                    // 超过 duration + 60秒，认为视频已结束
                    if elapsed > (duration as u64 + 60) {
                        tracing::warn!("Room {} inactive, triggering auto play", room_id);
                        // 触发自动连播...
                    }
                }
            }
        }

        tokio::time::sleep(Duration::from_secs(30)).await;
    }
}
```

#### Duration未知

**问题**: 某些视频源无法获取duration（自定义URL、HLS直播）。

**解决方案**: 数据库duration字段为NULL，完全依赖客户端ended事件。

```rust
// duration为NULL时不做超时检查
if movie.duration.is_none() {
    tracing::debug!(
        "Movie {} has unknown duration, waiting for client ended event",
        movie.id
    );
}
```

#### 限流保护

**问题**: 恶意客户端频繁发送ended消息。

**解决方案**: 限流器（10秒cooldown）。

```rust
pub struct VideoEndedRateLimiter {
    last_ended: Arc<DashMap<String, Instant>>,
    cooldown: Duration,
}

impl VideoEndedRateLimiter {
    pub fn check_and_update(&self, room_id: &str) -> bool {
        let now = Instant::now();

        if let Some(mut entry) = self.last_ended.get_mut(room_id) {
            let elapsed = now.duration_since(*entry);

            if elapsed < self.cooldown {
                tracing::warn!(
                    "Video ended rate limit exceeded: room={}",
                    room_id
                );
                return false;
            }

            *entry = now;
        } else {
            self.last_ended.insert(room_id.to_string(), now);
        }

        true
    }
}
```

### 10.5.8 设计要点

| 方面 | 设计 | 理由 |
|------|------|------|
| **触发方式** | 客户端主动上报 | 最准确，支持所有格式 |
| **duration来源** | 多来源（解析器→客户端→探测） | 冗余保证 |
| **倒计时UI** | 3秒缓冲 | 用户体验好，可取消 |
| **限流保护** | 10秒cooldown | 防止恶意请求 |
| **离线处理** | 后台超时检测 | 确保自动连播可靠性 |

---

## 10.6 消息路由与广播

### 10.6.1 房间消息中心

```rust
// 房间消息中心
pub struct RoomHub {
    rooms: Arc<DashMap<i64, RoomClients>>,
    cluster_sync: Arc<ClusterSync>,
}

struct RoomClients {
    clients: DashMap<String, ClientChannel>,  // session_id -> channel
    user_sessions: DashMap<i64, HashSet<String>>,  // user_id -> session_ids
}
```

### 10.6.2 广播实现

```rust
impl RoomHub {
    // 广播到房间所有客户端
    pub async fn broadcast(
        &self,
        room_id: i64,
        message: ServerMessage,
        exclude_session: Option<&str>,
    ) -> Result<()> {
        let msg_str = serde_json::to_string(&message)?;
        let ws_msg = Message::Text(msg_str);

        if let Some(room) = self.rooms.get(&room_id) {
            for entry in room.clients.iter() {
                let (session_id, channel) = (entry.key(), entry.value());

                // 排除发送者自己
                if let Some(exclude) = exclude_session {
                    if session_id == exclude {
                        continue;
                    }
                }

                if let Err(e) = channel.tx.send(ws_msg.clone()) {
                    warn!("Failed to send to session {}: {}", session_id, e);
                }
            }
        }

        Ok(())
    }

    // 发送给特定用户的所有会话
    pub async fn send_to_user(
        &self,
        room_id: i64,
        user_id: i64,
        message: ServerMessage,
    ) -> Result<()> {
        let msg_str = serde_json::to_string(&message)?;
        let ws_msg = Message::Text(msg_str);

        if let Some(room) = self.rooms.get(&room_id) {
            if let Some(sessions) = room.user_sessions.get(&user_id) {
                for session_id in sessions.iter() {
                    if let Some(channel) = room.clients.get(session_id) {
                        channel.tx.send(ws_msg.clone()).ok();
                    }
                }
            }
        }

        Ok(())
    }

    // 跨节点广播
    pub async fn broadcast_cluster(
        &self,
        room_id: i64,
        event: ClusterEvent,
    ) -> Result<()> {
        // 本地广播
        let server_msg = self.event_to_message(&event)?;
        self.broadcast(room_id, server_msg, None).await?;

        // 集群广播
        self.cluster_sync.publish_event(event).await?;

        Ok(())
    }
}
```

## 10.7 流量控制与限流

### 10.7.1 WebSocket限流器

```rust
// WebSocket消息限流器
pub struct WsRateLimiter {
    // 全局限流
    global: Arc<RateLimiter>,

    // 每用户限流
    per_user: Arc<DashMap<i64, RateLimiter>>,

    // 每消息类型限流
    per_type: Arc<DashMap<String, RateLimiter>>,
}

impl WsRateLimiter {
    pub fn new() -> Self {
        Self {
            global: Arc::new(RateLimiter::new(1000, Duration::from_secs(1))),  // 全局1000/s
            per_user: Arc::new(DashMap::new()),
            per_type: Arc::new(DashMap::new()),
        }
    }

    pub async fn check(
        &self,
        user_id: i64,
        msg_type: &str,
    ) -> Result<()> {
        // 1. 全局限流检查
        if !self.global.check().await {
            return Err(Error::RateLimitExceeded {
                retry_after: 1,
            });
        }

        // 2. 用户限流检查（100/s per user）
        let user_limiter = self.per_user
            .entry(user_id)
            .or_insert_with(|| RateLimiter::new(100, Duration::from_secs(1)));

        if !user_limiter.check().await {
            return Err(Error::RateLimitExceeded {
                retry_after: 1,
            });
        }

        // 3. 消息类型限流（特殊类型如弹幕、聊天）
        if msg_type == "chat.send" || msg_type == "danmaku.send" {
            let type_limiter = self.per_type
                .entry(format!("{}:{}", user_id, msg_type))
                .or_insert_with(|| {
                    // 聊天10/s, 弹幕5/s
                    let limit = if msg_type == "chat.send" { 10 } else { 5 };
                    RateLimiter::new(limit, Duration::from_secs(1))
                });

            if !type_limiter.check().await {
                return Err(Error::RateLimitExceeded {
                    retry_after: 1,
                });
            }
        }

        Ok(())
    }
}
```

### 10.7.2 Token Bucket算法

```rust
// 简单的Token Bucket算法
pub struct RateLimiter {
    capacity: u32,
    tokens: Arc<Mutex<u32>>,
    refill_rate: Duration,
    last_refill: Arc<Mutex<Instant>>,
}

impl RateLimiter {
    pub fn new(capacity: u32, refill_rate: Duration) -> Self {
        Self {
            capacity,
            tokens: Arc::new(Mutex::new(capacity)),
            refill_rate,
            last_refill: Arc::new(Mutex::new(Instant::now())),
        }
    }

    pub async fn check(&self) -> bool {
        self.refill().await;

        let mut tokens = self.tokens.lock().await;
        if *tokens > 0 {
            *tokens -= 1;
            true
        } else {
            false
        }
    }

    async fn refill(&self) {
        let mut last_refill = self.last_refill.lock().await;
        let now = Instant::now();
        let elapsed = now.duration_since(*last_refill);

        if elapsed >= self.refill_rate {
            let mut tokens = self.tokens.lock().await;
            *tokens = self.capacity;
            *last_refill = now;
        }
    }
}
```

## 10.8 断线重连机制

### 10.8.1 客户端重连逻辑

客户端需要实现以下重连机制：

**连接状态管理**：

- 保存 `session_id` 用于重连识别
- 记录重连尝试次数和延迟时间
- 最大重连次数：10次

**重连策略**：

- 非正常关闭时（code ≠ 1000）触发重连
- 指数退避：延迟 = base_delay × 2^attempts
- 初始延迟：1秒
- 最大延迟：约17分钟（1000ms × 2^10）

**心跳维护**：

- 连接成功后启动心跳定时器
- 每30秒发送一次ping消息
- 连接关闭时停止心跳

**错误处理**：

- 记录连接错误日志
- 区分网络错误和业务错误
- 提供用户友好的错误提示

### 10.8.2 服务端会话管理

```rust
// 服务端会话恢复支持
pub struct SessionManager {
    sessions: Arc<DashMap<String, SessionState>>,
    ttl: Duration,
}

struct SessionState {
    user_id: i64,
    room_id: i64,
    last_sequence: u64,  // 最后一条消息序号
    created_at: Instant,
}

impl SessionManager {
    pub async fn save_session(
        &self,
        session_id: String,
        user_id: i64,
        room_id: i64,
    ) {
        self.sessions.insert(session_id, SessionState {
            user_id,
            room_id,
            last_sequence: 0,
            created_at: Instant::now(),
        });
    }

    pub async fn restore_session(
        &self,
        session_id: &str,
    ) -> Option<SessionState> {
        self.sessions.get(session_id).map(|s| s.clone())
    }

    // 定期清理过期会话
    pub async fn cleanup_expired(&self) {
        let now = Instant::now();
        self.sessions.retain(|_, session| {
            now.duration_since(session.created_at) < self.ttl
        });
    }
}
```

## 10.9 多副本会话管理

### 10.9.1 问题背景

在多副本架构下，用户WebSocket断线重连可能连接到不同副本，导致：

- 同一用户在多个副本有多个活跃连接
- 收到重复消息
- 在线人数统计不准确
- 权限变更只影响部分连接

### 10.9.2 Redis会话注册

使用Redis记录所有活跃WebSocket连接：

```rust
// sync/session_manager.rs
use uuid::Uuid;
use chrono::Utc;

pub struct SessionManager {
    redis: deadpool_redis::Pool,
    local_node_id: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SessionInfo {
    pub session_id: String,
    pub node_id: String,
    pub room_id: String,      // nanoid
    pub connected_at: i64,
}

impl SessionManager {
    /// 注册WebSocket连接到Redis
    pub async fn register_session(
        &self,
        user_id: Uuid,
        room_id: &str,
        session_id: &str,
    ) -> Result<()> {
        let key = format!("ws:{}:{}", room_id, user_id);
        let session = SessionInfo {
            session_id: session_id.to_string(),
            node_id: self.local_node_id.clone(),
            room_id: room_id.to_string(),
            connected_at: Utc::now().timestamp(),
        };

        let mut conn = self.redis.get().await?;

        // 存储会话信息
        redis::cmd("HSET")
            .arg(&key)
            .arg(session_id)
            .arg(serde_json::to_string(&session)?)
            .query_async(&mut conn)
            .await?;

        // 设置过期时间（5分钟无心跳则自动删除）
        redis::cmd("EXPIRE")
            .arg(&key)
            .arg(300)
            .query_async(&mut conn)
            .await?;

        Ok(())
    }

    /// 检查并清理旧会话
    pub async fn cleanup_old_sessions(
        &self,
        user_id: Uuid,
        room_id: &str,
        current_session_id: &str,
    ) -> Result<Vec<SessionInfo>> {
        let key = format!("ws:{}:{}", room_id, user_id);
        let mut conn = self.redis.get().await?;

        // 获取该用户在该房间的所有会话
        let sessions: HashMap<String, String> = redis::cmd("HGETALL")
            .arg(&key)
            .query_async(&mut conn)
            .await?;

        let mut old_sessions = Vec::new();

        for (session_id, session_json) in sessions {
            if session_id == current_session_id {
                continue;  // 跳过当前会话
            }

            let session: SessionInfo = serde_json::from_str(&session_json)?;
            old_sessions.push(session);

            // 删除旧会话记录
            redis::cmd("HDEL")
                .arg(&key)
                .arg(&session_id)
                .query_async(&mut conn)
                .await?;
        }

        Ok(old_sessions)
    }

    /// 注销会话
    pub async fn unregister_session(
        &self,
        user_id: Uuid,
        room_id: &str,
        session_id: &str,
    ) -> Result<()> {
        let key = format!("ws:{}:{}", room_id, user_id);
        let mut conn = self.redis.get().await?;

        redis::cmd("HDEL")
            .arg(&key)
            .arg(session_id)
            .query_async(&mut conn)
            .await?;

        Ok(())
    }
}
```

### 10.9.3 连接建立时断开旧连接

修改连接处理逻辑，在新连接建立时强制断开旧连接：

```rust
// api/websocket.rs
pub async fn handle_connection(
    ws: WebSocket,
    token: String,
    room_id: String,  // nanoid
    auth_service: Arc<AuthService>,
    room_hub: Arc<RoomHub>,
    session_manager: Arc<SessionManager>,
    cluster_sync: Arc<ClusterSync>,
) -> Result<()> {
    // 1. 验证token
    let claims = auth_service.verify_token(&token).await?;
    let user_id = Uuid::parse_str(&claims.sub)?;

    // 2. 检查房间权限
    let member = room_hub.get_member(&room_id, user_id).await?;

    // 3. 生成新会话ID
    let session_id = Uuid::new_v4().to_string();

    // 4. 检查并清理旧会话
    let old_sessions = session_manager
        .cleanup_old_sessions(user_id, &room_id, &session_id)
        .await?;

    // 5. 断开旧连接
    for old_session in old_sessions {
        if old_session.node_id == session_manager.local_node_id {
            // 本地连接：直接断开
            room_hub.disconnect_session(&old_session.session_id).await;
        } else {
            // 远程连接：通过集群事件请求断开
            cluster_sync.publish(ClusterEvent::ForceDisconnect {
                user_id,
                room_id: room_id.clone(),
                session_id: old_session.session_id,
                reason: "new_connection".to_string(),
            }).await?;
        }
    }

    // 6. 注册新会话
    session_manager
        .register_session(user_id, &room_id, &session_id)
        .await?;

    // 7. 创建消息通道
    let (tx, mut rx) = mpsc::unbounded_channel();

    // 8. 注册到RoomHub
    room_hub.add_client(&room_id, user_id, session_id.clone(), tx.clone()).await;

    // 9. 发送初始状态
    let init_message = json!({
        "type": "connected",
        "data": {
            "session_id": session_id,
            "room": room_hub.get_room_info(&room_id).await?,
            "members": room_hub.get_room_members(&room_id).await?,
            "current_state": room_hub.get_current_state(&room_id).await?,
        }
    });
    tx.send(Message::Text(serde_json::to_string(&init_message)?)).ok();

    // 10. 启动消息循环
    let (mut ws_tx, mut ws_rx) = ws.split();

    let send_task = tokio::spawn(async move {
        while let Some(msg) = rx.recv().await {
            if ws_tx.send(msg).await.is_err() {
                break;
            }
        }
    });

    let recv_task = tokio::spawn(async move {
        while let Some(result) = ws_rx.next().await {
            match result {
                Ok(msg) => {
                    if let Err(e) = handle_message(msg, &room_hub, &room_id, user_id).await {
                        error!("Handle message error: {}", e);
                    }
                }
                Err(e) => {
                    error!("WebSocket error: {}", e);
                    break;
                }
            }
        }
    });

    // 11. 等待任务结束
    tokio::select! {
        _ = send_task => {},
        _ = recv_task => {},
    }

    // 12. 清理
    session_manager.unregister_session(user_id, &room_id, &session_id).await?;
    room_hub.remove_client(&room_id, user_id, &session_id).await;

    Ok(())
}
```

### 10.9.4 处理跨副本强制断开

在集群事件处理器中处理`ForceDisconnect`事件：

```rust
// sync/cluster_sync.rs
impl EventHandler for SessionEventHandler {
    async fn handle(&self, event: &ClusterEvent) -> Result<()> {
        match event {
            ClusterEvent::ForceDisconnect { user_id, room_id, session_id, reason } => {
                tracing::info!(
                    user_id = %user_id,
                    room_id = %room_id,
                    session_id = %session_id,
                    reason = %reason,
                    "Forcing disconnect from remote node"
                );

                // 查找并断开指定会话
                if let Some(room) = self.room_hub.get_room(room_id) {
                    // 发送断开消息给客户端
                    room.send_to_session(session_id, ServerMessage::ForceDisconnected {
                        reason: reason.clone(),
                    }).await;

                    // 断开连接
                    room.disconnect_session(session_id).await;
                }
            }
            _ => {}
        }
        Ok(())
    }
}
```

### 10.9.5 RoomHub扩展方法

扩展`RoomHub`以支持按会话断开连接：

```rust
// server/room_hub.rs
impl RoomHub {
    /// 断开指定会话
    pub async fn disconnect_session(&self, session_id: &str) -> Result<()> {
        for room in self.rooms.iter() {
            if let Some(client) = room.clients.get(session_id) {
                // 发送关闭消息
                let close_msg = Message::Close(Some(CloseFrame {
                    code: CloseCode::Normal,
                    reason: "Disconnected by server".into(),
                }));

                client.tx.send(close_msg).ok();

                // 从房间中移除
                room.clients.remove(session_id);

                tracing::info!(session_id = %session_id, "Session disconnected");
                return Ok(());
            }
        }

        Ok(())
    }

    /// 发送消息给指定会话
    pub async fn send_to_session(
        &self,
        room_id: &str,
        session_id: &str,
        message: ServerMessage,
    ) -> Result<()> {
        if let Some(room) = self.rooms.get(room_id) {
            if let Some(client) = room.clients.get(session_id) {
                let msg_str = serde_json::to_string(&message)?;
                client.tx.send(Message::Text(msg_str)).ok();
            }
        }
        Ok(())
    }
}
```

### 10.9.6 设计要点

**会话唯一性保证**：

- Redis记录所有活跃会话（跨所有副本）
- 新连接建立时，先清理旧会话
- 使用HSET存储，同一用户在同一房间只保留最新会话

**跨副本通信**：

- 通过`ClusterEvent::ForceDisconnect`跨副本断开连接
- 使用Redis Pub/Sub保证事件可靠传递

**会话过期**：

- Redis键自动过期（5分钟）
- 心跳机制刷新过期时间
- 防止僵尸会话占用资源

**客户端体验**：

- 旧连接收到`ForceDisconnected`消息后优雅关闭
- 新连接立即可用，无需等待旧连接超时
- 客户端自动重连逻辑不受影响

### 10.9.7 测试建议

```rust
#[tokio::test]
async fn test_reconnect_different_replica() {
    // 1. 用户连接到副本1
    let ws1 = connect_to_replica("replica-1", token).await;
    ws1.send(ClientMessage::Join { room_id }).await;

    // 2. 断开连接
    drop(ws1);

    // 3. 重连到副本2
    let ws2 = connect_to_replica("replica-2", token).await;
    ws2.send(ClientMessage::Join { room_id }).await;

    // 4. 发送消息
    ws2.send(ClientMessage::Chat { content: "test" }).await;

    // 5. 验证：只收到一次消息
    let msgs = ws2.receive_messages(Duration::from_secs(1)).await;
    assert_eq!(msgs.len(), 1, "Should receive message only once");
}
```

---

**上一章**: [15-API接口定义](./15-API接口定义.md)
**下一章**: [17-数据流设计](./17-数据流设计.md)
