# 13. 部署方案

---

## 目录

- [1. 部署架构概览](#1-部署架构概览)
- [2. Docker 单节点部署](#2-docker-单节点部署)
- [3. Docker Compose 部署](#3-docker-compose-部署)
- [4. Kubernetes Helm 部署](#4-kubernetes-helm-部署)
- [5. 配置管理](#5-配置管理)
- [6. 部署最佳实践](#6-部署最佳实践)

---

## 1. 部署架构概览

### 1.1 部署模式对比

| 部署模式 | 适用场景 | 优点 | 缺点 |
|---------|---------|------|------|
| **Docker 单容器** | 开发测试、小规模 | 简单快速、资源占用少 | 无高可用、无扩展性 |
| **Docker Compose** | 小型生产、团队部署 | 易于管理、包含依赖 | 单机限制、手动扩展 |
| **Kubernetes Helm** | 大规模生产、企业级 | 自动扩缩容、高可用 | 复杂度高、运维成本高 |

### 1.2 组件依赖关系

```text
┌─────────────────────────────────────────────────┐
│  SyncTV Application                             │
│  - HTTP/WebSocket Server                        │
│  - RTMP Live Streaming                          │
│  - HLS Transcoding                              │
└────────┬────────────────────────────────────────┘
         │
         ├─► PostgreSQL (数据库)
         │   - 用户、房间、视频元数据
         │   - OAuth2 token、会话
         │
         ├─► Redis (缓存与状态同步)
         │   - 房间状态、播放器状态
         │   - Pub/Sub (多副本通信)
         │   - Session存储
         │
         └─► MinIO/S3 (可选)
             - 用户上传文件存储
             - HLS切片存储 (多副本共享)
```

---

## 2. Docker 单节点部署

### 2.1 Dockerfile (多阶段构建)

```dockerfile
# syntax=docker/dockerfile:1

# ============================================
# Stage 1: 依赖缓存层
# ============================================
FROM rust:1.75-slim-bookworm AS chef

RUN cargo install cargo-chef
WORKDIR /app


# ============================================
# Stage 2: 生成依赖清单
# ============================================
FROM chef AS planner

COPY Cargo.toml Cargo.lock ./
COPY synctv/Cargo.toml ./synctv/
COPY livelib/Cargo.toml ./livelib/

RUN cargo chef prepare --recipe-path recipe.json


# ============================================
# Stage 3: 构建依赖 (最耗时,缓存)
# ============================================
FROM chef AS builder

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    libpq-dev \
    protobuf-compiler \
    && rm -rf /var/lib/apt/lists/*

# 构建依赖 (缓存层)
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json

# 复制源码并构建
COPY . .
RUN cargo build --release --bin synctv


# ============================================
# Stage 4: 运行时镜像 (最小化)
# ============================================
FROM debian:bookworm-slim

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    libpq5 \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

# 创建非root用户
RUN useradd -m -u 1000 synctv && \
    mkdir -p /data/hls /data/cache /etc/synctv && \
    chown -R synctv:synctv /data /etc/synctv

WORKDIR /app

# 复制可执行文件
COPY --from=builder /app/target/release/synctv /app/synctv
COPY --from=builder /app/synctv/migrations /app/migrations

# 切换到非root用户
USER synctv

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app/synctv", "health"]

EXPOSE 8080 1935

ENTRYPOINT ["/app/synctv"]
CMD ["server"]
```

### 2.2 构建与运行

```bash
# 构建镜像
docker build -t synctv:latest .

# 运行 (依赖外部 PostgreSQL 和 Redis)
docker run -d \
  --name synctv \
  -p 8080:8080 \
  -p 1935:1935 \
  -e DATABASE_URL="postgresql://user:pass@postgres-host:5432/synctv" \
  -e REDIS_URL="redis://redis-host:6379" \
  -e JWT_PRIVATE_KEY_PATH="/etc/synctv/jwt-private.pem" \
  -e JWT_PUBLIC_KEY_PATH="/etc/synctv/jwt-public.pem" \
  -e SMTP_HOST="smtp.example.com" \
  -e SMTP_PORT="587" \
  -e SMTP_USERNAME="noreply@example.com" \
  -e SMTP_PASSWORD="smtp-password" \
  -v /path/to/config:/etc/synctv \
  -v /path/to/data:/data \
  synctv:latest
```

### 2.3 生成 JWT 密钥对

```bash
# 生成 RS256 密钥对 (用于 JWT 签名)
docker run --rm -v $(pwd):/keys synctv:latest generate-keys \
  --private-key /keys/jwt-private.pem \
  --public-key /keys/jwt-public.pem
```

---

## 3. Docker Compose 部署

### 3.1 完整配置 (docker-compose.yml)

```yaml
version: '3.9'

services:
  # ================================================
  # PostgreSQL 数据库
  # ================================================
  postgres:
    image: postgres:15-alpine
    container_name: synctv-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: synctv
      POSTGRES_USER: synctv
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-change_me_in_production}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U synctv"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - synctv_network


  # ================================================
  # Redis 缓存
  # ================================================
  redis:
    image: redis:7-alpine
    container_name: synctv-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - synctv_network


  # ================================================
  # MinIO (可选: 对象存储)
  # ================================================
  minio:
    image: minio/minio:latest
    container_name: synctv-minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin123}
    volumes:
      - minio_data:/data
    ports:
      - "9000:9000"   # API
      - "9001:9001"   # Console
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - synctv_network


  # ================================================
  # SyncTV 应用 (数据库迁移)
  # ================================================
  synctv-migrate:
    image: synctv/synctv:${SYNCTV_VERSION:-latest}
    container_name: synctv-migrate
    command: migrate up
    environment:
      DATABASE_URL: postgresql://synctv:${POSTGRES_PASSWORD:-change_me_in_production}@postgres:5432/synctv
      RUST_LOG: info
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - synctv_network
    restart: "no"


  # ================================================
  # SyncTV 应用主服务
  # ================================================
  synctv:
    image: synctv/synctv:${SYNCTV_VERSION:-latest}
    container_name: synctv-app
    restart: unless-stopped
    command: server
    ports:
      - "8080:8080"   # HTTP/WebSocket
      - "1935:1935"   # RTMP
    environment:
      # 数据库配置
      DATABASE_URL: postgresql://synctv:${POSTGRES_PASSWORD:-change_me_in_production}@postgres:5432/synctv
      DATABASE_MAX_CONNECTIONS: "20"

      # Redis配置
      REDIS_URL: redis://redis:6379
      REDIS_MAX_CONNECTIONS: "10"

      # 服务器配置
      HTTP_ADDRESS: "0.0.0.0"
      HTTP_PORT: "8080"
      RTMP_ADDRESS: "0.0.0.0"
      RTMP_PORT: "1935"

      # JWT配置 (RS256)
      JWT_PRIVATE_KEY_PATH: "/etc/synctv/jwt-private.pem"
      JWT_PUBLIC_KEY_PATH: "/etc/synctv/jwt-public.pem"
      JWT_ACCESS_TOKEN_EXPIRES: "3600"      # 1小时
      JWT_REFRESH_TOKEN_EXPIRES: "2592000"  # 30天

      # SMTP邮件配置
      SMTP_HOST: ${SMTP_HOST:-smtp.example.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USERNAME: ${SMTP_USERNAME:-noreply@example.com}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      SMTP_FROM: ${SMTP_FROM:-SyncTV <noreply@example.com>}

      # OAuth2配置 (可选)
      OAUTH2_GITHUB_CLIENT_ID: ${OAUTH2_GITHUB_CLIENT_ID}
      OAUTH2_GITHUB_CLIENT_SECRET: ${OAUTH2_GITHUB_CLIENT_SECRET}
      OAUTH2_GOOGLE_CLIENT_ID: ${OAUTH2_GOOGLE_CLIENT_ID}
      OAUTH2_GOOGLE_CLIENT_SECRET: ${OAUTH2_GOOGLE_CLIENT_SECRET}

      # MinIO配置 (可选)
      S3_ENDPOINT: "http://minio:9000"
      S3_ACCESS_KEY: ${MINIO_ROOT_USER:-minioadmin}
      S3_SECRET_KEY: ${MINIO_ROOT_PASSWORD:-minioadmin123}
      S3_BUCKET: "synctv"
      S3_REGION: "us-east-1"

      # HLS配置
      HLS_SEGMENT_DURATION: "2"
      HLS_PLAYLIST_LENGTH: "6"
      HLS_CACHE_PATH: "/data/hls"

      # 限制配置
      MAX_ROOM_MEMBERS: "100"
      MAX_CONCURRENT_STREAMS: "50"
      MAX_UPLOAD_SIZE: "104857600"  # 100MB

      # 日志配置
      RUST_LOG: "synctv=info,tower_http=info"
      LOG_FORMAT: "json"

      # 节点ID (Docker Compose单节点)
      NODE_ID: "synctv-app-1"

    volumes:
      - ./config:/etc/synctv:ro        # JWT密钥、配置文件
      - synctv_data:/data              # HLS缓存、文件缓存
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      synctv-migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "/app/synctv", "health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      - synctv_network


  # ================================================
  # NGINX 反向代理 (可选)
  # ================================================
  nginx:
    image: nginx:alpine
    container_name: synctv-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
      - nginx_logs:/var/log/nginx
    depends_on:
      - synctv
    networks:
      - synctv_network


volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  minio_data:
    driver: local
  synctv_data:
    driver: local
  nginx_logs:
    driver: local


networks:
  synctv_network:
    driver: bridge
```

### 3.2 环境变量配置 (.env)

```bash
# .env 文件 (不要提交到git)

# SyncTV 版本
SYNCTV_VERSION=latest

# PostgreSQL
POSTGRES_PASSWORD=your_strong_password_here

# SMTP 邮件
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your_email@gmail.com
SMTP_PASSWORD=your_app_password
SMTP_FROM=SyncTV <noreply@yourdomain.com>

# OAuth2 GitHub
OAUTH2_GITHUB_CLIENT_ID=your_github_client_id
OAUTH2_GITHUB_CLIENT_SECRET=your_github_client_secret

# OAuth2 Google
OAUTH2_GOOGLE_CLIENT_ID=your_google_client_id
OAUTH2_GOOGLE_CLIENT_SECRET=your_google_client_secret

# MinIO
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=minioadmin123456
```

### 3.3 NGINX 配置 (nginx.conf)

```nginx
events {
    worker_connections 4096;
}

http {
    upstream synctv_backend {
        server synctv:8080;
    }

    # WebSocket 超时配置
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    server {
        listen 80;
        server_name synctv.example.com;

        # 重定向到HTTPS (生产环境)
        # return 301 https://$server_name$request_uri;

        client_max_body_size 100M;

        # 代理所有请求到 SyncTV
        location / {
            proxy_pass http://synctv_backend;
            proxy_http_version 1.1;

            # WebSocket 支持
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # 基本代理头
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 超时配置
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 3600s;  # WebSocket长连接
        }

        # RTMP 推流端点 (TCP代理)
        # 需要使用 stream 模块
    }

    # HTTPS 配置 (生产环境)
    server {
        listen 443 ssl http2;
        server_name synctv.example.com;

        ssl_certificate /etc/nginx/certs/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        client_max_body_size 100M;

        location / {
            proxy_pass http://synctv_backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 3600s;
        }
    }
}

# RTMP TCP 代理 (需要 stream 模块)
stream {
    upstream rtmp_backend {
        server synctv:1935;
    }

    server {
        listen 1935;
        proxy_pass rtmp_backend;
        proxy_timeout 24h;
    }
}
```

### 3.4 部署命令

```bash
# 1. 生成 JWT 密钥对
mkdir -p config
docker run --rm -v $(pwd)/config:/keys synctv/synctv:latest generate-keys \
  --private-key /keys/jwt-private.pem \
  --public-key /keys/jwt-public.pem

# 2. 启动所有服务
docker-compose up -d

# 3. 查看日志
docker-compose logs -f synctv

# 4. 查看服务状态
docker-compose ps

# 5. 停止服务
docker-compose down

# 6. 完全清理 (包括数据卷)
docker-compose down -v
```

---

## 4. Kubernetes Helm 部署

### 4.1 Helm Chart 结构

```text
synctv-helm/
├── Chart.yaml                 # Chart元数据
├── values.yaml                # 默认配置
├── values-prod.yaml           # 生产环境配置
├── values-dev.yaml            # 开发环境配置
├── templates/
│   ├── _helpers.tpl           # 辅助模板
│   ├── deployment.yaml        # SyncTV部署
│   ├── service.yaml           # Service定义
│   ├── ingress.yaml           # Ingress配置
│   ├── configmap.yaml         # ConfigMap
│   ├── secret.yaml            # Secret
│   ├── hpa.yaml               # 水平扩缩容
│   ├── pdb.yaml               # Pod中断预算
│   ├── servicemonitor.yaml    # Prometheus监控
│   ├── postgres/
│   │   ├── statefulset.yaml   # PostgreSQL
│   │   ├── service.yaml
│   │   └── pvc.yaml
│   └── redis/
│       ├── statefulset.yaml   # Redis
│       ├── service.yaml
│       └── configmap.yaml
└── charts/                    # 子Chart依赖
```

### 4.2 Chart.yaml

```yaml
apiVersion: v2
name: synctv
description: A Helm chart for SyncTV - Multi-user synchronized video watching platform
type: application
version: 1.0.0
appVersion: "1.0.0"
keywords:
  - synctv
  - video
  - streaming
  - rtmp
  - hls
home: https://github.com/your-org/synctv
sources:
  - https://github.com/your-org/synctv
maintainers:
  - name: SyncTV Team
    email: team@synctv.example.com
dependencies:
  - name: postgresql
    version: "12.x.x"
    repository: "https://charts.bitnami.com/bitnami"
    condition: postgresql.enabled
  - name: redis
    version: "18.x.x"
    repository: "https://charts.bitnami.com/bitnami"
    condition: redis.enabled
```

### 4.3 values.yaml (默认配置)

```yaml
# ============================================
# 全局配置
# ============================================
global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""


# ============================================
# SyncTV 应用配置
# ============================================
image:
  registry: docker.io
  repository: synctv/synctv
  tag: "1.0.0"
  pullPolicy: IfNotPresent

replicaCount: 3

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true

service:
  type: ClusterIP
  http:
    port: 8080
    targetPort: 8080
  rtmp:
    port: 1935
    targetPort: 1935
  metrics:
    port: 9090
    targetPort: 9090
  # 注意: 不需要 sessionAffinity,因为使用 Redis Pub/Sub 实现跨节点消息分发
  # WebSocket 客户端可以连接到任意节点,消息会通过 Redis 自动同步到所有节点

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-body-size: "100m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/websocket-services: "synctv"
  hosts:
    - host: synctv.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: synctv-tls
      hosts:
        - synctv.example.com

resources:
  requests:
    cpu: 1000m
    memory: 2Gi
  limits:
    cpu: 2000m
    memory: 4Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - synctv
          topologyKey: kubernetes.io/hostname


# ============================================
# 配置
# ============================================
config:
  # 服务器配置
  server:
    httpAddress: "0.0.0.0"
    httpPort: 8080
    rtmpAddress: "0.0.0.0"
    rtmpPort: 1935

  # JWT配置
  jwt:
    algorithm: "RS256"
    accessTokenExpires: 3600      # 1小时
    refreshTokenExpires: 2592000  # 30天

  # HLS配置
  hls:
    segmentDuration: 2
    playlistLength: 6
    cachePath: "/data/hls"

  # 限制配置
  limits:
    maxRoomMembers: 100
    maxConcurrentStreams: 50
    maxUploadSize: 104857600  # 100MB

  # 日志配置
  logging:
    level: "info"
    format: "json"


# ============================================
# Secrets 配置
# ============================================
secrets:
  # 数据库URL
  databaseUrl: "postgresql://synctv:password@postgres:5432/synctv"

  # Redis URL
  redisUrl: "redis://redis-master:6379"

  # JWT 密钥对 (Base64编码)
  jwtPrivateKey: ""  # 留空则自动生成
  jwtPublicKey: ""

  # SMTP配置
  smtp:
    host: "smtp.example.com"
    port: 587
    username: "noreply@example.com"
    password: "smtp-password"
    from: "SyncTV <noreply@example.com>"

  # OAuth2配置
  oauth2:
    github:
      clientId: ""
      clientSecret: ""
    google:
      clientId: ""
      clientSecret: ""


# ============================================
# 持久化存储
# ============================================
persistence:
  hls:
    enabled: true
    storageClass: "nfs-client"
    accessMode: ReadWriteMany
    size: 100Gi
  cache:
    enabled: true
    storageClass: "local-path"
    accessMode: ReadWriteOnce
    size: 50Gi


# ============================================
# PostgreSQL 配置 (Bitnami Chart)
# ============================================
postgresql:
  enabled: true
  auth:
    username: synctv
    password: change_me_in_production
    database: synctv
  primary:
    persistence:
      enabled: true
      size: 50Gi
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 2000m
        memory: 4Gi


# ============================================
# Redis 配置 (Bitnami Chart)
# ============================================
redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
  master:
    persistence:
      enabled: true
      size: 10Gi
    resources:
      requests:
        cpu: 250m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 2Gi


# ============================================
# 监控配置
# ============================================
serviceMonitor:
  enabled: true
  interval: 30s
  scrapeTimeout: 10s


# ============================================
# Pod 中断预算
# ============================================
podDisruptionBudget:
  enabled: true
  minAvailable: 1
```

### 4.4 templates/deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "synctv.fullname" . }}
  labels:
    {{- include "synctv.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "synctv.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "synctv.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}

      # 初始化容器: 数据库迁移
      initContainers:
        - name: migrate
          image: "{{ .Values.image.registry }}/{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          command: ["/app/synctv", "migrate", "up"]
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: database-url
            - name: RUST_LOG
              value: "info"

      containers:
        - name: synctv
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.registry }}/{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}

          command: ["/app/synctv", "server"]

          ports:
            - name: http
              containerPort: {{ .Values.config.server.httpPort }}
              protocol: TCP
            - name: rtmp
              containerPort: {{ .Values.config.server.rtmpPort }}
              protocol: TCP
            - name: metrics
              containerPort: 9090
              protocol: TCP

          env:
            # Pod信息
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: NODE_ID
              value: "$(POD_NAME)"

            # 数据库
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: database-url

            # Redis
            - name: REDIS_URL
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: redis-url

            # JWT
            - name: JWT_PRIVATE_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: jwt-private-key
            - name: JWT_PUBLIC_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: jwt-public-key

            # SMTP
            - name: SMTP_HOST
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: smtp-host
            - name: SMTP_PORT
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: smtp-port
            - name: SMTP_USERNAME
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: smtp-username
            - name: SMTP_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: smtp-password

            # 从 ConfigMap 读取配置
            - name: HTTP_PORT
              valueFrom:
                configMapKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: http-port
            - name: RTMP_PORT
              valueFrom:
                configMapKeyRef:
                  name: {{ include "synctv.fullname" . }}
                  key: rtmp-port

            # 日志
            - name: RUST_LOG
              value: "{{ .Values.config.logging.level }}"
            - name: LOG_FORMAT
              value: "{{ .Values.config.logging.format }}"

          livenessProbe:
            httpGet:
              path: /health/live
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3

          readinessProbe:
            httpGet:
              path: /health/ready
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 2

          resources:
            {{- toYaml .Values.resources | nindent 12 }}

          volumeMounts:
            - name: hls-cache
              mountPath: /data/hls
            - name: file-cache
              mountPath: /data/cache
            - name: tmp
              mountPath: /tmp

      volumes:
        - name: hls-cache
          {{- if .Values.persistence.hls.enabled }}
          persistentVolumeClaim:
            claimName: {{ include "synctv.fullname" . }}-hls
          {{- else }}
          emptyDir: {}
          {{- end }}
        - name: file-cache
          {{- if .Values.persistence.cache.enabled }}
          persistentVolumeClaim:
            claimName: {{ include "synctv.fullname" . }}-cache
          {{- else }}
          emptyDir:
            sizeLimit: {{ .Values.persistence.cache.size }}
          {{- end }}
        - name: tmp
          emptyDir: {}

      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}

      terminationGracePeriodSeconds: 60
```

### 4.5 部署命令

```bash
# 1. 添加 Helm 仓库
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# 2. 安装 (开发环境)
helm install synctv ./synctv-helm \
  --namespace synctv \
  --create-namespace \
  --values ./synctv-helm/values-dev.yaml

# 3. 安装 (生产环境)
helm install synctv ./synctv-helm \
  --namespace synctv \
  --create-namespace \
  --values ./synctv-helm/values-prod.yaml

# 4. 升级
helm upgrade synctv ./synctv-helm \
  --namespace synctv \
  --values ./synctv-helm/values-prod.yaml

# 5. 回滚到上一个版本
helm rollback synctv --namespace synctv

# 6. 查看部署状态
helm status synctv --namespace synctv

# 7. 卸载
helm uninstall synctv --namespace synctv
```

---

## 5. 配置管理

### 5.1 配置优先级

根据 [19-配置管理系统](./19-配置管理系统.md) 的设计,配置加载优先级为:

```
CLI参数 > 环境变量 > 配置文件 > 数据库 > 默认值
(高)                                         (低)
```

### 5.2 多环境配置示例

**开发环境 (config/development.toml)**:

```toml
[server]
http_address = "127.0.0.1"
http_port = 8080

[database]
url = "postgresql://synctv:dev@localhost:5432/synctv_dev"
max_connections = 5

[redis]
url = "redis://localhost:6379"

[logging]
level = "debug"
format = "pretty"

[limits]
max_room_members = 10
max_concurrent_streams = 5
```

**生产环境 (config/production.toml)**:

```toml
[server]
http_address = "0.0.0.0"
http_port = 8080

# 数据库和Redis从环境变量读取
# DATABASE_URL, REDIS_URL

[logging]
level = "info"
format = "json"

[limits]
max_room_members = 100
max_concurrent_streams = 50

[security]
enable_rate_limiting = true
rate_limit_requests_per_minute = 60
```

---

## 6. 部署最佳实践

### 6.1 安全性

#### 生成强密码

```bash
# 生成随机密码
openssl rand -base64 32

# 生成 JWT RS256 密钥对
openssl genrsa -out jwt-private.pem 4096
openssl rsa -in jwt-private.pem -pubout -out jwt-public.pem
```

#### 使用 Secrets 管理敏感信息

```bash
# Kubernetes Secrets
kubectl create secret generic synctv-secrets \
  --from-literal=database-url="postgresql://..." \
  --from-literal=redis-url="redis://..." \
  --from-file=jwt-private-key=./jwt-private.pem \
  --from-file=jwt-public-key=./jwt-public.pem \
  --namespace synctv
```

### 6.2 监控与日志

#### 健康检查端点

- `/health/live`: 存活检查 (进程是否运行)
- `/health/ready`: 就绪检查 (是否可以接受流量)
- `/metrics`: Prometheus 指标

#### 日志收集

```yaml
# Fluentd/Fluent Bit 配置示例
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    [INPUT]
        Name              tail
        Path              /var/log/containers/*synctv*.log
        Parser            docker
        Tag               kube.*
        Refresh_Interval  5

    [OUTPUT]
        Name   es
        Match  kube.*
        Host   elasticsearch.logging.svc.cluster.local
        Port   9200
        Index  synctv
```

### 6.3 备份策略

```bash
# PostgreSQL 备份
kubectl exec -n synctv postgres-0 -- pg_dump -U synctv synctv > backup-$(date +%Y%m%d).sql

# 恢复
kubectl exec -i -n synctv postgres-0 -- psql -U synctv synctv < backup-20260130.sql
```

### 6.4 性能调优

#### PostgreSQL 连接池

```toml
[database]
max_connections = 20        # 生产环境推荐 20-50
min_connections = 5
connection_timeout = 30
idle_timeout = 600
```

#### Redis 配置

```toml
[redis]
max_connections = 10
connection_timeout = 5
pool_timeout = 10
```

### 6.5 滚动更新策略

```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1         # 最多多1个Pod
      maxUnavailable: 0   # 保证零停机
```

---

## 总结

本章节提供了三种部署方案:

✅ **Docker 单节点**: 适合开发测试、小规模部署
✅ **Docker Compose**: 包含完整依赖,易于团队部署
✅ **Kubernetes Helm**: 企业级部署,支持自动扩缩容和高可用

**部署选择建议**:

- 开发测试: Docker 单容器
- 小型团队: Docker Compose (< 1000 用户)
- 大规模生产: Kubernetes Helm (> 1000 用户)

**下一章**: [23-监控优化](./23-监控优化.md)

---

**上一章**: [21-关键实现](./21-关键实现.md)
**下一章**: [23-监控优化](./23-监控优化.md)
