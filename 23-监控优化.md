# 14. 监控优化

---

## 14.1 监控指标与日志

### 14.1.1 Prometheus 监控

#### ServiceMonitor 配置

```yaml
# synctv-servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: synctv
  namespace: synctv
  labels:
    app: synctv
spec:
  selector:
    matchLabels:
      app: synctv
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
```

#### 关键指标

| 指标名称 | 类型 | 说明 |
| --- | --- | --- |
| `synctv_active_rooms` | Gauge | 活跃房间数 |
| `synctv_active_streams` | Gauge | 活跃流数量 |
| `synctv_connected_users` | Gauge | 在线用户数 |
| `http_request_duration_seconds` | Histogram | HTTP请求延迟 |
| `http_requests_total` | Counter | HTTP请求总数 |
| `websocket_connections_total` | Gauge | WebSocket连接数 |
| `stream_bitrate_bytes` | Gauge | 流媒体码率 |
| `cache_hit_rate` | Gauge | 缓存命中率 |
| `db_connection_pool_size` | Gauge | 数据库连接池大小 |
| `redis_connection_errors_total` | Counter | Redis连接错误数 |

#### Metrics 实现

```rust
use prometheus::{
    Counter, Gauge, Histogram, HistogramOpts, IntCounter, IntGauge,
    Opts, Registry, TextEncoder,
};
use std::sync::Arc;

pub struct Metrics {
    pub active_rooms: IntGauge,
    pub active_streams: IntGauge,
    pub connected_users: IntGauge,
    pub http_requests_total: IntCounter,
    pub http_request_duration: Histogram,
    pub websocket_connections: IntGauge,
    pub cache_hit_total: IntCounter,
    pub cache_miss_total: IntCounter,
    pub db_queries_total: IntCounter,
    pub stream_bitrate: Gauge,
}

impl Metrics {
    pub fn new(registry: &Registry) -> Result<Self> {
        let active_rooms = IntGauge::with_opts(
            Opts::new("synctv_active_rooms", "Number of active rooms")
        )?;
        registry.register(Box::new(active_rooms.clone()))?;

        let active_streams = IntGauge::with_opts(
            Opts::new("synctv_active_streams", "Number of active streams")
        )?;
        registry.register(Box::new(active_streams.clone()))?;

        let connected_users = IntGauge::with_opts(
            Opts::new("synctv_connected_users", "Number of connected users")
        )?;
        registry.register(Box::new(connected_users.clone()))?;

        let http_requests_total = IntCounter::with_opts(
            Opts::new("http_requests_total", "Total number of HTTP requests")
        )?;
        registry.register(Box::new(http_requests_total.clone()))?;

        let http_request_duration = Histogram::with_opts(
            HistogramOpts::new(
                "http_request_duration_seconds",
                "HTTP request latency in seconds"
            )
            .buckets(vec![0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0])
        )?;
        registry.register(Box::new(http_request_duration.clone()))?;

        let websocket_connections = IntGauge::with_opts(
            Opts::new("websocket_connections_total", "Active WebSocket connections")
        )?;
        registry.register(Box::new(websocket_connections.clone()))?;

        let cache_hit_total = IntCounter::with_opts(
            Opts::new("cache_hit_total", "Total cache hits")
        )?;
        registry.register(Box::new(cache_hit_total.clone()))?;

        let cache_miss_total = IntCounter::with_opts(
            Opts::new("cache_miss_total", "Total cache misses")
        )?;
        registry.register(Box::new(cache_miss_total.clone()))?;

        let db_queries_total = IntCounter::with_opts(
            Opts::new("db_queries_total", "Total database queries")
        )?;
        registry.register(Box::new(db_queries_total.clone()))?;

        let stream_bitrate = Gauge::with_opts(
            Opts::new("stream_bitrate_bytes", "Stream bitrate in bytes per second")
        )?;
        registry.register(Box::new(stream_bitrate.clone()))?;

        Ok(Self {
            active_rooms,
            active_streams,
            connected_users,
            http_requests_total,
            http_request_duration,
            websocket_connections,
            cache_hit_total,
            cache_miss_total,
            db_queries_total,
            stream_bitrate,
        })
    }

    pub fn export(&self) -> String {
        let encoder = TextEncoder::new();
        let metric_families = prometheus::gather();
        encoder.encode_to_string(&metric_families).unwrap()
    }
}

// Metrics中间件
pub async fn metrics_middleware(
    Extension(metrics): Extension<Arc<Metrics>>,
    request: Request<Body>,
    next: Next,
) -> Response {
    let start = std::time::Instant::now();
    metrics.http_requests_total.inc();

    let response = next.run(request).await;

    let duration = start.elapsed().as_secs_f64();
    metrics.http_request_duration.observe(duration);

    response
}

// Metrics端点
pub async fn metrics_handler(
    Extension(metrics): Extension<Arc<Metrics>>,
) -> impl IntoResponse {
    metrics.export()
}
```

### 14.1.2 Grafana Dashboard

#### Dashboard 配置

```json
{
  "dashboard": {
    "title": "SyncTV Metrics Dashboard",
    "panels": [
      {
        "title": "Active Rooms",
        "type": "graph",
        "targets": [
          {
            "expr": "synctv_active_rooms",
            "legendFormat": "Active Rooms"
          }
        ]
      },
      {
        "title": "Active Streams",
        "type": "graph",
        "targets": [
          {
            "expr": "synctv_active_streams",
            "legendFormat": "Active Streams"
          }
        ]
      },
      {
        "title": "Connected Users",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(synctv_connected_users)",
            "legendFormat": "Total Users"
          }
        ]
      },
      {
        "title": "HTTP Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "Requests/sec"
          }
        ]
      },
      {
        "title": "Request Latency (P95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "P95 Latency"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "type": "gauge",
        "targets": [
          {
            "expr": "rate(cache_hit_total[5m]) / (rate(cache_hit_total[5m]) + rate(cache_miss_total[5m])) * 100",
            "legendFormat": "Hit Rate %"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "db_connection_pool_size",
            "legendFormat": "Pool Size"
          }
        ]
      },
      {
        "title": "Stream Bitrate",
        "type": "graph",
        "targets": [
          {
            "expr": "stream_bitrate_bytes",
            "legendFormat": "Bitrate (bytes/s)"
          }
        ]
      }
    ]
  }
}
```

### 14.1.3 日志收集

#### Fluent Bit 配置

```yaml
# fluent-bit-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: synctv
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         5
        Daemon        off
        Log_Level     info
        Parsers_File  parsers.conf

    [INPUT]
        Name              tail
        Path              /var/log/containers/synctv-*.log
        Parser            docker
        Tag               kube.*
        Refresh_Interval  5
        Mem_Buf_Limit     5MB
        Skip_Long_Lines   On

    [FILTER]
        Name                kubernetes
        Match               kube.*
        Kube_URL            https://kubernetes.default.svc:443
        Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
        Merge_Log           On
        Keep_Log            Off

    [FILTER]
        Name    parser
        Match   kube.*
        Key_Name log
        Parser  json

    [OUTPUT]
        Name            es
        Match           *
        Host            elasticsearch
        Port            9200
        Logstash_Format On
        Logstash_Prefix synctv
        Retry_Limit     5

  parsers.conf: |
    [PARSER]
        Name   json
        Format json
        Time_Key time
        Time_Format %Y-%m-%dT%H:%M:%S.%LZ
```

#### 结构化日志实现

```rust
use tracing::{info, warn, error, debug};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

pub fn init_logging() {
    tracing_subscriber::registry()
        .with(EnvFilter::from_default_env())
        .with(
            tracing_subscriber::fmt::layer()
                .json()  // JSON格式日志
                .with_current_span(true)
                .with_span_list(true)
        )
        .init();
}

// 使用结构化日志
info!(
    user_id = %user.id,
    room_id = %room_id,
    action = "join_room",
    "User joined room"
);

error!(
    error = %e,
    stream_key = %stream_key,
    "Failed to start stream"
);
```

## 14.2 数据库优化

### 14.2.1 连接池配置

```rust
use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_pool(database_url: &str) -> Result<PgPool> {
    PgPoolOptions::new()
        .max_connections(50)          // 最大连接数
        .min_connections(10)          // 最小连接数
        .acquire_timeout(Duration::from_secs(3))
        .idle_timeout(Some(Duration::from_secs(300)))  // 5分钟
        .max_lifetime(Some(Duration::from_secs(1800))) // 30分钟

        // 测试连接有效性
        .test_before_acquire(true)

        // 连接创建时执行
        .after_connect(|conn, _meta| Box::pin(async move {
            conn.execute("SET application_name = 'synctv'").await?;
            conn.execute("SET timezone = 'UTC'").await?;
            Ok(())
        }))

        .connect(database_url)
        .await
        .map_err(Into::into)
}
```

### 14.2.2 查询优化

#### 添加索引

```sql
-- 部分索引（减少索引大小）
CREATE INDEX idx_active_rooms
ON rooms(id)
WHERE status = 'active';

-- 表达式索引
CREATE INDEX idx_username_lower
ON users(LOWER(username));

-- 覆盖索引（避免回表）
CREATE INDEX idx_room_members_permissions
ON room_members(room_id, user_id)
INCLUDE (permissions, admin_permissions, role);

-- 复合索引
CREATE INDEX idx_chat_messages_room_time
ON chat_messages(room_id, created_at DESC);
```

#### 物化视图

```sql
-- 物化视图（预计算）
CREATE MATERIALIZED VIEW room_stats AS
SELECT
    r.id as room_id,
    r.name,
    COUNT(DISTINCT rm.user_id) as member_count,
    COUNT(DISTINCT CASE WHEN rm.role = 'admin' THEN rm.user_id END) as admin_count,
    MAX(rm.joined_at) as last_join_time
FROM rooms r
LEFT JOIN room_members rm ON r.id = rm.room_id
GROUP BY r.id, r.name;

CREATE UNIQUE INDEX ON room_stats(room_id);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY room_stats;
```

#### 分区表

```sql
-- 按时间分区聊天消息表
CREATE TABLE chat_messages (
    id VARCHAR(36),
    room_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    username VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'text',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- 创建分区（每月一个）
CREATE TABLE chat_messages_2026_01 PARTITION OF chat_messages
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE chat_messages_2026_02 PARTITION OF chat_messages
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');
```

## 14.3 缓存优化

### 14.3.1 Redis Pipeline

批量操作使用Pipeline减少网络往返：

```rust
use redis::pipe;

pub async fn batch_get_user_info(
    redis: &mut ConnectionManager,
    user_ids: &[i64],
) -> Result<Vec<Option<User>>> {
    let mut pipe = redis::pipe();

    for user_id in user_ids {
        pipe.get(format!("user:{}:info", user_id));
    }

    let results: Vec<Option<String>> = pipe.query_async(redis).await?;

    results.into_iter()
        .map(|s| s.and_then(|json| serde_json::from_str(&json).ok()))
        .collect()
}

pub async fn batch_set_room_info(
    redis: &mut ConnectionManager,
    rooms: &[(i64, Room)],
) -> Result<()> {
    let mut pipe = redis::pipe();

    for (room_id, room) in rooms {
        let json = serde_json::to_string(room)?;
        pipe.set_ex(format!("room:{}:info", room_id), json, 3600);
    }

    pipe.query_async(redis).await?;
    Ok(())
}
```

### 14.3.2 缓存预热

```rust
pub struct CacheWarmer {
    local_cache: Arc<LocalCache<String, Arc<Bytes>>>,
    redis: Arc<RedisClient>,
    db: Arc<PgPool>,
}

impl CacheWarmer {
    pub async fn warmup(&self) -> Result<()> {
        // 预热热门房间数据
        let hot_rooms = sqlx::query_as!(
            Room,
            "SELECT * FROM rooms
             WHERE status = 'active'
             ORDER BY member_count DESC
             LIMIT 100"
        )
        .fetch_all(&*self.db)
        .await?;

        for room in hot_rooms {
            let key = format!("room:{}", room.id);
            let json = serde_json::to_vec(&room)?;

            // 写入本地缓存
            self.local_cache.insert(
                key.clone(),
                Arc::new(Bytes::from(json.clone())),
                3600,
            ).await;

            // 写入Redis
            self.redis.set_ex(&key, &json, 3600).await?;
        }

        info!("Cache warmed up with {} rooms", hot_rooms.len());
        Ok(())
    }

    pub async fn warmup_user_data(&self, user_ids: &[i64]) -> Result<()> {
        let users = sqlx::query_as!(
            User,
            "SELECT * FROM users WHERE id = ANY($1)",
            user_ids
        )
        .fetch_all(&*self.db)
        .await?;

        for user in users {
            let key = format!("user:{}:info", user.id);
            let json = serde_json::to_vec(&user)?;
            self.redis.set_ex(&key, &json, 1800).await?;
        }

        Ok(())
    }
}
```

### 14.3.3 缓存策略

| 数据类型 | 缓存层级 | TTL | 更新策略 |
| --- | --- | --- | --- |
| 房间信息 | 本地+Redis | 1小时 | 写穿透 |
| 用户信息 | Redis | 30分钟 | 延迟失效 |
| 房间成员列表 | Redis | 5分钟 | 主动刷新 |
| HLS切片 | 本地磁盘 | 10秒 | 自动清理 |
| GOP缓存 | 内存 | 无限 | LRU淘汰 |

## 14.4 网络与流媒体优化

### 14.4.1 HTTP/2 支持

```rust
use axum_server::tls_rustls::RustlsConfig;

pub async fn run_https_server(config: &Config) -> Result<()> {
    let tls_config = RustlsConfig::from_pem_file(
        "/path/to/cert.pem",
        "/path/to/key.pem"
    ).await?;

    let addr = format!("{}:{}", config.server.https_address, config.server.https_port)
        .parse()?;

    axum_server::bind_rustls(addr, tls_config)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
```

### 14.4.2 响应压缩

```rust
use tower_http::compression::{CompressionLayer, CompressionLevel};

let app = Router::new()
    .route("/api/rooms", get(list_rooms))
    .route("/api/rooms/:id", get(get_room))
    .layer(
        CompressionLayer::new()
            .br(true)      // Brotli
            .gzip(true)    // Gzip
            .deflate(true) // Deflate
            .quality(CompressionLevel::Fastest)
    );
```

### 14.4.3 GOP 缓存优化

```rust
pub struct GopCacheConfig {
    pub max_gops: usize,           // 最多缓存GOP数量：2
    pub max_duration_ms: u64,      // 最多缓存时长：10秒
    pub max_size_bytes: usize,     // 最多缓存大小：10MB
}

impl GopCache {
    pub fn new(config: GopCacheConfig) -> Self {
        Self {
            gops: Vec::with_capacity(config.max_gops),
            config,
            total_size: 0,
            start_time: None,
        }
    }

    pub fn add_packet(&mut self, packet: MediaPacket) {
        if packet.is_keyframe {
            // 新GOP开始
            if self.gops.len() >= self.config.max_gops {
                if let Some(old_gop) = self.gops.remove(0) {
                    self.total_size -= old_gop.iter()
                        .map(|p| p.data.len())
                        .sum::<usize>();
                }
            }
            self.gops.push(Vec::new());
            self.start_time = Some(Instant::now());
        }

        if let Some(current_gop) = self.gops.last_mut() {
            self.total_size += packet.data.len();
            current_gop.push(packet);
        }

        // 检查大小限制
        self.enforce_limits();
    }

    fn enforce_limits(&mut self) {
        // 检查时长限制
        if let Some(start) = self.start_time {
            if start.elapsed().as_millis() as u64 > self.config.max_duration_ms {
                if !self.gops.is_empty() {
                    if let Some(old_gop) = self.gops.remove(0) {
                        self.total_size -= old_gop.iter()
                            .map(|p| p.data.len())
                            .sum::<usize>();
                    }
                }
            }
        }

        // 检查大小限制
        while self.total_size > self.config.max_size_bytes && !self.gops.is_empty() {
            if let Some(old_gop) = self.gops.remove(0) {
                self.total_size -= old_gop.iter()
                    .map(|p| p.data.len())
                    .sum::<usize>();
            }
        }
    }

    pub fn get_all_packets(&self) -> Vec<MediaPacket> {
        self.gops.iter()
            .flatten()
            .cloned()
            .collect()
    }
}
```

### 14.4.4 HLS 切片优化

配置优化以降低延迟：

```toml
[hls]
segment_duration = 2              # 2秒切片（低延迟）
playlist_length = 6               # 保留6个切片
delete_threshold = 10             # 删除10秒前的切片
enable_ll_hls = true              # 启用Low-Latency HLS
partial_segment_duration = 0.5   # 部分切片500ms
```

```rust
pub struct HlsConfig {
    pub segment_duration: u32,
    pub playlist_length: usize,
    pub delete_threshold: u32,
    pub enable_ll_hls: bool,
    pub partial_segment_duration: f64,
}

impl HlsWriter {
    pub fn new(config: HlsConfig) -> Self {
        Self {
            config,
            segments: VecDeque::with_capacity(config.playlist_length),
            sequence_number: 0,
            target_duration: config.segment_duration,
        }
    }

    pub async fn write_segment(&mut self, data: Bytes) -> Result<()> {
        let segment = Segment {
            sequence: self.sequence_number,
            duration: self.config.segment_duration as f64,
            data,
            timestamp: Utc::now(),
        };

        self.segments.push_back(segment);
        self.sequence_number += 1;

        // 保持固定数量的切片
        while self.segments.len() > self.config.playlist_length {
            self.segments.pop_front();
        }

        // 清理过期切片
        self.cleanup_old_segments().await?;

        Ok(())
    }

    async fn cleanup_old_segments(&mut self) -> Result<()> {
        let now = Utc::now();
        let threshold = Duration::seconds(self.config.delete_threshold as i64);

        self.segments.retain(|seg| {
            now.signed_duration_since(seg.timestamp) < threshold
        });

        Ok(())
    }
}
```

## 14.5 并发优化

### 14.5.1 自定义 Tokio 运行时

```rust
use tokio::runtime::{Builder, Runtime};

pub fn create_optimized_runtime() -> io::Result<Runtime> {
    Builder::new_multi_thread()
        .worker_threads(num_cpus::get())
        .thread_name("synctv-worker")
        .thread_stack_size(3 * 1024 * 1024)
        .enable_all()
        .on_thread_start(|| {
            debug!("Worker thread started");
        })
        .on_thread_stop(|| {
            debug!("Worker thread stopped");
        })
        .build()
}
```

### 14.5.2 工作窃取调度

Tokio 默认使用工作窃取调度器，自动平衡任务负载：

```rust
// 使用spawn_blocking处理CPU密集型任务
pub async fn process_video_frame(frame: VideoFrame) -> Result<ProcessedFrame> {
    tokio::task::spawn_blocking(move || {
        // CPU密集型处理
        expensive_video_processing(frame)
    })
    .await?
}

// 使用spawn处理异步任务
pub async fn handle_stream(stream: TcpStream) {
    tokio::spawn(async move {
        if let Err(e) = process_stream(stream).await {
            error!("Stream processing error: {}", e);
        }
    });
}
```

### 14.5.3 并发限制

```rust
use tokio::sync::Semaphore;

pub struct ConcurrencyLimiter {
    semaphore: Arc<Semaphore>,
}

impl ConcurrencyLimiter {
    pub fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }

    pub async fn run<F, T>(&self, f: F) -> Result<T>
    where
        F: Future<Output = Result<T>>,
    {
        let _permit = self.semaphore.acquire().await?;
        f.await
    }
}

// 使用示例：限制同时处理的流数量
let limiter = ConcurrencyLimiter::new(50);

limiter.run(async {
    process_rtmp_stream(stream).await
}).await?;
```

### 14.5.4 性能基准测试

```rust
#[cfg(test)]
mod benches {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn bench_gop_cache(c: &mut Criterion) {
        c.bench_function("gop_cache_add", |b| {
            let mut cache = GopCache::new(GopCacheConfig {
                max_gops: 2,
                max_duration_ms: 10000,
                max_size_bytes: 10 * 1024 * 1024,
            });

            b.iter(|| {
                cache.add_packet(black_box(MediaPacket {
                    is_keyframe: false,
                    timestamp: 0,
                    data: vec![0u8; 1024].into(),
                }));
            });
        });
    }

    criterion_group!(benches, bench_gop_cache);
    criterion_main!(benches);
}
```

---

**上一章**: [22-部署方案](./22-部署方案.md)
**下一章**: [24-安全故障](./24-安全故障.md)
