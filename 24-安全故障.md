# 15. 安全与故障处理

---

## 目录

- [1. 认证与授权](#1-认证与授权)
- [2. 传输与数据安全](#2-传输与数据安全)
- [3. 输入验证与防攻击](#3-输入验证与防攻击)
- [4. 常见故障场景](#4-常见故障场景)
- [5. 熔断器与降级](#5-熔断器与降级)
- [6. 审计与监控](#6-审计与监控)

---

## 1. 认证与授权

> 详细设计参见 [06-用户系统设计](./06-用户系统设计.md) 和 [07-权限系统设计](./07-权限系统设计.md)

### 1.1 JWT Token (RS256)

**核心设计**: 使用 RS256 非对称加密,私钥签名,公钥验证,多副本友好

```rust
use jsonwebtoken::{encode, decode, Header, Algorithm, Validation, EncodingKey, DecodingKey};
use serde::{Serialize, Deserialize};
use chrono::Utc;
use uuid::Uuid;

/// JWT Claims (访问令牌)
#[derive(Debug, Serialize, Deserialize)]
pub struct AccessClaims {
    /// 用户ID (nanoid)
    pub sub: String,

    /// 用户名
    pub username: String,

    /// 全局角色
    pub role: UserRole,

    /// 签发时间
    pub iat: i64,

    /// 过期时间 (1小时)
    pub exp: i64,

    /// JWT ID (用于撤销, nanoid)
    pub jti: String,

    /// 签发者 (节点 ID)
    pub iss: String,
}

/// JWT Claims (刷新令牌)
#[derive(Debug, Serialize, Deserialize)]
pub struct RefreshClaims {
    /// 用户ID (nanoid)
    pub sub: String,
    pub iat: i64,
    pub exp: i64,  // 30天
    /// JWT ID (用于撤销, nanoid)
    pub jti: String,
    /// 签发者 (节点 ID)
    pub iss: String,
}

pub struct JwtManager {
    /// 私钥 (用于签名)
    encoding_key: EncodingKey,

    /// 公钥 (用于验证)
    decoding_key: DecodingKey,

    /// 算法: RS256
    algorithm: Algorithm,

    /// 访问令牌过期时间 (秒)
    access_token_expires: i64,

    /// 刷新令牌过期时间 (秒)
    refresh_token_expires: i64,
}

impl JwtManager {
    /// 从PEM格式密钥创建
    pub fn from_pem(private_key_pem: &[u8], public_key_pem: &[u8]) -> Result<Self> {
        Ok(Self {
            encoding_key: EncodingKey::from_rsa_pem(private_key_pem)?,
            decoding_key: DecodingKey::from_rsa_pem(public_key_pem)?,
            algorithm: Algorithm::RS256,
            access_token_expires: 3600,      // 1小时
            refresh_token_expires: 2592000,  // 30天
        })
    }

    /// 生成访问令牌
    pub fn generate_access_token(
        &self,
        user_id: &str,  // nanoid
        username: String,
        role: UserRole,
        node_id: &str,
    ) -> Result<String> {
        let now = Utc::now().timestamp();

        let claims = AccessClaims {
            sub: user_id.to_string(),
            username,
            role,
            iat: now,
            exp: now + self.access_token_expires,
            jti: nanoid::nanoid!(21),
            iss: node_id.to_string(),
        };

        encode(&Header::new(self.algorithm), &claims, &self.encoding_key)
            .map_err(Into::into)
    }

    /// 生成刷新令牌
    pub fn generate_refresh_token(&self, user_id: &str, node_id: &str) -> Result<String> {  // nanoid
        let now = Utc::now().timestamp();

        let claims = RefreshClaims {
            sub: user_id.to_string(),
            iat: now,
            exp: now + self.refresh_token_expires,
            jti: nanoid::nanoid!(21),
            iss: node_id.to_string(),
        };

        encode(&Header::new(self.algorithm), &claims, &self.encoding_key)
            .map_err(Into::into)
    }

    /// 验证访问令牌
    pub fn verify_access_token(&self, token: &str) -> Result<AccessClaims> {
        let mut validation = Validation::new(self.algorithm);
        validation.validate_exp = true;
        validation.set_issuer(&["synctv"]);

        let token_data = decode::<AccessClaims>(token, &self.decoding_key, &validation)?;

        Ok(token_data.claims)
    }

    /// 验证刷新令牌
    pub fn verify_refresh_token(&self, token: &str) -> Result<RefreshClaims> {
        let mut validation = Validation::new(self.algorithm);
        validation.validate_exp = true;
        validation.set_issuer(&["synctv"]);

        let token_data = decode::<RefreshClaims>(token, &self.decoding_key, &validation)?;

        Ok(token_data.claims)
    }
}
```

#### Token 撤销黑名单

```rust
pub struct TokenBlacklist {
    redis: Arc<RedisClient>,
}

impl TokenBlacklist {
    /// 撤销Token (添加到黑名单)
    pub async fn revoke(&self, jti: &str, exp: i64) -> Result<()> {
        let now = Utc::now().timestamp();
        let ttl = (exp - now).max(0) as u64;

        // 存储到Redis,过期时间与Token一致
        self.redis.set_ex(
            &format!("token:revoked:{}", jti),
            "1",
            ttl,
        ).await?;

        Ok(())
    }

    /// 检查Token是否被撤销
    pub async fn is_revoked(&self, jti: &str) -> Result<bool> {
        Ok(self.redis.exists(&format!("token:revoked:{}", jti)).await?)
    }
}
```

#### 认证中间件

```rust
/// JWT认证中间件
pub async fn jwt_auth_middleware(
    State(state): State<AppState>,
    mut request: Request<Body>,
    next: Next,
) -> Result<Response> {
    // 1. 提取Token
    let token = request.headers()
        .get(header::AUTHORIZATION)
        .and_then(|h| h.to_str().ok())
        .and_then(|h| h.strip_prefix("Bearer "))
        .ok_or(Error::MissingToken)?;

    // 2. 验证Token
    let claims = state.jwt_manager.verify_access_token(token)?;

    // 3. 检查是否被撤销
    if state.token_blacklist.is_revoked(&claims.jti).await? {
        return Err(Error::TokenRevoked);
    }

    // 4. 检查用户是否被封禁
    let user = state.user_service.get_user(claims.sub).await?;
    if user.role == UserRole::Banned {
        return Err(Error::UserBanned);
    }

    // 5. 将用户信息注入请求
    request.extensions_mut().insert(claims);
    request.extensions_mut().insert(user);

    Ok(next.run(request).await)
}

/// 可选认证中间件 (允许匿名访问)
pub async fn optional_auth_middleware(
    State(state): State<AppState>,
    mut request: Request<Body>,
    next: Next,
) -> Response {
    // 尝试提取Token
    if let Some(token) = request.headers()
        .get(header::AUTHORIZATION)
        .and_then(|h| h.to_str().ok())
        .and_then(|h| h.strip_prefix("Bearer "))
    {
        // 验证Token (忽略错误)
        if let Ok(claims) = state.jwt_manager.verify_access_token(token) {
            if !state.token_blacklist.is_revoked(&claims.jti).await.unwrap_or(false) {
                if let Ok(user) = state.user_service.get_user(claims.sub).await {
                    request.extensions_mut().insert(claims);
                    request.extensions_mut().insert(user);
                }
            }
        }
    }

    next.run(request).await
}
```

### 1.2 OAuth2 认证 (PKCE)

**支持提供商**: GitHub, GitLab, Google, Discord, Microsoft, OIDC通用

```rust
use oauth2::{
    AuthUrl, AuthorizationCode, ClientId, ClientSecret, CsrfToken,
    PkceCodeChallenge, PkceCodeVerifier, RedirectUrl, Scope, TokenUrl,
    basic::BasicClient, reqwest::async_http_client,
};

pub struct OAuth2Manager {
    providers: HashMap<String, BasicClient>,
    pkce_verifiers: Arc<DashMap<String, PkceCodeVerifier>>,
}

impl OAuth2Manager {
    /// 生成授权URL (带PKCE)
    pub async fn generate_authorization_url(
        &self,
        provider: &str,
    ) -> Result<(String, String)> {
        let client = self.providers.get(provider)
            .ok_or(Error::UnsupportedProvider)?;

        // 生成 PKCE challenge
        let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

        // 生成授权URL
        let (auth_url, csrf_token) = client
            .authorize_url(CsrfToken::new_random)
            .add_scope(Scope::new("user:email".to_string()))
            .set_pkce_challenge(pkce_challenge)
            .url();

        // 存储 PKCE verifier
        self.pkce_verifiers.insert(
            csrf_token.secret().clone(),
            pkce_verifier,
        );

        Ok((auth_url.to_string(), csrf_token.secret().clone()))
    }

    /// 交换授权码获取Token
    pub async fn exchange_code(
        &self,
        provider: &str,
        code: String,
        csrf_token: String,
    ) -> Result<String> {
        let client = self.providers.get(provider)
            .ok_or(Error::UnsupportedProvider)?;

        // 获取 PKCE verifier
        let pkce_verifier = self.pkce_verifiers.remove(&csrf_token)
            .ok_or(Error::InvalidCsrfToken)?
            .1;

        // 交换授权码
        let token_result = client
            .exchange_code(AuthorizationCode::new(code))
            .set_pkce_verifier(pkce_verifier)
            .request_async(async_http_client)
            .await?;

        Ok(token_result.access_token().secret().clone())
    }
}
```

### 1.3 密码安全 (Argon2id)

**算法**: Argon2id (2023年密码哈希竞赛冠军)

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2, ParamsBuilder, Algorithm, Version,
};

pub struct PasswordHasher {
    argon2: Argon2<'static>,
}

impl PasswordHasher {
    pub fn new() -> Result<Self> {
        // Argon2id 参数配置
        let params = ParamsBuilder::new()
            .m_cost(19456)     // 19 MiB
            .t_cost(2)         // 2 iterations
            .p_cost(1)         // 1 thread
            .build()?;

        let argon2 = Argon2::new(
            Algorithm::Argon2id,
            Version::V0x13,
            params,
        );

        Ok(Self { argon2 })
    }

    /// 哈希密码
    pub fn hash_password(&self, password: &str) -> Result<String> {
        let salt = SaltString::generate(&mut OsRng);
        let password_hash = self.argon2
            .hash_password(password.as_bytes(), &salt)?
            .to_string();

        Ok(password_hash)
    }

    /// 验证密码
    pub fn verify_password(&self, password: &str, hash: &str) -> Result<bool> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|_| Error::InvalidPasswordHash)?;

        Ok(self.argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
    }
}

/// 密码强度验证
pub fn validate_password_strength(password: &str) -> Result<()> {
    if password.len() < 8 {
        return Err(Error::WeakPassword("密码至少需要8个字符"));
    }

    if password.len() > 128 {
        return Err(Error::WeakPassword("密码不能超过128个字符"));
    }

    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_digit = password.chars().any(|c| c.is_ascii_digit());
    let has_special = password.chars().any(|c| !c.is_alphanumeric());

    let strength = [has_uppercase, has_lowercase, has_digit, has_special]
        .iter()
        .filter(|&&x| x)
        .count();

    if strength < 3 {
        return Err(Error::WeakPassword(
            "密码必须包含大写、小写、数字、特殊字符中的至少3种"
        ));
    }

    Ok(())
}
```

### 1.4 权限系统 (Telegram-like)

> 详细设计参见 [07-权限系统设计](./07-权限系统设计.md)

```rust
/// 成员权限 (64位掩码)
#[derive(Debug, Clone, Copy)]
pub struct MemberPermissions(pub u64);

impl MemberPermissions {
    // 基础权限 (bit 0-9)
    pub const SEND_CHAT_MESSAGE: u64 = 1 << 0;
    pub const SEND_EMOJI: u64 = 1 << 1;
    pub const ADD_MOVIE: u64 = 1 << 2;
    pub const DELETE_MOVIE: u64 = 1 << 3;
    pub const EDIT_MOVIE: u64 = 1 << 4;
    pub const REORDER_PLAYLIST: u64 = 1 << 5;
    pub const PLAY_CONTROL: u64 = 1 << 6;
    pub const CHANGE_CURRENT_MOVIE: u64 = 1 << 7;
    pub const INVITE_MEMBERS: u64 = 1 << 8;
    pub const VIEW_MEMBER_LIST: u64 = 1 << 9;

    // 管理权限 (bit 10-19)
    pub const KICK_MEMBERS: u64 = 1 << 10;
    pub const BAN_MEMBERS: u64 = 1 << 11;
    pub const EDIT_ROOM_INFO: u64 = 1 << 12;
    pub const EDIT_ROOM_SETTINGS: u64 = 1 << 13;
    pub const MANAGE_ADMINS: u64 = 1 << 14;
    pub const VIEW_AUDIT_LOG: u64 = 1 << 15;

    /// 检查是否有权限
    pub fn has(&self, permission: u64) -> bool {
        (self.0 & permission) != 0
    }

    /// 添加权限
    pub fn grant(&mut self, permission: u64) {
        self.0 |= permission;
    }

    /// 移除权限
    pub fn revoke(&mut self, permission: u64) {
        self.0 &= !permission;
    }
}

/// 房间成员
#[derive(Debug, Clone)]
pub struct RoomMember {
    pub user_id: Uuid,
    pub room_id: Uuid,
    pub role: RoomRole,
    pub permissions: MemberPermissions,
    pub joined_at: DateTime<Utc>,
}

/// 房间角色
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RoomRole {
    Creator,    // 创建者 (最高权限)
    Admin,      // 管理员
    Member,     // 普通成员
    Guest,      // 访客 (受限权限)
}

impl RoomMember {
    /// 检查是否有权限
    pub fn has_permission(&self, permission: u64) -> bool {
        match self.role {
            RoomRole::Creator => true,  // 创建者拥有所有权限
            RoomRole::Admin | RoomRole::Member => self.permissions.has(permission),
            RoomRole::Guest => {
                // 访客只有查看权限
                let guest_permissions = MemberPermissions::SEND_CHAT_MESSAGE
                    | MemberPermissions::SEND_EMOJI
                    | MemberPermissions::VIEW_MEMBER_LIST;
                (permission & guest_permissions) != 0
            }
        }
    }
}

/// 权限检查中间件
pub async fn require_room_permission(
    State(state): State<AppState>,
    Extension(user): Extension<User>,
    Path(room_id): Path<Uuid>,
    required_permission: u64,
    request: Request<Body>,
    next: Next,
) -> Result<Response> {
    // 获取房间成员信息
    let member = state.room_service
        .get_member(room_id, user.id)
        .await?
        .ok_or(Error::NotInRoom)?;

    // 检查权限
    if !member.has_permission(required_permission) {
        return Err(Error::PermissionDenied);
    }

    // 将成员信息注入请求
    request.extensions_mut().insert(member);

    Ok(next.run(request).await)
}
```

### 1.5 邮件验证

```rust
use lettre::{
    Message, SmtpTransport, Transport,
    transport::smtp::authentication::Credentials,
};

pub struct EmailService {
    smtp: SmtpTransport,
    from: String,
}

impl EmailService {
    /// 发送验证邮件
    pub async fn send_verification_email(
        &self,
        to: &str,
        token: &str,
    ) -> Result<()> {
        let verification_url = format!(
            "https://synctv.example.com/verify-email?token={}",
            token
        );

        let email = Message::builder()
            .from(self.from.parse()?)
            .to(to.parse()?)
            .subject("验证您的SyncTV邮箱")
            .body(format!(
                "请点击以下链接验证您的邮箱:\n\n{}\n\n此链接24小时内有效。",
                verification_url
            ))?;

        self.smtp.send(&email)?;

        Ok(())
    }

    /// 发送密码重置邮件
    pub async fn send_password_reset_email(
        &self,
        to: &str,
        token: &str,
    ) -> Result<()> {
        let reset_url = format!(
            "https://synctv.example.com/reset-password?token={}",
            token
        );

        let email = Message::builder()
            .from(self.from.parse()?)
            .to(to.parse()?)
            .subject("重置您的SyncTV密码")
            .body(format!(
                "请点击以下链接重置您的密码:\n\n{}\n\n此链接1小时内有效。\n\n如果您没有请求重置密码,请忽略此邮件。",
                reset_url
            ))?;

        self.smtp.send(&email)?;

        Ok(())
    }
}
```

---

## 2. 传输与数据安全

### 2.1 HTTPS/TLS 配置

```rust
use rustls::{ServerConfig, Certificate, PrivateKey};
use rustls_pemfile::{certs, pkcs8_private_keys};
use std::fs::File;
use std::io::BufReader;

pub fn load_tls_config(cert_path: &str, key_path: &str) -> Result<ServerConfig> {
    let cert_file = File::open(cert_path)?;
    let key_file = File::open(key_path)?;

    let cert_chain = certs(&mut BufReader::new(cert_file))?
        .into_iter()
        .map(Certificate)
        .collect();

    let mut keys = pkcs8_private_keys(&mut BufReader::new(key_file))?;
    let key = PrivateKey(keys.remove(0));

    let config = ServerConfig::builder()
        .with_safe_default_cipher_suites()
        .with_safe_default_kx_groups()
        .with_protocol_versions(&[&rustls::version::TLS13, &rustls::version::TLS12])?
        .with_no_client_auth()
        .with_single_cert(cert_chain, key)?;

    Ok(config)
}

// 启动HTTPS服务器
pub async fn run_https_server(app: Router, config: &Config) -> Result<()> {
    let tls_config = load_tls_config(
        &config.tls.cert_path,
        &config.tls.key_path,
    )?;

    let addr = format!("{}:{}", config.server.address, config.server.https_port)
        .parse()?;

    axum_server::bind_rustls(addr, tls_config)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}
```

### 2.2 CORS 配置

```rust
use tower_http::cors::{CorsLayer, Any};
use http::Method;

pub fn cors_layer(allowed_origins: Vec<String>) -> CorsLayer {
    let origins: Vec<HeaderValue> = allowed_origins
        .into_iter()
        .filter_map(|origin| origin.parse().ok())
        .collect();

    CorsLayer::new()
        .allow_origin(origins)
        .allow_methods([
            Method::GET,
            Method::POST,
            Method::PUT,
            Method::DELETE,
            Method::OPTIONS,
        ])
        .allow_headers([
            header::AUTHORIZATION,
            header::CONTENT_TYPE,
            header::ACCEPT,
        ])
        .allow_credentials(true)
        .max_age(Duration::from_secs(3600))
}
```

### 2.3 数据加密

```rust
use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm, Nonce,
};

pub struct DataEncryptor {
    cipher: Aes256Gcm,
}

impl DataEncryptor {
    pub fn new(key: &[u8; 32]) -> Self {
        let cipher = Aes256Gcm::new(key.into());
        Self { cipher }
    }

    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>> {
        let nonce = Nonce::from_slice(&rand::random::<[u8; 12]>());
        let ciphertext = self.cipher
            .encrypt(nonce, plaintext)
            .map_err(|e| Error::EncryptionFailed(e.to_string()))?;

        // 将nonce和ciphertext拼接
        let mut result = nonce.to_vec();
        result.extend_from_slice(&ciphertext);

        Ok(result)
    }

    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>> {
        if ciphertext.len() < 12 {
            return Err(Error::InvalidCiphertext);
        }

        let (nonce_bytes, encrypted) = ciphertext.split_at(12);
        let nonce = Nonce::from_slice(nonce_bytes);

        self.cipher
            .decrypt(nonce, encrypted)
            .map_err(|e| Error::DecryptionFailed(e.to_string()))
    }
}
```

---

## 3. 输入验证与防攻击

### 3.1 参数验证

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateRoomRequest {
    #[validate(length(min = 1, max = 50, message = "房间名称必须在1-50字符之间"))]
    pub name: String,

    #[validate(length(max = 500, message = "描述不能超过500字符"))]
    pub description: Option<String>,

    #[validate(length(min = 6, max = 32, message = "密码必须在6-32字符之间"))]
    pub password: Option<String>,

    #[validate]
    pub settings: RoomSettings,
}

// 自动验证
pub async fn create_room(
    State(state): State<AppState>,
    Extension(user): Extension<User>,
    Json(req): Json<CreateRoomRequest>,
) -> Result<Json<Room>> {
    // 验证请求
    req.validate()?;

    // 创建房间
    let room = state.room_service.create_room(user.id, req).await?;

    Ok(Json(room))
}
```

### 3.2 SQL 注入防护

使用SQLx的参数化查询自动防止SQL注入:

```rust
// ✅ 安全：使用占位符
pub async fn get_user_by_username(
    pool: &PgPool,
    username: &str,
) -> Result<Option<User>> {
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE username = $1",
        username
    )
    .fetch_optional(pool)
    .await?;

    Ok(user)
}

// ❌ 危险：字符串拼接（永远不要这样做）
// let query = format!("SELECT * FROM users WHERE username = '{}'", username);
```

### 3.3 XSS 防护

```rust
use ammonia::clean;

pub struct ContentFilter {
    html_cleaner: Ammonia,
}

impl ContentFilter {
    /// 清理HTML内容,防止XSS
    pub fn sanitize_html(&self, content: &str) -> String {
        clean(content)
    }

    /// 转义文本
    pub fn escape_text(&self, text: &str) -> String {
        text.replace('&', "&amp;")
            .replace('<', "&lt;")
            .replace('>', "&gt;")
            .replace('"', "&quot;")
            .replace('\'', "&#x27;")
    }

    /// 过滤敏感词
    pub async fn filter(&self, content: &str) -> Result<String> {
        let escaped = self.escape_text(content);
        let filtered = self.filter_sensitive_words(&escaped).await?;
        Ok(filtered)
    }
}
```

### 3.4 Rate Limiting

```rust
use governor::{Quota, RateLimiter as GovernorRateLimiter};
use dashmap::DashMap;

pub struct RateLimiter {
    limiters: Arc<DashMap<String, DefaultDirectRateLimiter>>,
}

impl RateLimiter {
    pub async fn check(
        &self,
        key: &str,
        max_requests: u32,
        period: Duration,
    ) -> bool {
        let limiter = self.limiters
            .entry(key.to_string())
            .or_insert_with(|| {
                let quota = Quota::per_minute(NonZeroU32::new(max_requests).unwrap());
                GovernorRateLimiter::direct(quota)
            });

        limiter.check().is_ok()
    }
}

// Rate limiting 中间件
pub async fn rate_limit_middleware(
    Extension(rate_limiter): Extension<Arc<RateLimiter>>,
    ConnectInfo(addr): ConnectInfo<SocketAddr>,
    request: Request<Body>,
    next: Next,
) -> Result<Response> {
    let key = format!("ip:{}", addr.ip());

    if !rate_limiter.check(&key, 100, Duration::from_secs(60)).await {
        return Err(Error::TooManyRequests { retry_after: 60 });
    }

    Ok(next.run(request).await)
}
```

---

## 4. 常见故障场景

### 4.1 数据库连接失败

#### 检测与恢复

```rust
pub async fn check_database_health(pool: &PgPool) -> HealthStatus {
    match sqlx::query("SELECT 1").fetch_one(pool).await {
        Ok(_) => HealthStatus::Healthy,
        Err(e) => HealthStatus::Unhealthy {
            reason: format!("Database error: {}", e),
        },
    }
}

// 自动重试机制
pub async fn execute_with_retry<F, T>(
    f: F,
    max_retries: u32,
) -> Result<T>
where
    F: Fn() -> BoxFuture<'static, Result<T>>,
{
    let mut retries = 0;

    loop {
        match f().await {
            Ok(result) => return Ok(result),
            Err(e) if retries < max_retries => {
                retries += 1;
                let delay = Duration::from_millis(100 * 2_u64.pow(retries));
                warn!("Retrying in {:?} (attempt {}/{})", delay, retries, max_retries);
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}
```

### 4.2 Redis 故障降级

```rust
pub struct ResilientCache {
    redis: Option<Arc<RedisClient>>,
    local: Arc<LocalCache<String, Arc<Bytes>>>,
}

impl ResilientCache {
    pub async fn get(&self, key: &str) -> Result<Option<Arc<Bytes>>> {
        // 尝试Redis
        if let Some(redis) = &self.redis {
            if let Ok(Some(value)) = redis.get(key).await {
                return Ok(Some(Arc::new(Bytes::from(value))));
            }
        }

        // 降级到本地缓存
        Ok(self.local.get(key).await)
    }

    pub async fn set(&self, key: &str, value: Arc<Bytes>, ttl: u64) -> Result<()> {
        // 写入本地缓存
        self.local.insert(key.to_string(), value.clone(), ttl).await;

        // 尝试写入Redis
        if let Some(redis) = &self.redis {
            redis.set_ex(key, value.as_ref(), ttl).await.ok();
        }

        Ok(())
    }
}
```

### 4.3 Publisher 故障转移

```rust
pub async fn detect_publisher_failure(
    stream_key: &str,
    registry: &ClusterRegistry,
) -> bool {
    if let Ok(Some(publisher_info)) = registry.get_publisher(stream_key).await {
        let last_heartbeat = publisher_info.last_heartbeat;
        let now = Utc::now().timestamp();

        // 超过30秒无心跳认为故障
        (now - last_heartbeat) > 30
    } else {
        true
    }
}

pub async fn failover_publisher(
    stream_key: &str,
    registry: &ClusterRegistry,
    local_node_id: &str,
) -> Result<()> {
    // 1. 获取分布式锁
    let lock_key = format!("lock:stream:failover:{}", stream_key);
    let _lock = registry.acquire_lock(&lock_key, 30).await?;

    // 2. 再次确认故障
    if !detect_publisher_failure(stream_key, registry).await {
        return Ok(());
    }

    // 3. 选举新Publisher (基于一致性哈希)
    let new_publisher = registry.hash_ring.get_node(stream_key);

    // 4. 如果本节点是新Publisher,启动推流
    if new_publisher == local_node_id {
        info!("Taking over as publisher for stream: {}", stream_key);
        registry.register_publisher(stream_key, local_node_id, 300).await?;
        registry.publish_event(ClusterEvent::PublisherChanged {
            stream_key: stream_key.to_string(),
            new_publisher: local_node_id.to_string(),
        }).await?;
    }

    Ok(())
}
```

---

## 5. 熔断器与降级

### 5.1 Circuit Breaker 实现

```rust
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitState>>,
    failure_threshold: u32,
    success_threshold: u32,
    timeout: Duration,

    failure_count: AtomicU32,
    success_count: AtomicU32,
    last_failure_time: AtomicU64,
}

#[derive(Debug, Clone, PartialEq)]
enum CircuitState {
    Closed,      // 正常
    Open,        // 熔断
    HalfOpen,    // 半开（尝试恢复）
}

impl CircuitBreaker {
    pub async fn call<F, T>(&self, f: F) -> Result<T>
    where
        F: Future<Output = Result<T>>,
    {
        let state = self.state.read().await.clone();

        match state {
            CircuitState::Open => {
                let now = Utc::now().timestamp() as u64;
                let last_failure = self.last_failure_time.load(Ordering::Relaxed);

                if now - last_failure > self.timeout.as_secs() {
                    *self.state.write().await = CircuitState::HalfOpen;
                } else {
                    return Err(Error::CircuitBreakerOpen);
                }
            }
            _ => {}
        }

        match f.await {
            Ok(result) => {
                self.on_success().await;
                Ok(result)
            }
            Err(e) => {
                self.on_failure().await;
                Err(e)
            }
        }
    }
}
```

### 5.2 服务降级

```rust
pub async fn get_room_info(
    state: &AppState,
    room_id: Uuid,
) -> Result<Room> {
    // 尝试从缓存获取
    if let Ok(Some(room)) = state.cache.get_room(room_id).await {
        return Ok(room);
    }

    // 使用熔断器保护数据库查询
    match state.db_circuit_breaker.call(async {
        state.db.get_room(room_id).await
    }).await {
        Ok(room) => {
            state.cache.set_room(room_id, &room).await.ok();
            Ok(room)
        }
        Err(Error::CircuitBreakerOpen) => {
            warn!("Database circuit breaker open, returning degraded response");
            Err(Error::ServiceDegraded)
        }
        Err(e) => Err(e),
    }
}
```

---

## 6. 审计与监控

### 6.1 审计日志

```rust
pub struct AuditLogger {
    db: Arc<PgPool>,
}

#[derive(Debug)]
pub struct AuditLog {
    pub id: Uuid,
    pub user_id: Uuid,
    pub action: String,
    pub resource_type: String,
    pub resource_id: String,
    pub details: serde_json::Value,
    pub ip_address: String,
    pub user_agent: String,
    pub created_at: DateTime<Utc>,
}

impl AuditLogger {
    pub async fn log(
        &self,
        user_id: Uuid,
        action: &str,
        resource_type: &str,
        resource_id: &str,
        details: serde_json::Value,
        ip_address: String,
        user_agent: String,
    ) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO audit_logs (id, user_id, action, resource_type, resource_id, details, ip_address, user_agent, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            "#,
            Uuid::new_v4(),
            user_id,
            action,
            resource_type,
            resource_id,
            details,
            ip_address,
            user_agent,
            Utc::now(),
        )
        .execute(&*self.db)
        .await?;

        Ok(())
    }
}
```

### 6.2 优雅关闭

```rust
pub async fn graceful_shutdown(
    server_handle: ServerHandle,
    cluster_sync: Arc<ClusterSync>,
    stream_hub: Arc<StreamHub>,
    room_hub: Arc<RoomHub>,
) {
    // 监听关闭信号
    tokio::select! {
        _ = tokio::signal::ctrl_c() => {},
        _ = tokio::signal::unix::signal(
            tokio::signal::unix::SignalKind::terminate()
        ).unwrap().recv() => {},
    }

    info!("Received shutdown signal, starting graceful shutdown...");

    // 1. 停止接受新连接
    server_handle.graceful_shutdown(Some(Duration::from_secs(60)));

    // 2. 停止所有推流
    let active_streams = stream_hub.get_all_streams().await;
    for stream_key in active_streams {
        stream_hub.stop_stream(&stream_key).await.ok();
    }

    // 3. 通知集群节点下线
    cluster_sync.publish_event(ClusterEvent::NodeLeaving {
        node_id: get_local_node_id(),
    }).await.ok();

    // 4. 关闭所有WebSocket连接
    let active_rooms = room_hub.get_all_rooms().await;
    for room_id in active_rooms {
        room_hub.broadcast(
            room_id,
            ServerMessage::ServerShutdown {
                message: "服务器正在维护,请稍后重新连接".to_string(),
            },
            None,
        ).await.ok();
    }

    // 5. 等待所有任务完成
    tokio::time::sleep(Duration::from_secs(5)).await;

    info!("Graceful shutdown completed");
}
```

---

## 总结

本章节设计了一个**现代化、安全**的系统:

✅ **JWT RS256**: 非对称加密,多副本友好
✅ **OAuth2 PKCE**: 增强安全性的OAuth2流程
✅ **Argon2id**: 2023年密码哈希冠军
✅ **权限系统**: Telegram-like,64位掩码,细粒度控制
✅ **邮件验证**: SMTP发送验证/重置邮件
✅ **输入验证**: 防SQL注入、XSS、CSRF
✅ **熔断降级**: Circuit Breaker保护依赖服务
✅ **审计日志**: 记录所有关键操作

**下一章**: [25-附录](./25-附录.md)

---

**上一章**: [23-监控优化](./23-监控优化.md)
**下一章**: [25-附录](./25-附录.md)
