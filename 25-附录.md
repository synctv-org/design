# 16. 附录

---

## 16.1 技术栈详细说明

### 16.1.1 Web框架 - Axum

**选择理由**

- 基于tokio，性能优秀
- 类型安全的路由和提取器
- 优秀的中间件支持
- 良好的生态系统

**核心用法**

```rust
use axum::{
    Router,
    routing::{get, post},
    extract::{Path, Query, State, Json},
    middleware,
    response::IntoResponse,
};

// 应用状态
#[derive(Clone)]
pub struct AppState {
    pub db: Arc<PgPool>,
    pub redis: Arc<RedisClient>,
    pub room_hub: Arc<RoomHub>,
}

// 路由定义
pub fn create_router(state: AppState) -> Router {
    Router::new()
        // 认证路由
        .route("/api/v1/auth/register", post(auth::register))
        .route("/api/v1/auth/login", post(auth::login))

        // 房间路由
        .route("/api/v1/rooms", get(room::list_rooms).post(room::create_room))
        .route("/api/v1/rooms/:id", get(room::get_room))

        // WebSocket
        .route("/api/v1/rooms/:id/ws", get(ws::handle_websocket))

        // 全局中间件
        .layer(middleware::from_fn(request_id_middleware))
        .layer(middleware::from_fn(logging_middleware))
        .layer(middleware::from_fn_with_state(state.clone(), auth_middleware))

        // CORS
        .layer(CorsLayer::permissive())

        // 状态
        .with_state(state)
}

// Handler示例
pub async fn create_room(
    State(state): State<AppState>,
    Extension(user): Extension<User>,
    Json(payload): Json<CreateRoomRequest>,
) -> Result<Json<ApiResponse<Room>>> {
    let room = state.room_service.create_room(
        user.id,
        payload.name,
        payload.password,
    ).await?;

    Ok(Json(ApiResponse::success(room)))
}
```

### 16.1.2 异步运行时 - Tokio

**选择理由**

- Rust异步生态的事实标准
- 高性能的work-stealing调度器
- 丰富的异步原语（channel、mutex、rwlock等）
- 优秀的工具支持（tokio-console）

**核心配置**

```rust
// main.rs
#[tokio::main(flavor = "multi_thread", worker_threads = 8)]
async fn main() -> Result<()> {
    // 初始化运行时
    tokio::runtime::Builder::new_multi_thread()
        .worker_threads(8)
        .thread_name("synctv-worker")
        .thread_stack_size(3 * 1024 * 1024)
        .enable_all()
        .build()?;

    // 启动应用
    run().await
}

// 并发控制
pub async fn process_concurrent<T>(
    items: Vec<T>,
    concurrency: usize,
    f: impl Fn(T) -> BoxFuture<'static, Result<()>>,
) -> Result<()> {
    let semaphore = Arc::new(Semaphore::new(concurrency));

    let tasks: Vec<_> = items
        .into_iter()
        .map(|item| {
            let sem = semaphore.clone();
            let f = f.clone();
            tokio::spawn(async move {
                let _permit = sem.acquire().await?;
                f(item).await
            })
        })
        .collect();

    futures::future::try_join_all(tasks).await?;
    Ok(())
}
```

### 16.1.3 数据库 - SQLx

**选择理由**

- 编译期SQL验证
- 异步支持
- 连接池管理
- 宏自动生成类型

**核心用法**

```rust
use sqlx::{PgPool, postgres::PgPoolOptions};

// 连接池配置
pub async fn create_pool(database_url: &str) -> Result<PgPool> {
    PgPoolOptions::new()
        .max_connections(20)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(3))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .connect(database_url)
        .await
        .map_err(Into::into)
}

// 查询宏（编译期验证）
pub async fn get_user_by_id(
    pool: &PgPool,
    user_id: i64,
) -> Result<Option<User>> {
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, role, created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(pool)
    .await?;

    Ok(user)
}

// 事务
pub async fn transfer_room_ownership(
    pool: &PgPool,
    room_id: i64,
    from_user_id: i64,
    to_user_id: i64,
) -> Result<()> {
    let mut tx = pool.begin().await?;

    // 更新房间所有者
    sqlx::query!(
        "UPDATE rooms SET creator_id = $1 WHERE id = $2 AND creator_id = $3",
        to_user_id,
        room_id,
        from_user_id
    )
    .execute(&mut *tx)
    .await?;

    // 更新成员角色
    sqlx::query!(
        "UPDATE room_members SET role = 'creator' WHERE room_id = $1 AND user_id = $2",
        room_id,
        to_user_id
    )
    .execute(&mut *tx)
    .await?;

    sqlx::query!(
        "UPDATE room_members SET role = 'member' WHERE room_id = $1 AND user_id = $2",
        room_id,
        from_user_id
    )
    .execute(&mut *tx)
    .await?;

    tx.commit().await?;
    Ok(())
}
```

### 16.1.4 缓存 - Redis

**选择理由**

- 高性能键值存储
- Pub/Sub消息总线
- 丰富的数据结构
- 成熟的生态系统

**核心用法**

```rust
use redis::{aio::ConnectionManager, AsyncCommands, RedisError};

// 连接管理
pub async fn create_redis_client(url: &str) -> Result<ConnectionManager> {
    let client = redis::Client::open(url)?;
    let conn = ConnectionManager::new(client).await?;
    Ok(conn)
}

// 基础操作
pub struct RedisCache {
    conn: ConnectionManager,
}

impl RedisCache {
    pub async fn get(&mut self, key: &str) -> Result<Option<Vec<u8>>> {
        self.conn.get(key).await.map_err(Into::into)
    }

    pub async fn set_ex(&mut self, key: &str, value: &[u8], ttl: u64) -> Result<()> {
        self.conn.set_ex(key, value, ttl).await.map_err(Into::into)
    }

    pub async fn incr(&mut self, key: &str) -> Result<i64> {
        self.conn.incr(key, 1).await.map_err(Into::into)
    }

    pub async fn expire(&mut self, key: &str, ttl: u64) -> Result<bool> {
        self.conn.expire(key, ttl as i64).await.map_err(Into::into)
    }
}

// Pub/Sub
pub async fn subscribe_events<F>(
    client: redis::Client,
    channel: &str,
    mut handler: F,
) -> Result<()>
where
    F: FnMut(Vec<u8>) -> BoxFuture<'static, Result<()>>,
{
    let mut pubsub = client.get_async_connection().await?.into_pubsub();
    pubsub.subscribe(channel).await?;

    let mut stream = pubsub.on_message();
    while let Some(msg) = stream.next().await {
        let payload = msg.get_payload_bytes();
        if let Err(e) = handler(payload.to_vec()).await {
            error!("Handle message error: {}", e);
        }
    }

    Ok(())
}
```

### 16.1.5 流媒体引擎 - Xiu

**选择理由**

- 纯Rust实现，安全性高
- 支持RTMP/HLS/FLV/RTSP多协议
- 内置流转发功能
- 模块化设计易于集成

**核心集成**

```rust
use xiu::{
    rtmp::{RtmpServer, RtmpServerConfig},
    http::{HttpServer, HttpServerConfig},
    stream::{StreamHub, StreamIdentifier},
};

pub struct XiuIntegration {
    stream_hub: Arc<StreamHub>,
    notifier: Arc<SyncTvNotifier>,
}

impl XiuIntegration {
    pub async fn start(&self, config: &Config) -> Result<()> {
        // RTMP服务器
        let rtmp_config = RtmpServerConfig {
            address: config.rtmp_listen_address.clone(),
            port: config.rtmp_port,
            ..Default::default()
        };

        let rtmp_server = RtmpServer::new(
            rtmp_config,
            self.stream_hub.clone(),
            Some(self.notifier.clone()),
        );

        // HTTP服务器（HLS/FLV）
        let http_config = HttpServerConfig {
            address: config.http_listen_address.clone(),
            port: config.http_port,
            ..Default::default()
        };

        let http_server = HttpServer::new(
            http_config,
            self.stream_hub.clone(),
        );

        // 并发启动
        tokio::try_join!(
            rtmp_server.run(),
            http_server.run(),
        )?;

        Ok(())
    }
}

// 事件通知器
#[async_trait]
impl xiu::Notifier for SyncTvNotifier {
    async fn on_publish(&self, stream_id: StreamIdentifier) -> Result<()> {
        let stream_key = format!("{}_{}", stream_id.app_name, stream_id.stream_name);

        // 验证stream_key
        self.validate_stream_key(&stream_key).await?;

        // 注册到集群
        self.cluster_registry.register_stream_master(
            &stream_key,
            &self.local_node_id,
            300,
        ).await?;

        // 通知其他节点
        self.cluster_sync.publish_event(ClusterEvent::StreamStarted {
            stream_key,
            master_node_id: self.local_node_id.clone(),
            timestamp: Utc::now().timestamp_millis(),
        }).await?;

        Ok(())
    }

    async fn on_unpublish(&self, stream_id: StreamIdentifier) -> Result<()> {
        let stream_key = format!("{}_{}", stream_id.app_name, stream_id.stream_name);

        // 通知集群
        self.cluster_sync.publish_event(ClusterEvent::StreamStopped {
            stream_key: stream_key.clone(),
            timestamp: Utc::now().timestamp_millis(),
        }).await?;

        // 清理注册
        self.cluster_registry.unregister_stream(&stream_key).await?;

        Ok(())
    }
}
```

### 16.1.6 gRPC - Tonic

**选择理由**

- 高性能的gRPC实现
- 基于tokio异步运行时
- 自动生成代码
- 支持流式传输

**核心用法**

```rust
// 服务端实现
pub struct StreamRelayServiceImpl {
    stream_hub: Arc<StreamHub>,
}

#[tonic::async_trait]
impl StreamRelayService for StreamRelayServiceImpl {
    type PullRtmpStreamStream = ReceiverStream<Result<RtmpPacket, Status>>;

    async fn pull_rtmp_stream(
        &self,
        request: Request<PullRtmpRequest>,
    ) -> Result<Response<Self::PullRtmpStreamStream>, Status> {
        let req = request.into_inner();

        // 订阅流
        let (tx, rx) = mpsc::channel(100);
        let stream_key = req.stream_key.clone();

        tokio::spawn(async move {
            let mut subscriber = self.stream_hub.subscribe(&stream_key).await?;

            while let Some(packet) = subscriber.recv().await {
                let grpc_packet = RtmpPacket {
                    packet_type: packet.packet_type as i32,
                    timestamp: packet.timestamp as i64,
                    data: packet.data.to_vec(),
                };

                if tx.send(Ok(grpc_packet)).await.is_err() {
                    break;
                }
            }

            Ok::<(), Error>(())
        });

        Ok(Response::new(ReceiverStream::new(rx)))
    }
}

// 客户端
pub struct StreamRelayClient {
    client: StreamRelayServiceClient<Channel>,
}

impl StreamRelayClient {
    pub async fn new(addr: String) -> Result<Self> {
        let channel = Channel::from_shared(addr)?
            .connect()
            .await?;

        let client = StreamRelayServiceClient::new(channel);

        Ok(Self { client })
    }

    pub async fn pull_stream(&mut self, stream_key: String) -> Result<()> {
        let request = PullRtmpRequest {
            stream_key: stream_key.clone(),
            requesting_node_id: get_local_node_id(),
        };

        let mut stream = self.client
            .pull_rtmp_stream(request)
            .await?
            .into_inner();

        while let Some(packet) = stream.message().await? {
            // 处理包
            process_packet(stream_key.clone(), packet).await?;
        }

        Ok(())
    }
}
```

### 16.1.7 序列化 - Serde

**选择理由**

- Rust序列化的标准库
- 零拷贝反序列化
- 支持多种格式（JSON、TOML、MessagePack）
- 宏自动派生

**核心用法**

```rust
use serde::{Serialize, Deserialize};

// 基础派生
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct User {
    pub id: i64,
    pub username: String,
    pub email: String,

    #[serde(skip)]
    pub password_hash: String,  // 跳过序列化

    #[serde(default)]
    pub created_at: DateTime<Utc>,  // 使用默认值
}

// 自定义序列化
#[derive(Serialize, Deserialize)]
pub struct Room {
    pub id: i64,

    #[serde(rename = "roomName")]  // 重命名字段
    pub name: String,

    #[serde(skip_serializing_if = "Option::is_none")]  // None时跳过
    pub password: Option<String>,

    #[serde(with = "timestamp_format")]  // 自定义格式
    pub created_at: DateTime<Utc>,
}

// 自定义时间戳格式
mod timestamp_format {
    use super::*;
    use serde::{Deserializer, Serializer};

    pub fn serialize<S>(date: &DateTime<Utc>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_i64(date.timestamp_millis())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<DateTime<Utc>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let timestamp = i64::deserialize(deserializer)?;
        Ok(DateTime::from_timestamp_millis(timestamp).unwrap())
    }
}
```

### 16.1.8 日志 - Tracing

**选择理由**

- 结构化日志
- 分布式追踪支持
- 异步友好
- 丰富的订阅者

**核心用法**

```rust
use tracing::{info, warn, error, debug, instrument};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// 初始化日志
pub fn init_tracing() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "synctv=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
}

// 使用宏
#[instrument(skip(db), fields(user_id = %user_id))]
pub async fn get_user(db: &PgPool, user_id: i64) -> Result<User> {
    debug!("Fetching user from database");

    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
        .fetch_one(db)
        .await?;

    info!(username = %user.username, "User fetched successfully");
    Ok(user)
}

// 结构化日志
info!(
    room_id = 123,
    user_count = 5,
    "Room status updated"
);

// Span追踪
use tracing::Span;

let span = tracing::info_span!("process_video", video_id = 456);
let _enter = span.enter();

// span内的所有日志都会带上video_id=456
info!("Starting video processing");
process_video().await?;
info!("Video processing completed");
```

### 16.1.9 错误处理 - Thiserror + Anyhow

**选择理由**

- thiserror：库错误定义
- anyhow：应用错误处理
- 良好的错误链支持
- 自动派生Display

**核心用法**

```rust
use thiserror::Error;
use anyhow::{Context, Result};

// 定义错误类型
#[derive(Error, Debug)]
pub enum SyncTvError {
    #[error("User not found: {0}")]
    UserNotFound(i64),

    #[error("Room not found: {0}")]
    RoomNotFound(i64),

    #[error("Permission denied: {required:?}")]
    PermissionDenied {
        required: Permission,
    },

    #[error("Database error")]
    Database(#[from] sqlx::Error),

    #[error("Redis error")]
    Redis(#[from] redis::RedisError),

    #[error("Invalid stream key")]
    InvalidStreamKey,
}

// 使用anyhow简化错误处理
pub async fn create_room(
    db: &PgPool,
    user_id: i64,
    name: String,
) -> Result<Room> {
    // 自动转换错误
    let user = get_user(db, user_id)
        .await
        .context("Failed to fetch user")?;

    // 添加上下文
    let room = sqlx::query_as!(...)
        .fetch_one(db)
        .await
        .with_context(|| format!("Failed to create room '{}'", name))?;

    Ok(room)
}

// 错误响应转换
impl IntoResponse for SyncTvError {
    fn into_response(self) -> Response {
        let (status, code, message) = match self {
            Self::UserNotFound(id) => (
                StatusCode::NOT_FOUND,
                error_codes::USER_NOT_FOUND,
                format!("User {} not found", id),
            ),
            Self::PermissionDenied { required } => (
                StatusCode::FORBIDDEN,
                error_codes::PERMISSION_DENIED,
                format!("Permission denied: {:?}", required),
            ),
            _ => (
                StatusCode::INTERNAL_SERVER_ERROR,
                error_codes::INTERNAL_ERROR,
                "Internal server error".to_string(),
            ),
        };

        let body = Json(ErrorResponse {
            code,
            message,
            details: None,
        });

        (status, body).into_response()
    }
}
```

---

## 16.2 Cargo.toml完整配置

```toml
[package]
name = "synctv"
version = "1.0.0"
edition = "2021"
authors = ["SyncTV Team"]
description = "A real-time synchronized video watching platform"

[workspace]
members = ["synctv", "livelib"]

[dependencies]
# Web框架
axum = { version = "0.7", features = ["ws", "macros"] }
axum-server = { version = "0.6", features = ["tls-rustls"] }
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["fs", "trace", "cors", "compression-full"] }

# 异步运行时
tokio = { version = "1", features = ["full"] }
tokio-stream = "0.1"
tokio-util = "0.7"
futures = "0.3"

# 数据库
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "macros", "migrate", "uuid", "chrono"] }

# Redis
redis = { version = "0.24", features = ["tokio-comp", "connection-manager"] }
deadpool-redis = "0.14"

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# 时间处理
chrono = { version = "0.4", features = ["serde"] }

# UUID
uuid = { version = "1", features = ["v4", "serde"] }

# 日志
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# 错误处理
thiserror = "1"
anyhow = "1"

# 认证
jsonwebtoken = "9"
argon2 = "0.5"

# 加密
aes-gcm = "0.10"
rand = "0.8"

# 输入验证
validator = { version = "0.16", features = ["derive"] }

# HTML清理
ammonia = "3"

# gRPC
tonic = { version = "0.11", features = ["tls"] }
prost = "0.12"

# 并发工具
dashmap = "5"
parking_lot = "0.12"

# 缓存
lru = "0.12"

# Rate limiting
governor = "0.6"

# HTTP客户端
reqwest = { version = "0.11", features = ["json", "stream"] }

# WebSocket
tokio-tungstenite = "0.21"

# 配置管理
config = "0.14"

# 字节操作
bytes = "1"

# 流媒体（xiu集成）
xiu = { git = "https://github.com/harlanc/xiu", branch = "master" }

# Kubernetes客户端（可选）
kube = { version = "0.88", optional = true, features = ["runtime", "derive"] }
k8s-openapi = { version = "0.21", optional = true, features = ["v1_28"] }

[build-dependencies]
tonic-build = "0.11"

[dev-dependencies]
criterion = "0.5"
mockall = "0.12"

[features]
default = []
kubernetes = ["kube", "k8s-openapi"]

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

[[bin]]
name = "synctv"
path = "synctv/src/main.rs"

[[bench]]
name = "performance"
harness = false
```

---

## 16.3 数据库迁移示例

```sql
-- migrations/20240101000001_initial_schema.up.sql

-- 用户表
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'user',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);

-- 房间表
CREATE TABLE rooms (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    creator_id BIGINT NOT NULL REFERENCES users(id),
    password_hash VARCHAR(255),
    settings JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_rooms_creator ON rooms(creator_id);
CREATE INDEX idx_rooms_created ON rooms(created_at DESC);

-- 房间成员表
CREATE TABLE room_members (
    room_id BIGINT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL DEFAULT 'member',
    permissions BIGINT NOT NULL DEFAULT 31,
    admin_permissions BIGINT NOT NULL DEFAULT 0,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (room_id, user_id)
);

CREATE INDEX idx_room_members_user ON room_members(user_id);

-- 影片表
CREATE TABLE movies (
    id BIGSERIAL PRIMARY KEY,
    room_id BIGINT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    url TEXT NOT NULL,
    type VARCHAR(50) NOT NULL,
    headers JSONB,
    subtitles JSONB,
    parsed_info JSONB,
    creator_id BIGINT NOT NULL REFERENCES users(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_movies_room ON movies(room_id, created_at DESC);

-- 房间当前状态表
CREATE TABLE room_current_state (
    room_id BIGINT PRIMARY KEY REFERENCES rooms(id) ON DELETE CASCADE,
    movie_id BIGINT REFERENCES movies(id) ON DELETE SET NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'paused',
    current_time DOUBLE PRECISION NOT NULL DEFAULT 0,
    rate DOUBLE PRECISION NOT NULL DEFAULT 1.0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 聊天消息表
CREATE TABLE chat_messages (
    id VARCHAR(36) PRIMARY KEY,
    room_id BIGINT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    username VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'text',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_chat_messages_room_time ON chat_messages(room_id, created_at DESC);

-- 自动清理触发器
CREATE OR REPLACE FUNCTION cleanup_old_messages()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM chat_messages
    WHERE room_id = NEW.room_id
    AND id NOT IN (
        SELECT id FROM chat_messages
        WHERE room_id = NEW.room_id
        ORDER BY created_at DESC
        LIMIT 500
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cleanup_messages
AFTER INSERT ON chat_messages
FOR EACH ROW
EXECUTE FUNCTION cleanup_old_messages();

-- 审计日志表
CREATE TABLE audit_logs (
    id VARCHAR(36) PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id),
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id VARCHAR(100) NOT NULL,
    details JSONB,
    ip_address VARCHAR(45) NOT NULL,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id, created_at DESC);

-- updated_at自动更新
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER trigger_rooms_updated_at
BEFORE UPDATE ON rooms
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();
```

---

## 16.4 环境变量配置

```bash
# .env.example

# Server Configuration
HTTP_ADDRESS=0.0.0.0
HTTP_PORT=8080
RTMP_ADDRESS=0.0.0.0
RTMP_PORT=1935

# Database
DATABASE_URL=postgresql://synctv:password@localhost:5432/synctv
DATABASE_MAX_CONNECTIONS=50
DATABASE_MIN_CONNECTIONS=10

# Redis
REDIS_URL=redis://localhost:6379
REDIS_MAX_CONNECTIONS=20

# JWT
JWT_SECRET=your-secret-key-here-change-in-production
JWT_EXPIRATION=86400

# Cluster
CLUSTER_DISCOVERY_METHOD=kubernetes  # or "static"
CLUSTER_SERVICE_NAME=synctv
CLUSTER_NAMESPACE=synctv

# HLS
HLS_SEGMENT_DURATION=2
HLS_PLAYLIST_LENGTH=6
HLS_CACHE_PATH=/data/hls

# Cache
FILE_CACHE_PATH=/data/cache
FILE_CACHE_MAX_SIZE=53687091200  # 50GB
REDIS_CACHE_MAX_SIZE=10737418240  # 10GB

# Limits
MAX_ROOM_MEMBERS=100
MAX_CONCURRENT_STREAMS=50

# Logging
RUST_LOG=synctv=info,tower_http=info
LOG_FORMAT=json
```

---

## 16.5 性能基准测试

```rust
// benches/performance.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use synctv::cache::LocalCache;
use bytes::Bytes;
use std::sync::Arc;

fn benchmark_cache_operations(c: &mut Criterion) {
    let runtime = tokio::runtime::Runtime::new().unwrap();
    let cache = Arc::new(LocalCache::<String, Arc<Bytes>>::new(1000));

    c.bench_function("cache_insert", |b| {
        b.to_async(&runtime).iter(|| async {
            let key = format!("key_{}", rand::random::<u32>());
            let value = Arc::new(Bytes::from(vec![0u8; 1024]));
            cache.insert(key, value, 60).await;
        });
    });

    c.bench_function("cache_get", |b| {
        b.to_async(&runtime).iter(|| async {
            let key = format!("key_{}", rand::random::<u32>() % 1000);
            black_box(cache.get(&key).await);
        });
    });
}

criterion_group!(benches, benchmark_cache_operations);
criterion_main!(benches);
```

**运行基准测试**

```bash
# 运行所有基准测试
cargo bench

# 运行特定测试
cargo bench --bench performance

# 生成HTML报告
cargo bench -- --save-baseline main

# 对比基准
cargo bench -- --baseline main
```

**性能指标说明**

| 指标 | 说明 | 目标值 |
|------|------|--------|
| Cache Insert | 缓存插入延迟 | < 100μs |
| Cache Get | 缓存读取延迟 | < 50μs |
| DB Query | 数据库查询延迟 | < 10ms |
| WebSocket Latency | WebSocket消息延迟 | < 50ms |
| RTMP Processing | RTMP包处理延迟 | < 5ms |
| Memory Usage | 内存使用（每房间） | < 10MB |
| CPU Usage | CPU使用率 | < 80% |

---

## 16.6 术语表

| 术语 | 英文 | 解释 |
|------|------|------|
| GOP | Group of Pictures | 一组连续的视频帧，从一个关键帧开始到下一个关键帧之前 |
| HLS | HTTP Live Streaming | 苹果公司推出的流媒体协议，基于HTTP |
| FLV | Flash Video | Adobe Flash使用的视频格式 |
| RTMP | Real-Time Messaging Protocol | 实时消息传输协议，用于音视频流传输 |
| WebSocket | - | 全双工通信协议，基于TCP，支持双向实时通信 |
| JWT | JSON Web Token | 用于身份验证的token格式，包含Header、Payload和Signature |
| gRPC | gRPC Remote Procedure Call | Google开发的高性能RPC框架，基于HTTP/2和Protocol Buffers |
| Redis Pub/Sub | Redis Publish/Subscribe | Redis的发布/订阅消息模式，用于分布式消息传递 |
| 一致性哈希 | Consistent Hashing | 用于分布式系统的负载均衡算法，支持动态扩缩容 |
| 零拷贝 | Zero-copy | 避免数据在内存中的额外拷贝，提升性能 |
| Headless Service | - | Kubernetes中不分配ClusterIP的服务类型，用于Pod间直接通信 |
| StatefulSet | - | Kubernetes中有状态应用的控制器，提供稳定的网络标识 |
| CDN | Content Delivery Network | 内容分发网络，用于加速内容分发 |
| CORS | Cross-Origin Resource Sharing | 跨域资源共享，浏览器安全机制 |
| TLS | Transport Layer Security | 传输层安全协议，用于加密通信 |
| ACL | Access Control List | 访问控制列表，用于权限管理 |
| RBAC | Role-Based Access Control | 基于角色的访问控制 |
| Sharding | - | 数据分片，用于数据库水平扩展 |
| Circuit Breaker | - | 熔断器，防止系统雪崩的保护机制 |
| Rate Limiting | - | 速率限制，防止滥用API |
| Dead Letter Queue | - | 死信队列，用于处理失败的消息 |
| Idempotent | - | 幂等性，多次执行结果相同 |
| Saga Pattern | - | Saga模式，分布式事务解决方案 |
| CQRS | Command Query Responsibility Segregation | 命令查询职责分离模式 |
| Event Sourcing | - | 事件溯源，存储所有状态变更事件 |
| CAP定理 | CAP Theorem | 一致性、可用性、分区容错性三者不可兼得 |
| BASE | Basically Available, Soft state, Eventually consistent | 基本可用、软状态、最终一致性 |
| Raft | - | 分布式共识算法 |
| Load Balancer | - | 负载均衡器，分发请求到多个节点 |
| Health Check | - | 健康检查，监控服务状态 |
| Graceful Shutdown | - | 优雅关闭，确保请求完成后再关闭 |
| Backpressure | - | 背压，流控机制 |
| Tokio | - | Rust异步运行时 |
| Axum | - | 基于tokio的Web框架 |
| SQLx | - | Rust异步SQL库，支持编译期验证 |
| Serde | - | Rust序列化/反序列化框架 |
| Tracing | - | Rust结构化日志和追踪库 |
| Thiserror | - | Rust错误类型派生宏 |
| Anyhow | - | Rust错误处理简化库 |
| Tonic | - | Rust gRPC框架 |
| DashMap | - | 高性能并发HashMap |
| Parking Lot | - | 更快的同步原语实现 |

**流媒体术语**

| 术语 | 解释 |
|------|------|
| I帧 | Intra-coded frame，关键帧，完整的图像帧 |
| P帧 | Predicted frame，预测帧，参考前一帧的差异 |
| B帧 | Bidirectional predicted frame，双向预测帧 |
| 码率 | Bitrate，单位时间内的数据量，影响视频质量 |
| 帧率 | Frame Rate，每秒显示的帧数（fps） |
| 分辨率 | Resolution，视频的宽高像素数 |
| AAC | Advanced Audio Coding，先进音频编码 |
| H.264 | 视频编码标准，也称AVC |
| H.265 | 视频编码标准，也称HEVC，压缩率更高 |
| VP9 | Google开发的视频编码格式 |
| AV1 | 新一代开源视频编码格式 |
| M3U8 | HLS的播放列表文件格式 |
| TS文件 | Transport Stream，HLS的视频片段格式 |
| 转码 | Transcoding，转换视频编码格式 |
| 转封装 | Transmuxing，改变容器格式但不重新编码 |

**Rust术语**

| 术语 | 解释 |
|------|------|
| 所有权 | Ownership，Rust内存管理核心概念 |
| 借用 | Borrowing，临时访问数据但不拥有 |
| 生命周期 | Lifetime，引用的有效作用域 |
| Trait | Rust的接口/行为抽象 |
| 泛型 | Generics，类型参数化 |
| 宏 | Macro，编译期代码生成 |
| Future | Rust异步编程的核心trait |
| Pin | 固定内存位置，用于异步编程 |
| Send | 可跨线程转移所有权的trait |
| Sync | 可跨线程共享引用的trait |
| Arc | Atomic Reference Counter，原子引用计数 |
| Mutex | Mutual Exclusion，互斥锁 |
| RwLock | Read-Write Lock，读写锁 |
| Channel | 线程间通信管道 |

---

**上一章**: [24-安全故障](./24-安全故障.md)
**返回首页**: [README](./README.md)
